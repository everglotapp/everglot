import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any;
  /** A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
};

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigInt']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigInt']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
};

export type ChineseGuessCharacterQuestion = Node & {
  __typename?: 'ChineseGuessCharacterQuestion';
  character: Scalars['String'];
  createdAt: Scalars['Datetime'];
  hint: Scalars['String'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseGuessCharacterQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `ChineseGuessCharacterQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ChineseGuessCharacterQuestionCondition = {
  /** Checks for equality with the object’s `character` field. */
  character?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `hint` field. */
  hint?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `ChineseGuessCharacterQuestion` object types. All fields are combined with a logical ‘and.’ */
export type ChineseGuessCharacterQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ChineseGuessCharacterQuestionFilter>>;
  /** Filter by the object’s `character` field. */
  character?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `hint` field. */
  hint?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<ChineseGuessCharacterQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ChineseGuessCharacterQuestionFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `ChineseGuessCharacterQuestion` */
export type ChineseGuessCharacterQuestionInput = {
  character: Scalars['String'];
  createdAt?: Maybe<Scalars['Datetime']>;
  hint: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `ChineseGuessCharacterQuestion`. Fields that are set will be updated. */
export type ChineseGuessCharacterQuestionPatch = {
  character?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  hint?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `ChineseGuessCharacterQuestion` values. */
export type ChineseGuessCharacterQuestionsConnection = {
  __typename?: 'ChineseGuessCharacterQuestionsConnection';
  /** A list of edges which contains the `ChineseGuessCharacterQuestion` and cursor to aid in pagination. */
  edges: Array<ChineseGuessCharacterQuestionsEdge>;
  /** A list of `ChineseGuessCharacterQuestion` objects. */
  nodes: Array<Maybe<ChineseGuessCharacterQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChineseGuessCharacterQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ChineseGuessCharacterQuestion` edge in the connection. */
export type ChineseGuessCharacterQuestionsEdge = {
  __typename?: 'ChineseGuessCharacterQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ChineseGuessCharacterQuestion` at the end of the edge. */
  node?: Maybe<ChineseGuessCharacterQuestion>;
};

/** Methods to use when ordering `ChineseGuessCharacterQuestion`. */
export enum ChineseGuessCharacterQuestionsOrderBy {
  CharacterAsc = 'CHARACTER_ASC',
  CharacterDesc = 'CHARACTER_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  HintAsc = 'HINT_ASC',
  HintDesc = 'HINT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type ChineseRandomQuestion = Node & {
  __typename?: 'ChineseRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `ChineseRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ChineseRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `ChineseRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type ChineseRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ChineseRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<ChineseRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ChineseRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `ChineseRandomQuestion` */
export type ChineseRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `ChineseRandomQuestion`. Fields that are set will be updated. */
export type ChineseRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `ChineseRandomQuestion` values. */
export type ChineseRandomQuestionsConnection = {
  __typename?: 'ChineseRandomQuestionsConnection';
  /** A list of edges which contains the `ChineseRandomQuestion` and cursor to aid in pagination. */
  edges: Array<ChineseRandomQuestionsEdge>;
  /** A list of `ChineseRandomQuestion` objects. */
  nodes: Array<Maybe<ChineseRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChineseRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ChineseRandomQuestion` edge in the connection. */
export type ChineseRandomQuestionsEdge = {
  __typename?: 'ChineseRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ChineseRandomQuestion` at the end of the edge. */
  node?: Maybe<ChineseRandomQuestion>;
};

/** Methods to use when ordering `ChineseRandomQuestion`. */
export enum ChineseRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type ChineseWouldYouRatherQuestion = Node & {
  __typename?: 'ChineseWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `ChineseWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ChineseWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `ChineseWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type ChineseWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ChineseWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<ChineseWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ChineseWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `ChineseWouldYouRatherQuestion` */
export type ChineseWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `ChineseWouldYouRatherQuestion`. Fields that are set will be updated. */
export type ChineseWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `ChineseWouldYouRatherQuestion` values. */
export type ChineseWouldYouRatherQuestionsConnection = {
  __typename?: 'ChineseWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `ChineseWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<ChineseWouldYouRatherQuestionsEdge>;
  /** A list of `ChineseWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<ChineseWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChineseWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ChineseWouldYouRatherQuestion` edge in the connection. */
export type ChineseWouldYouRatherQuestionsEdge = {
  __typename?: 'ChineseWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ChineseWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<ChineseWouldYouRatherQuestion>;
};

/** Methods to use when ordering `ChineseWouldYouRatherQuestion`. */
export enum ChineseWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** All input for the create `ChineseGuessCharacterQuestion` mutation. */
export type CreateChineseGuessCharacterQuestionInput = {
  /** The `ChineseGuessCharacterQuestion` to be created by this mutation. */
  chineseGuessCharacterQuestion: ChineseGuessCharacterQuestionInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ChineseGuessCharacterQuestion` mutation. */
export type CreateChineseGuessCharacterQuestionPayload = {
  __typename?: 'CreateChineseGuessCharacterQuestionPayload';
  /** The `ChineseGuessCharacterQuestion` that was created by this mutation. */
  chineseGuessCharacterQuestion?: Maybe<ChineseGuessCharacterQuestion>;
  /** An edge for our `ChineseGuessCharacterQuestion`. May be used by Relay 1. */
  chineseGuessCharacterQuestionEdge?: Maybe<ChineseGuessCharacterQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseGuessCharacterQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `ChineseGuessCharacterQuestion` mutation. */
export type CreateChineseGuessCharacterQuestionPayloadChineseGuessCharacterQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseGuessCharacterQuestionsOrderBy>>;
};

/** All input for the create `ChineseRandomQuestion` mutation. */
export type CreateChineseRandomQuestionInput = {
  /** The `ChineseRandomQuestion` to be created by this mutation. */
  chineseRandomQuestion: ChineseRandomQuestionInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ChineseRandomQuestion` mutation. */
export type CreateChineseRandomQuestionPayload = {
  __typename?: 'CreateChineseRandomQuestionPayload';
  /** The `ChineseRandomQuestion` that was created by this mutation. */
  chineseRandomQuestion?: Maybe<ChineseRandomQuestion>;
  /** An edge for our `ChineseRandomQuestion`. May be used by Relay 1. */
  chineseRandomQuestionEdge?: Maybe<ChineseRandomQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `ChineseRandomQuestion` mutation. */
export type CreateChineseRandomQuestionPayloadChineseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseRandomQuestionsOrderBy>>;
};

/** All input for the create `ChineseWouldYouRatherQuestion` mutation. */
export type CreateChineseWouldYouRatherQuestionInput = {
  /** The `ChineseWouldYouRatherQuestion` to be created by this mutation. */
  chineseWouldYouRatherQuestion: ChineseWouldYouRatherQuestionInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our create `ChineseWouldYouRatherQuestion` mutation. */
export type CreateChineseWouldYouRatherQuestionPayload = {
  __typename?: 'CreateChineseWouldYouRatherQuestionPayload';
  /** The `ChineseWouldYouRatherQuestion` that was created by this mutation. */
  chineseWouldYouRatherQuestion?: Maybe<ChineseWouldYouRatherQuestion>;
  /** An edge for our `ChineseWouldYouRatherQuestion`. May be used by Relay 1. */
  chineseWouldYouRatherQuestionEdge?: Maybe<ChineseWouldYouRatherQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `ChineseWouldYouRatherQuestion` mutation. */
export type CreateChineseWouldYouRatherQuestionPayloadChineseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `EnglishRandomQuestion` mutation. */
export type CreateEnglishRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishRandomQuestion` to be created by this mutation. */
  englishRandomQuestion: EnglishRandomQuestionInput;
};

/** The output of our create `EnglishRandomQuestion` mutation. */
export type CreateEnglishRandomQuestionPayload = {
  __typename?: 'CreateEnglishRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishRandomQuestion` that was created by this mutation. */
  englishRandomQuestion?: Maybe<EnglishRandomQuestion>;
  /** An edge for our `EnglishRandomQuestion`. May be used by Relay 1. */
  englishRandomQuestionEdge?: Maybe<EnglishRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `EnglishRandomQuestion` mutation. */
export type CreateEnglishRandomQuestionPayloadEnglishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishRandomQuestionsOrderBy>>;
};

/** All input for the create `EnglishWord` mutation. */
export type CreateEnglishWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWord` to be created by this mutation. */
  englishWord: EnglishWordInput;
};

/** The output of our create `EnglishWord` mutation. */
export type CreateEnglishWordPayload = {
  __typename?: 'CreateEnglishWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWord` that was created by this mutation. */
  englishWord?: Maybe<EnglishWord>;
  /** An edge for our `EnglishWord`. May be used by Relay 1. */
  englishWordEdge?: Maybe<EnglishWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `EnglishWord` mutation. */
export type CreateEnglishWordPayloadEnglishWordEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWordsOrderBy>>;
};

/** All input for the create `EnglishWouldYouRatherQuestion` mutation. */
export type CreateEnglishWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWouldYouRatherQuestion` to be created by this mutation. */
  englishWouldYouRatherQuestion: EnglishWouldYouRatherQuestionInput;
};

/** The output of our create `EnglishWouldYouRatherQuestion` mutation. */
export type CreateEnglishWouldYouRatherQuestionPayload = {
  __typename?: 'CreateEnglishWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWouldYouRatherQuestion` that was created by this mutation. */
  englishWouldYouRatherQuestion?: Maybe<EnglishWouldYouRatherQuestion>;
  /** An edge for our `EnglishWouldYouRatherQuestion`. May be used by Relay 1. */
  englishWouldYouRatherQuestionEdge?: Maybe<EnglishWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `EnglishWouldYouRatherQuestion` mutation. */
export type CreateEnglishWouldYouRatherQuestionPayloadEnglishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `FrenchRandomQuestion` mutation. */
export type CreateFrenchRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchRandomQuestion` to be created by this mutation. */
  frenchRandomQuestion: FrenchRandomQuestionInput;
};

/** The output of our create `FrenchRandomQuestion` mutation. */
export type CreateFrenchRandomQuestionPayload = {
  __typename?: 'CreateFrenchRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchRandomQuestion` that was created by this mutation. */
  frenchRandomQuestion?: Maybe<FrenchRandomQuestion>;
  /** An edge for our `FrenchRandomQuestion`. May be used by Relay 1. */
  frenchRandomQuestionEdge?: Maybe<FrenchRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `FrenchRandomQuestion` mutation. */
export type CreateFrenchRandomQuestionPayloadFrenchRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchRandomQuestionsOrderBy>>;
};

/** All input for the create `FrenchWord` mutation. */
export type CreateFrenchWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWord` to be created by this mutation. */
  frenchWord: FrenchWordInput;
};

/** The output of our create `FrenchWord` mutation. */
export type CreateFrenchWordPayload = {
  __typename?: 'CreateFrenchWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWord` that was created by this mutation. */
  frenchWord?: Maybe<FrenchWord>;
  /** An edge for our `FrenchWord`. May be used by Relay 1. */
  frenchWordEdge?: Maybe<FrenchWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `FrenchWord` mutation. */
export type CreateFrenchWordPayloadFrenchWordEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWordsOrderBy>>;
};

/** All input for the create `FrenchWouldYouRatherQuestion` mutation. */
export type CreateFrenchWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWouldYouRatherQuestion` to be created by this mutation. */
  frenchWouldYouRatherQuestion: FrenchWouldYouRatherQuestionInput;
};

/** The output of our create `FrenchWouldYouRatherQuestion` mutation. */
export type CreateFrenchWouldYouRatherQuestionPayload = {
  __typename?: 'CreateFrenchWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWouldYouRatherQuestion` that was created by this mutation. */
  frenchWouldYouRatherQuestion?: Maybe<FrenchWouldYouRatherQuestion>;
  /** An edge for our `FrenchWouldYouRatherQuestion`. May be used by Relay 1. */
  frenchWouldYouRatherQuestionEdge?: Maybe<FrenchWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `FrenchWouldYouRatherQuestion` mutation. */
export type CreateFrenchWouldYouRatherQuestionPayloadFrenchWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `GermanRandomQuestion` mutation. */
export type CreateGermanRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanRandomQuestion` to be created by this mutation. */
  germanRandomQuestion: GermanRandomQuestionInput;
};

/** The output of our create `GermanRandomQuestion` mutation. */
export type CreateGermanRandomQuestionPayload = {
  __typename?: 'CreateGermanRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanRandomQuestion` that was created by this mutation. */
  germanRandomQuestion?: Maybe<GermanRandomQuestion>;
  /** An edge for our `GermanRandomQuestion`. May be used by Relay 1. */
  germanRandomQuestionEdge?: Maybe<GermanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `GermanRandomQuestion` mutation. */
export type CreateGermanRandomQuestionPayloadGermanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanRandomQuestionsOrderBy>>;
};

/** All input for the create `GermanWord` mutation. */
export type CreateGermanWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWord` to be created by this mutation. */
  germanWord: GermanWordInput;
};

/** The output of our create `GermanWord` mutation. */
export type CreateGermanWordPayload = {
  __typename?: 'CreateGermanWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWord` that was created by this mutation. */
  germanWord?: Maybe<GermanWord>;
  /** An edge for our `GermanWord`. May be used by Relay 1. */
  germanWordEdge?: Maybe<GermanWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `GermanWord` mutation. */
export type CreateGermanWordPayloadGermanWordEdgeArgs = {
  orderBy?: Maybe<Array<GermanWordsOrderBy>>;
};

/** All input for the create `GermanWouldYouRatherQuestion` mutation. */
export type CreateGermanWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWouldYouRatherQuestion` to be created by this mutation. */
  germanWouldYouRatherQuestion: GermanWouldYouRatherQuestionInput;
};

/** The output of our create `GermanWouldYouRatherQuestion` mutation. */
export type CreateGermanWouldYouRatherQuestionPayload = {
  __typename?: 'CreateGermanWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWouldYouRatherQuestion` that was created by this mutation. */
  germanWouldYouRatherQuestion?: Maybe<GermanWouldYouRatherQuestion>;
  /** An edge for our `GermanWouldYouRatherQuestion`. May be used by Relay 1. */
  germanWouldYouRatherQuestionEdge?: Maybe<GermanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `GermanWouldYouRatherQuestion` mutation. */
export type CreateGermanWouldYouRatherQuestionPayloadGermanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` that was created by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Reads a single `Language` that is related to this `Group`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Group`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Group` mutation. */
export type CreateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the create `GroupUser` mutation. */
export type CreateGroupUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GroupUser` to be created by this mutation. */
  groupUser: GroupUserInput;
};

/** The output of our create `GroupUser` mutation. */
export type CreateGroupUserPayload = {
  __typename?: 'CreateGroupUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  /** The `GroupUser` that was created by this mutation. */
  groupUser?: Maybe<GroupUser>;
  /** An edge for our `GroupUser`. May be used by Relay 1. */
  groupUserEdge?: Maybe<GroupUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
};


/** The output of our create `GroupUser` mutation. */
export type CreateGroupUserPayloadGroupUserEdgeArgs = {
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};

/** All input for the create `InviteToken` mutation. */
export type CreateInviteTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InviteToken` to be created by this mutation. */
  inviteToken: InviteTokenInput;
};

/** The output of our create `InviteToken` mutation. */
export type CreateInviteTokenPayload = {
  __typename?: 'CreateInviteTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InviteToken` that was created by this mutation. */
  inviteToken?: Maybe<InviteToken>;
  /** An edge for our `InviteToken`. May be used by Relay 1. */
  inviteTokenEdge?: Maybe<InviteTokensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `InviteToken`. */
  user?: Maybe<User>;
};


/** The output of our create `InviteToken` mutation. */
export type CreateInviteTokenPayloadInviteTokenEdgeArgs = {
  orderBy?: Maybe<Array<InviteTokensOrderBy>>;
};

/** All input for the create `ItalianRandomQuestion` mutation. */
export type CreateItalianRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianRandomQuestion` to be created by this mutation. */
  italianRandomQuestion: ItalianRandomQuestionInput;
};

/** The output of our create `ItalianRandomQuestion` mutation. */
export type CreateItalianRandomQuestionPayload = {
  __typename?: 'CreateItalianRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianRandomQuestion` that was created by this mutation. */
  italianRandomQuestion?: Maybe<ItalianRandomQuestion>;
  /** An edge for our `ItalianRandomQuestion`. May be used by Relay 1. */
  italianRandomQuestionEdge?: Maybe<ItalianRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `ItalianRandomQuestion` mutation. */
export type CreateItalianRandomQuestionPayloadItalianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianRandomQuestionsOrderBy>>;
};

/** All input for the create `ItalianWord` mutation. */
export type CreateItalianWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWord` to be created by this mutation. */
  italianWord: ItalianWordInput;
};

/** The output of our create `ItalianWord` mutation. */
export type CreateItalianWordPayload = {
  __typename?: 'CreateItalianWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWord` that was created by this mutation. */
  italianWord?: Maybe<ItalianWord>;
  /** An edge for our `ItalianWord`. May be used by Relay 1. */
  italianWordEdge?: Maybe<ItalianWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `ItalianWord` mutation. */
export type CreateItalianWordPayloadItalianWordEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWordsOrderBy>>;
};

/** All input for the create `ItalianWouldYouRatherQuestion` mutation. */
export type CreateItalianWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWouldYouRatherQuestion` to be created by this mutation. */
  italianWouldYouRatherQuestion: ItalianWouldYouRatherQuestionInput;
};

/** The output of our create `ItalianWouldYouRatherQuestion` mutation. */
export type CreateItalianWouldYouRatherQuestionPayload = {
  __typename?: 'CreateItalianWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWouldYouRatherQuestion` that was created by this mutation. */
  italianWouldYouRatherQuestion?: Maybe<ItalianWouldYouRatherQuestion>;
  /** An edge for our `ItalianWouldYouRatherQuestion`. May be used by Relay 1. */
  italianWouldYouRatherQuestionEdge?: Maybe<ItalianWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `ItalianWouldYouRatherQuestion` mutation. */
export type CreateItalianWouldYouRatherQuestionPayloadItalianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `JapaneseRandomQuestion` mutation. */
export type CreateJapaneseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseRandomQuestion` to be created by this mutation. */
  japaneseRandomQuestion: JapaneseRandomQuestionInput;
};

/** The output of our create `JapaneseRandomQuestion` mutation. */
export type CreateJapaneseRandomQuestionPayload = {
  __typename?: 'CreateJapaneseRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseRandomQuestion` that was created by this mutation. */
  japaneseRandomQuestion?: Maybe<JapaneseRandomQuestion>;
  /** An edge for our `JapaneseRandomQuestion`. May be used by Relay 1. */
  japaneseRandomQuestionEdge?: Maybe<JapaneseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `JapaneseRandomQuestion` mutation. */
export type CreateJapaneseRandomQuestionPayloadJapaneseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseRandomQuestionsOrderBy>>;
};

/** All input for the create `JapaneseWouldYouRatherQuestion` mutation. */
export type CreateJapaneseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseWouldYouRatherQuestion` to be created by this mutation. */
  japaneseWouldYouRatherQuestion: JapaneseWouldYouRatherQuestionInput;
};

/** The output of our create `JapaneseWouldYouRatherQuestion` mutation. */
export type CreateJapaneseWouldYouRatherQuestionPayload = {
  __typename?: 'CreateJapaneseWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseWouldYouRatherQuestion` that was created by this mutation. */
  japaneseWouldYouRatherQuestion?: Maybe<JapaneseWouldYouRatherQuestion>;
  /** An edge for our `JapaneseWouldYouRatherQuestion`. May be used by Relay 1. */
  japaneseWouldYouRatherQuestionEdge?: Maybe<JapaneseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `JapaneseWouldYouRatherQuestion` mutation. */
export type CreateJapaneseWouldYouRatherQuestionPayloadJapaneseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `KoreanRandomQuestion` mutation. */
export type CreateKoreanRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanRandomQuestion` to be created by this mutation. */
  koreanRandomQuestion: KoreanRandomQuestionInput;
};

/** The output of our create `KoreanRandomQuestion` mutation. */
export type CreateKoreanRandomQuestionPayload = {
  __typename?: 'CreateKoreanRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanRandomQuestion` that was created by this mutation. */
  koreanRandomQuestion?: Maybe<KoreanRandomQuestion>;
  /** An edge for our `KoreanRandomQuestion`. May be used by Relay 1. */
  koreanRandomQuestionEdge?: Maybe<KoreanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `KoreanRandomQuestion` mutation. */
export type CreateKoreanRandomQuestionPayloadKoreanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanRandomQuestionsOrderBy>>;
};

/** All input for the create `KoreanWouldYouRatherQuestion` mutation. */
export type CreateKoreanWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanWouldYouRatherQuestion` to be created by this mutation. */
  koreanWouldYouRatherQuestion: KoreanWouldYouRatherQuestionInput;
};

/** The output of our create `KoreanWouldYouRatherQuestion` mutation. */
export type CreateKoreanWouldYouRatherQuestionPayload = {
  __typename?: 'CreateKoreanWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanWouldYouRatherQuestion` that was created by this mutation. */
  koreanWouldYouRatherQuestion?: Maybe<KoreanWouldYouRatherQuestion>;
  /** An edge for our `KoreanWouldYouRatherQuestion`. May be used by Relay 1. */
  koreanWouldYouRatherQuestionEdge?: Maybe<KoreanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `KoreanWouldYouRatherQuestion` mutation. */
export type CreateKoreanWouldYouRatherQuestionPayloadKoreanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `Language` mutation. */
export type CreateLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Language` to be created by this mutation. */
  language: LanguageInput;
};

/** The output of our create `Language` mutation. */
export type CreateLanguagePayload = {
  __typename?: 'CreateLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Language` that was created by this mutation. */
  language?: Maybe<Language>;
  /** An edge for our `Language`. May be used by Relay 1. */
  languageEdge?: Maybe<LanguagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Language` mutation. */
export type CreateLanguagePayloadLanguageEdgeArgs = {
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};

/** All input for the create `LanguageSkillLevel` mutation. */
export type CreateLanguageSkillLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LanguageSkillLevel` to be created by this mutation. */
  languageSkillLevel: LanguageSkillLevelInput;
};

/** The output of our create `LanguageSkillLevel` mutation. */
export type CreateLanguageSkillLevelPayload = {
  __typename?: 'CreateLanguageSkillLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LanguageSkillLevel` that was created by this mutation. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** An edge for our `LanguageSkillLevel`. May be used by Relay 1. */
  languageSkillLevelEdge?: Maybe<LanguageSkillLevelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `LanguageSkillLevel` mutation. */
export type CreateLanguageSkillLevelPayloadLanguageSkillLevelEdgeArgs = {
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};

/** All input for the create `Message` mutation. */
export type CreateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` to be created by this mutation. */
  message: MessageInput;
};

/** The output of our create `Message` mutation. */
export type CreateMessagePayload = {
  __typename?: 'CreateMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was created by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Reads a single `Message` that is related to this `Message`. */
  parentMessage?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Message`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Message`. */
  recipientGroup?: Maybe<Group>;
  /** Reads a single `User` that is related to this `Message`. */
  sender?: Maybe<User>;
};


/** The output of our create `Message` mutation. */
export type CreateMessagePayloadMessageEdgeArgs = {
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** All input for the create `MessagePreview` mutation. */
export type CreateMessagePreviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MessagePreview` to be created by this mutation. */
  messagePreview: MessagePreviewInput;
};

/** The output of our create `MessagePreview` mutation. */
export type CreateMessagePreviewPayload = {
  __typename?: 'CreateMessagePreviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Message` that is related to this `MessagePreview`. */
  message?: Maybe<Message>;
  /** The `MessagePreview` that was created by this mutation. */
  messagePreview?: Maybe<MessagePreview>;
  /** An edge for our `MessagePreview`. May be used by Relay 1. */
  messagePreviewEdge?: Maybe<MessagePreviewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MessagePreview` mutation. */
export type CreateMessagePreviewPayloadMessagePreviewEdgeArgs = {
  orderBy?: Maybe<Array<MessagePreviewsOrderBy>>;
};

/** All input for the create `NotificationChannel` mutation. */
export type CreateNotificationChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `NotificationChannel` to be created by this mutation. */
  notificationChannel: NotificationChannelInput;
};

/** The output of our create `NotificationChannel` mutation. */
export type CreateNotificationChannelPayload = {
  __typename?: 'CreateNotificationChannelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `NotificationChannel` that was created by this mutation. */
  notificationChannel?: Maybe<NotificationChannel>;
  /** An edge for our `NotificationChannel`. May be used by Relay 1. */
  notificationChannelEdge?: Maybe<NotificationChannelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `NotificationChannel` mutation. */
export type CreateNotificationChannelPayloadNotificationChannelEdgeArgs = {
  orderBy?: Maybe<Array<NotificationChannelsOrderBy>>;
};

/** All input for the create `Notification` mutation. */
export type CreateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` to be created by this mutation. */
  notification: NotificationInput;
};

/** The output of our create `Notification` mutation. */
export type CreateNotificationPayload = {
  __typename?: 'CreateNotificationPayload';
  /** Reads a single `NotificationChannel` that is related to this `Notification`. */
  channel?: Maybe<NotificationChannel>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was created by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Notification`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Notification`. */
  recipientGroup?: Maybe<Group>;
};


/** The output of our create `Notification` mutation. */
export type CreateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** All input for the create `PortugueseRandomQuestion` mutation. */
export type CreatePortugueseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseRandomQuestion` to be created by this mutation. */
  portugueseRandomQuestion: PortugueseRandomQuestionInput;
};

/** The output of our create `PortugueseRandomQuestion` mutation. */
export type CreatePortugueseRandomQuestionPayload = {
  __typename?: 'CreatePortugueseRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseRandomQuestion` that was created by this mutation. */
  portugueseRandomQuestion?: Maybe<PortugueseRandomQuestion>;
  /** An edge for our `PortugueseRandomQuestion`. May be used by Relay 1. */
  portugueseRandomQuestionEdge?: Maybe<PortugueseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `PortugueseRandomQuestion` mutation. */
export type CreatePortugueseRandomQuestionPayloadPortugueseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseRandomQuestionsOrderBy>>;
};

/** All input for the create `PortugueseWord` mutation. */
export type CreatePortugueseWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWord` to be created by this mutation. */
  portugueseWord: PortugueseWordInput;
};

/** The output of our create `PortugueseWord` mutation. */
export type CreatePortugueseWordPayload = {
  __typename?: 'CreatePortugueseWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWord` that was created by this mutation. */
  portugueseWord?: Maybe<PortugueseWord>;
  /** An edge for our `PortugueseWord`. May be used by Relay 1. */
  portugueseWordEdge?: Maybe<PortugueseWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `PortugueseWord` mutation. */
export type CreatePortugueseWordPayloadPortugueseWordEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWordsOrderBy>>;
};

/** All input for the create `PortugueseWouldYouRatherQuestion` mutation. */
export type CreatePortugueseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWouldYouRatherQuestion` to be created by this mutation. */
  portugueseWouldYouRatherQuestion: PortugueseWouldYouRatherQuestionInput;
};

/** The output of our create `PortugueseWouldYouRatherQuestion` mutation. */
export type CreatePortugueseWouldYouRatherQuestionPayload = {
  __typename?: 'CreatePortugueseWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWouldYouRatherQuestion` that was created by this mutation. */
  portugueseWouldYouRatherQuestion?: Maybe<PortugueseWouldYouRatherQuestion>;
  /** An edge for our `PortugueseWouldYouRatherQuestion`. May be used by Relay 1. */
  portugueseWouldYouRatherQuestionEdge?: Maybe<PortugueseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `PortugueseWouldYouRatherQuestion` mutation. */
export type CreatePortugueseWouldYouRatherQuestionPayloadPortugueseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `PostCorrection` mutation. */
export type CreatePostCorrectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostCorrection` to be created by this mutation. */
  postCorrection: PostCorrectionInput;
};

/** The output of our create `PostCorrection` mutation. */
export type CreatePostCorrectionPayload = {
  __typename?: 'CreatePostCorrectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostCorrection`. */
  post?: Maybe<Post>;
  /** The `PostCorrection` that was created by this mutation. */
  postCorrection?: Maybe<PostCorrection>;
  /** An edge for our `PostCorrection`. May be used by Relay 1. */
  postCorrectionEdge?: Maybe<PostCorrectionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostCorrection`. */
  user?: Maybe<User>;
};


/** The output of our create `PostCorrection` mutation. */
export type CreatePostCorrectionPayloadPostCorrectionEdgeArgs = {
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};

/** All input for the create `PostGameAnswer` mutation. */
export type CreatePostGameAnswerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostGameAnswer` to be created by this mutation. */
  postGameAnswer: PostGameAnswerInput;
};

/** The output of our create `PostGameAnswer` mutation. */
export type CreatePostGameAnswerPayload = {
  __typename?: 'CreatePostGameAnswerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `PostGame` that is related to this `PostGameAnswer`. */
  game?: Maybe<PostGame>;
  /** The `PostGameAnswer` that was created by this mutation. */
  postGameAnswer?: Maybe<PostGameAnswer>;
  /** An edge for our `PostGameAnswer`. May be used by Relay 1. */
  postGameAnswerEdge?: Maybe<PostGameAnswersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PostGameRange` that is related to this `PostGameAnswer`. */
  range?: Maybe<PostGameRange>;
  /** Reads a single `User` that is related to this `PostGameAnswer`. */
  user?: Maybe<User>;
};


/** The output of our create `PostGameAnswer` mutation. */
export type CreatePostGameAnswerPayloadPostGameAnswerEdgeArgs = {
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** All input for the create `PostGame` mutation. */
export type CreatePostGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostGame` to be created by this mutation. */
  postGame: PostGameInput;
};

/** The output of our create `PostGame` mutation. */
export type CreatePostGamePayload = {
  __typename?: 'CreatePostGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostGame`. */
  post?: Maybe<Post>;
  /** The `PostGame` that was created by this mutation. */
  postGame?: Maybe<PostGame>;
  /** An edge for our `PostGame`. May be used by Relay 1. */
  postGameEdge?: Maybe<PostGamesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PostGame` mutation. */
export type CreatePostGamePayloadPostGameEdgeArgs = {
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};

/** All input for the create `PostGameRange` mutation. */
export type CreatePostGameRangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostGameRange` to be created by this mutation. */
  postGameRange: PostGameRangeInput;
};

/** The output of our create `PostGameRange` mutation. */
export type CreatePostGameRangePayload = {
  __typename?: 'CreatePostGameRangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `PostGame` that is related to this `PostGameRange`. */
  game?: Maybe<PostGame>;
  /** The `PostGameRange` that was created by this mutation. */
  postGameRange?: Maybe<PostGameRange>;
  /** An edge for our `PostGameRange`. May be used by Relay 1. */
  postGameRangeEdge?: Maybe<PostGameRangesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PostGameRange` mutation. */
export type CreatePostGameRangePayloadPostGameRangeEdgeArgs = {
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};

/** All input for the create `Post` mutation. */
export type CreatePostInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Post` to be created by this mutation. */
  post: PostInput;
};

/** All input for the create `PostLike` mutation. */
export type CreatePostLikeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostLike` to be created by this mutation. */
  postLike: PostLikeInput;
};

/** The output of our create `PostLike` mutation. */
export type CreatePostLikePayload = {
  __typename?: 'CreatePostLikePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostLike`. */
  post?: Maybe<Post>;
  /** The `PostLike` that was created by this mutation. */
  postLike?: Maybe<PostLike>;
  /** An edge for our `PostLike`. May be used by Relay 1. */
  postLikeEdge?: Maybe<PostLikesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostLike`. */
  user?: Maybe<User>;
};


/** The output of our create `PostLike` mutation. */
export type CreatePostLikePayloadPostLikeEdgeArgs = {
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};

/** The output of our create `Post` mutation. */
export type CreatePostPayload = {
  __typename?: 'CreatePostPayload';
  /** Reads a single `User` that is related to this `Post`. */
  author?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `Post`. */
  language?: Maybe<Language>;
  /** Reads a single `Post` that is related to this `Post`. */
  parentPost?: Maybe<Post>;
  /** The `Post` that was created by this mutation. */
  post?: Maybe<Post>;
  /** An edge for our `Post`. May be used by Relay 1. */
  postEdge?: Maybe<PostsEdge>;
  /** Reads a single `Prompt` that is related to this `Post`. */
  prompt?: Maybe<Prompt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Post` mutation. */
export type CreatePostPayloadPostEdgeArgs = {
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** All input for the create `PostRecording` mutation. */
export type CreatePostRecordingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostRecording` to be created by this mutation. */
  postRecording: PostRecordingInput;
};

/** The output of our create `PostRecording` mutation. */
export type CreatePostRecordingPayload = {
  __typename?: 'CreatePostRecordingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostRecording`. */
  post?: Maybe<Post>;
  /** The `PostRecording` that was created by this mutation. */
  postRecording?: Maybe<PostRecording>;
  /** An edge for our `PostRecording`. May be used by Relay 1. */
  postRecordingEdge?: Maybe<PostRecordingsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostRecording`. */
  user?: Maybe<User>;
};


/** The output of our create `PostRecording` mutation. */
export type CreatePostRecordingPayloadPostRecordingEdgeArgs = {
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};

/** All input for the create `PostUserMention` mutation. */
export type CreatePostUserMentionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostUserMention` to be created by this mutation. */
  postUserMention: PostUserMentionInput;
};

/** The output of our create `PostUserMention` mutation. */
export type CreatePostUserMentionPayload = {
  __typename?: 'CreatePostUserMentionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostUserMention`. */
  post?: Maybe<Post>;
  /** The `PostUserMention` that was created by this mutation. */
  postUserMention?: Maybe<PostUserMention>;
  /** An edge for our `PostUserMention`. May be used by Relay 1. */
  postUserMentionEdge?: Maybe<PostUserMentionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostUserMention`. */
  user?: Maybe<User>;
};


/** The output of our create `PostUserMention` mutation. */
export type CreatePostUserMentionPayloadPostUserMentionEdgeArgs = {
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};

/** All input for the create `Prompt` mutation. */
export type CreatePromptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Prompt` to be created by this mutation. */
  prompt: PromptInput;
};

/** The output of our create `Prompt` mutation. */
export type CreatePromptPayload = {
  __typename?: 'CreatePromptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `Prompt`. */
  language?: Maybe<Language>;
  /** The `Prompt` that was created by this mutation. */
  prompt?: Maybe<Prompt>;
  /** An edge for our `Prompt`. May be used by Relay 1. */
  promptEdge?: Maybe<PromptsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Prompt`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our create `Prompt` mutation. */
export type CreatePromptPayloadPromptEdgeArgs = {
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};

/** All input for the create `RussianRandomQuestion` mutation. */
export type CreateRussianRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RussianRandomQuestion` to be created by this mutation. */
  russianRandomQuestion: RussianRandomQuestionInput;
};

/** The output of our create `RussianRandomQuestion` mutation. */
export type CreateRussianRandomQuestionPayload = {
  __typename?: 'CreateRussianRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianRandomQuestion` that was created by this mutation. */
  russianRandomQuestion?: Maybe<RussianRandomQuestion>;
  /** An edge for our `RussianRandomQuestion`. May be used by Relay 1. */
  russianRandomQuestionEdge?: Maybe<RussianRandomQuestionsEdge>;
};


/** The output of our create `RussianRandomQuestion` mutation. */
export type CreateRussianRandomQuestionPayloadRussianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianRandomQuestionsOrderBy>>;
};

/** All input for the create `RussianWord` mutation. */
export type CreateRussianWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RussianWord` to be created by this mutation. */
  russianWord: RussianWordInput;
};

/** The output of our create `RussianWord` mutation. */
export type CreateRussianWordPayload = {
  __typename?: 'CreateRussianWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWord` that was created by this mutation. */
  russianWord?: Maybe<RussianWord>;
  /** An edge for our `RussianWord`. May be used by Relay 1. */
  russianWordEdge?: Maybe<RussianWordsEdge>;
};


/** The output of our create `RussianWord` mutation. */
export type CreateRussianWordPayloadRussianWordEdgeArgs = {
  orderBy?: Maybe<Array<RussianWordsOrderBy>>;
};

/** All input for the create `RussianWouldYouRatherQuestion` mutation. */
export type CreateRussianWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RussianWouldYouRatherQuestion` to be created by this mutation. */
  russianWouldYouRatherQuestion: RussianWouldYouRatherQuestionInput;
};

/** The output of our create `RussianWouldYouRatherQuestion` mutation. */
export type CreateRussianWouldYouRatherQuestionPayload = {
  __typename?: 'CreateRussianWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWouldYouRatherQuestion` that was created by this mutation. */
  russianWouldYouRatherQuestion?: Maybe<RussianWouldYouRatherQuestion>;
  /** An edge for our `RussianWouldYouRatherQuestion`. May be used by Relay 1. */
  russianWouldYouRatherQuestionEdge?: Maybe<RussianWouldYouRatherQuestionsEdge>;
};


/** The output of our create `RussianWouldYouRatherQuestion` mutation. */
export type CreateRussianWouldYouRatherQuestionPayloadRussianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `SpanishRandomQuestion` mutation. */
export type CreateSpanishRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpanishRandomQuestion` to be created by this mutation. */
  spanishRandomQuestion: SpanishRandomQuestionInput;
};

/** The output of our create `SpanishRandomQuestion` mutation. */
export type CreateSpanishRandomQuestionPayload = {
  __typename?: 'CreateSpanishRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishRandomQuestion` that was created by this mutation. */
  spanishRandomQuestion?: Maybe<SpanishRandomQuestion>;
  /** An edge for our `SpanishRandomQuestion`. May be used by Relay 1. */
  spanishRandomQuestionEdge?: Maybe<SpanishRandomQuestionsEdge>;
};


/** The output of our create `SpanishRandomQuestion` mutation. */
export type CreateSpanishRandomQuestionPayloadSpanishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishRandomQuestionsOrderBy>>;
};

/** All input for the create `SpanishWord` mutation. */
export type CreateSpanishWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpanishWord` to be created by this mutation. */
  spanishWord: SpanishWordInput;
};

/** The output of our create `SpanishWord` mutation. */
export type CreateSpanishWordPayload = {
  __typename?: 'CreateSpanishWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWord` that was created by this mutation. */
  spanishWord?: Maybe<SpanishWord>;
  /** An edge for our `SpanishWord`. May be used by Relay 1. */
  spanishWordEdge?: Maybe<SpanishWordsEdge>;
};


/** The output of our create `SpanishWord` mutation. */
export type CreateSpanishWordPayloadSpanishWordEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWordsOrderBy>>;
};

/** All input for the create `SpanishWouldYouRatherQuestion` mutation. */
export type CreateSpanishWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpanishWouldYouRatherQuestion` to be created by this mutation. */
  spanishWouldYouRatherQuestion: SpanishWouldYouRatherQuestionInput;
};

/** The output of our create `SpanishWouldYouRatherQuestion` mutation. */
export type CreateSpanishWouldYouRatherQuestionPayload = {
  __typename?: 'CreateSpanishWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWouldYouRatherQuestion` that was created by this mutation. */
  spanishWouldYouRatherQuestion?: Maybe<SpanishWouldYouRatherQuestion>;
  /** An edge for our `SpanishWouldYouRatherQuestion`. May be used by Relay 1. */
  spanishWouldYouRatherQuestionEdge?: Maybe<SpanishWouldYouRatherQuestionsEdge>;
};


/** The output of our create `SpanishWouldYouRatherQuestion` mutation. */
export type CreateSpanishWouldYouRatherQuestionPayloadSpanishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the create `UserDevice` mutation. */
export type CreateUserDeviceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserDevice` to be created by this mutation. */
  userDevice: UserDeviceInput;
};

/** The output of our create `UserDevice` mutation. */
export type CreateUserDevicePayload = {
  __typename?: 'CreateUserDevicePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserDevice`. */
  user?: Maybe<User>;
  /** The `UserDevice` that was created by this mutation. */
  userDevice?: Maybe<UserDevice>;
  /** An edge for our `UserDevice`. May be used by Relay 1. */
  userDeviceEdge?: Maybe<UserDevicesEdge>;
};


/** The output of our create `UserDevice` mutation. */
export type CreateUserDevicePayloadUserDeviceEdgeArgs = {
  orderBy?: Maybe<Array<UserDevicesOrderBy>>;
};

/** All input for the create `UserFollower` mutation. */
export type CreateUserFollowerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserFollower` to be created by this mutation. */
  userFollower: UserFollowerInput;
};

/** The output of our create `UserFollower` mutation. */
export type CreateUserFollowerPayload = {
  __typename?: 'CreateUserFollowerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  follower?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  user?: Maybe<User>;
  /** The `UserFollower` that was created by this mutation. */
  userFollower?: Maybe<UserFollower>;
  /** An edge for our `UserFollower`. May be used by Relay 1. */
  userFollowerEdge?: Maybe<UserFollowersEdge>;
};


/** The output of our create `UserFollower` mutation. */
export type CreateUserFollowerPayloadUserFollowerEdgeArgs = {
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** All input for the create `UserLanguage` mutation. */
export type CreateUserLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserLanguage` to be created by this mutation. */
  userLanguage: UserLanguageInput;
};

/** The output of our create `UserLanguage` mutation. */
export type CreateUserLanguagePayload = {
  __typename?: 'CreateUserLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `UserLanguage`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `UserLanguage`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserLanguage`. */
  user?: Maybe<User>;
  /** The `UserLanguage` that was created by this mutation. */
  userLanguage?: Maybe<UserLanguage>;
  /** An edge for our `UserLanguage`. May be used by Relay 1. */
  userLanguageEdge?: Maybe<UserLanguagesEdge>;
};


/** The output of our create `UserLanguage` mutation. */
export type CreateUserLanguagePayloadUserLanguageEdgeArgs = {
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `User`. */
  languageByLocale?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `InviteToken` that is related to this `User`. */
  signedUpWithToken?: Maybe<InviteToken>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the create `UserPreference` mutation. */
export type CreateUserPreferenceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserPreference` to be created by this mutation. */
  userPreference: UserPreferenceInput;
};

/** The output of our create `UserPreference` mutation. */
export type CreateUserPreferencePayload = {
  __typename?: 'CreateUserPreferencePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `UserPreference`. */
  feedLanguage?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserPreference`. */
  user?: Maybe<User>;
  /** The `UserPreference` that was created by this mutation. */
  userPreference?: Maybe<UserPreference>;
  /** An edge for our `UserPreference`. May be used by Relay 1. */
  userPreferenceEdge?: Maybe<UserPreferencesEdge>;
};


/** The output of our create `UserPreference` mutation. */
export type CreateUserPreferencePayloadUserPreferenceEdgeArgs = {
  orderBy?: Maybe<Array<UserPreferencesOrderBy>>;
};

/** All input for the create `UserSession` mutation. */
export type CreateUserSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserSession` to be created by this mutation. */
  userSession: UserSessionInput;
};

/** The output of our create `UserSession` mutation. */
export type CreateUserSessionPayload = {
  __typename?: 'CreateUserSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserSession` that was created by this mutation. */
  userSession?: Maybe<UserSession>;
  /** An edge for our `UserSession`. May be used by Relay 1. */
  userSessionEdge?: Maybe<UserSessionsEdge>;
};


/** The output of our create `UserSession` mutation. */
export type CreateUserSessionPayloadUserSessionEdgeArgs = {
  orderBy?: Maybe<Array<UserSessionsOrderBy>>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
};

/** All input for the `deleteChineseGuessCharacterQuestionByNodeId` mutation. */
export type DeleteChineseGuessCharacterQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChineseGuessCharacterQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChineseGuessCharacterQuestionByUuid` mutation. */
export type DeleteChineseGuessCharacterQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteChineseGuessCharacterQuestion` mutation. */
export type DeleteChineseGuessCharacterQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ChineseGuessCharacterQuestion` mutation. */
export type DeleteChineseGuessCharacterQuestionPayload = {
  __typename?: 'DeleteChineseGuessCharacterQuestionPayload';
  /** The `ChineseGuessCharacterQuestion` that was deleted by this mutation. */
  chineseGuessCharacterQuestion?: Maybe<ChineseGuessCharacterQuestion>;
  /** An edge for our `ChineseGuessCharacterQuestion`. May be used by Relay 1. */
  chineseGuessCharacterQuestionEdge?: Maybe<ChineseGuessCharacterQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedGuessCharacterQuestionsZhNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseGuessCharacterQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `ChineseGuessCharacterQuestion` mutation. */
export type DeleteChineseGuessCharacterQuestionPayloadChineseGuessCharacterQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseGuessCharacterQuestionsOrderBy>>;
};

/** All input for the `deleteChineseRandomQuestionByNodeId` mutation. */
export type DeleteChineseRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChineseRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChineseRandomQuestionByUuid` mutation. */
export type DeleteChineseRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteChineseRandomQuestion` mutation. */
export type DeleteChineseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ChineseRandomQuestion` mutation. */
export type DeleteChineseRandomQuestionPayload = {
  __typename?: 'DeleteChineseRandomQuestionPayload';
  /** The `ChineseRandomQuestion` that was deleted by this mutation. */
  chineseRandomQuestion?: Maybe<ChineseRandomQuestion>;
  /** An edge for our `ChineseRandomQuestion`. May be used by Relay 1. */
  chineseRandomQuestionEdge?: Maybe<ChineseRandomQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsZhNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `ChineseRandomQuestion` mutation. */
export type DeleteChineseRandomQuestionPayloadChineseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseRandomQuestionsOrderBy>>;
};

/** All input for the `deleteChineseWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteChineseWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChineseWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChineseWouldYouRatherQuestionByUuid` mutation. */
export type DeleteChineseWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteChineseWouldYouRatherQuestion` mutation. */
export type DeleteChineseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ChineseWouldYouRatherQuestion` mutation. */
export type DeleteChineseWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteChineseWouldYouRatherQuestionPayload';
  /** The `ChineseWouldYouRatherQuestion` that was deleted by this mutation. */
  chineseWouldYouRatherQuestion?: Maybe<ChineseWouldYouRatherQuestion>;
  /** An edge for our `ChineseWouldYouRatherQuestion`. May be used by Relay 1. */
  chineseWouldYouRatherQuestionEdge?: Maybe<ChineseWouldYouRatherQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsZhNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `ChineseWouldYouRatherQuestion` mutation. */
export type DeleteChineseWouldYouRatherQuestionPayloadChineseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteEnglishRandomQuestionByNodeId` mutation. */
export type DeleteEnglishRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EnglishRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEnglishRandomQuestionByUuid` mutation. */
export type DeleteEnglishRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteEnglishRandomQuestion` mutation. */
export type DeleteEnglishRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `EnglishRandomQuestion` mutation. */
export type DeleteEnglishRandomQuestionPayload = {
  __typename?: 'DeleteEnglishRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsEnNodeId?: Maybe<Scalars['ID']>;
  /** The `EnglishRandomQuestion` that was deleted by this mutation. */
  englishRandomQuestion?: Maybe<EnglishRandomQuestion>;
  /** An edge for our `EnglishRandomQuestion`. May be used by Relay 1. */
  englishRandomQuestionEdge?: Maybe<EnglishRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `EnglishRandomQuestion` mutation. */
export type DeleteEnglishRandomQuestionPayloadEnglishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishRandomQuestionsOrderBy>>;
};

/** All input for the `deleteEnglishWordByNodeId` mutation. */
export type DeleteEnglishWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EnglishWord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEnglishWordByUuid` mutation. */
export type DeleteEnglishWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteEnglishWord` mutation. */
export type DeleteEnglishWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `EnglishWord` mutation. */
export type DeleteEnglishWordPayload = {
  __typename?: 'DeleteEnglishWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWordsEnNodeId?: Maybe<Scalars['ID']>;
  /** The `EnglishWord` that was deleted by this mutation. */
  englishWord?: Maybe<EnglishWord>;
  /** An edge for our `EnglishWord`. May be used by Relay 1. */
  englishWordEdge?: Maybe<EnglishWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `EnglishWord` mutation. */
export type DeleteEnglishWordPayloadEnglishWordEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWordsOrderBy>>;
};

/** All input for the `deleteEnglishWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteEnglishWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EnglishWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEnglishWouldYouRatherQuestionByUuid` mutation. */
export type DeleteEnglishWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteEnglishWouldYouRatherQuestion` mutation. */
export type DeleteEnglishWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `EnglishWouldYouRatherQuestion` mutation. */
export type DeleteEnglishWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteEnglishWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsEnNodeId?: Maybe<Scalars['ID']>;
  /** The `EnglishWouldYouRatherQuestion` that was deleted by this mutation. */
  englishWouldYouRatherQuestion?: Maybe<EnglishWouldYouRatherQuestion>;
  /** An edge for our `EnglishWouldYouRatherQuestion`. May be used by Relay 1. */
  englishWouldYouRatherQuestionEdge?: Maybe<EnglishWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `EnglishWouldYouRatherQuestion` mutation. */
export type DeleteEnglishWouldYouRatherQuestionPayloadEnglishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteFrenchRandomQuestionByNodeId` mutation. */
export type DeleteFrenchRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FrenchRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFrenchRandomQuestionByUuid` mutation. */
export type DeleteFrenchRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteFrenchRandomQuestion` mutation. */
export type DeleteFrenchRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `FrenchRandomQuestion` mutation. */
export type DeleteFrenchRandomQuestionPayload = {
  __typename?: 'DeleteFrenchRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsFrNodeId?: Maybe<Scalars['ID']>;
  /** The `FrenchRandomQuestion` that was deleted by this mutation. */
  frenchRandomQuestion?: Maybe<FrenchRandomQuestion>;
  /** An edge for our `FrenchRandomQuestion`. May be used by Relay 1. */
  frenchRandomQuestionEdge?: Maybe<FrenchRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `FrenchRandomQuestion` mutation. */
export type DeleteFrenchRandomQuestionPayloadFrenchRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchRandomQuestionsOrderBy>>;
};

/** All input for the `deleteFrenchWordByNodeId` mutation. */
export type DeleteFrenchWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FrenchWord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFrenchWordByUuid` mutation. */
export type DeleteFrenchWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteFrenchWord` mutation. */
export type DeleteFrenchWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `FrenchWord` mutation. */
export type DeleteFrenchWordPayload = {
  __typename?: 'DeleteFrenchWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWordsFrNodeId?: Maybe<Scalars['ID']>;
  /** The `FrenchWord` that was deleted by this mutation. */
  frenchWord?: Maybe<FrenchWord>;
  /** An edge for our `FrenchWord`. May be used by Relay 1. */
  frenchWordEdge?: Maybe<FrenchWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `FrenchWord` mutation. */
export type DeleteFrenchWordPayloadFrenchWordEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWordsOrderBy>>;
};

/** All input for the `deleteFrenchWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteFrenchWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FrenchWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFrenchWouldYouRatherQuestionByUuid` mutation. */
export type DeleteFrenchWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteFrenchWouldYouRatherQuestion` mutation. */
export type DeleteFrenchWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `FrenchWouldYouRatherQuestion` mutation. */
export type DeleteFrenchWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteFrenchWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsFrNodeId?: Maybe<Scalars['ID']>;
  /** The `FrenchWouldYouRatherQuestion` that was deleted by this mutation. */
  frenchWouldYouRatherQuestion?: Maybe<FrenchWouldYouRatherQuestion>;
  /** An edge for our `FrenchWouldYouRatherQuestion`. May be used by Relay 1. */
  frenchWouldYouRatherQuestionEdge?: Maybe<FrenchWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `FrenchWouldYouRatherQuestion` mutation. */
export type DeleteFrenchWouldYouRatherQuestionPayloadFrenchWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteGermanRandomQuestionByNodeId` mutation. */
export type DeleteGermanRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GermanRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGermanRandomQuestionByUuid` mutation. */
export type DeleteGermanRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteGermanRandomQuestion` mutation. */
export type DeleteGermanRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `GermanRandomQuestion` mutation. */
export type DeleteGermanRandomQuestionPayload = {
  __typename?: 'DeleteGermanRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsDeNodeId?: Maybe<Scalars['ID']>;
  /** The `GermanRandomQuestion` that was deleted by this mutation. */
  germanRandomQuestion?: Maybe<GermanRandomQuestion>;
  /** An edge for our `GermanRandomQuestion`. May be used by Relay 1. */
  germanRandomQuestionEdge?: Maybe<GermanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `GermanRandomQuestion` mutation. */
export type DeleteGermanRandomQuestionPayloadGermanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanRandomQuestionsOrderBy>>;
};

/** All input for the `deleteGermanWordByNodeId` mutation. */
export type DeleteGermanWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GermanWord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGermanWordByUuid` mutation. */
export type DeleteGermanWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteGermanWord` mutation. */
export type DeleteGermanWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `GermanWord` mutation. */
export type DeleteGermanWordPayload = {
  __typename?: 'DeleteGermanWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWordsDeNodeId?: Maybe<Scalars['ID']>;
  /** The `GermanWord` that was deleted by this mutation. */
  germanWord?: Maybe<GermanWord>;
  /** An edge for our `GermanWord`. May be used by Relay 1. */
  germanWordEdge?: Maybe<GermanWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `GermanWord` mutation. */
export type DeleteGermanWordPayloadGermanWordEdgeArgs = {
  orderBy?: Maybe<Array<GermanWordsOrderBy>>;
};

/** All input for the `deleteGermanWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteGermanWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GermanWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGermanWouldYouRatherQuestionByUuid` mutation. */
export type DeleteGermanWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteGermanWouldYouRatherQuestion` mutation. */
export type DeleteGermanWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `GermanWouldYouRatherQuestion` mutation. */
export type DeleteGermanWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteGermanWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsDeNodeId?: Maybe<Scalars['ID']>;
  /** The `GermanWouldYouRatherQuestion` that was deleted by this mutation. */
  germanWouldYouRatherQuestion?: Maybe<GermanWouldYouRatherQuestion>;
  /** An edge for our `GermanWouldYouRatherQuestion`. May be used by Relay 1. */
  germanWouldYouRatherQuestionEdge?: Maybe<GermanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `GermanWouldYouRatherQuestion` mutation. */
export type DeleteGermanWouldYouRatherQuestionPayloadGermanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteGroupByNodeId` mutation. */
export type DeleteGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGroupByUuid` mutation. */
export type DeleteGroupByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedGroupNodeId?: Maybe<Scalars['ID']>;
  /** The `Group` that was deleted by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Reads a single `Language` that is related to this `Group`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Group`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Group` mutation. */
export type DeleteGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `deleteGroupUserByNodeId` mutation. */
export type DeleteGroupUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GroupUser` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGroupUser` mutation. */
export type DeleteGroupUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `GroupUser` mutation. */
export type DeleteGroupUserPayload = {
  __typename?: 'DeleteGroupUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedGroupUserNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  /** The `GroupUser` that was deleted by this mutation. */
  groupUser?: Maybe<GroupUser>;
  /** An edge for our `GroupUser`. May be used by Relay 1. */
  groupUserEdge?: Maybe<GroupUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `GroupUser` mutation. */
export type DeleteGroupUserPayloadGroupUserEdgeArgs = {
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};

/** All input for the `deleteInviteTokenByNodeId` mutation. */
export type DeleteInviteTokenByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InviteToken` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInviteToken` mutation. */
export type DeleteInviteTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `InviteToken` mutation. */
export type DeleteInviteTokenPayload = {
  __typename?: 'DeleteInviteTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedInviteTokenNodeId?: Maybe<Scalars['ID']>;
  /** The `InviteToken` that was deleted by this mutation. */
  inviteToken?: Maybe<InviteToken>;
  /** An edge for our `InviteToken`. May be used by Relay 1. */
  inviteTokenEdge?: Maybe<InviteTokensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `InviteToken`. */
  user?: Maybe<User>;
};


/** The output of our delete `InviteToken` mutation. */
export type DeleteInviteTokenPayloadInviteTokenEdgeArgs = {
  orderBy?: Maybe<Array<InviteTokensOrderBy>>;
};

/** All input for the `deleteItalianRandomQuestionByNodeId` mutation. */
export type DeleteItalianRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ItalianRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteItalianRandomQuestionByUuid` mutation. */
export type DeleteItalianRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteItalianRandomQuestion` mutation. */
export type DeleteItalianRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ItalianRandomQuestion` mutation. */
export type DeleteItalianRandomQuestionPayload = {
  __typename?: 'DeleteItalianRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsItNodeId?: Maybe<Scalars['ID']>;
  /** The `ItalianRandomQuestion` that was deleted by this mutation. */
  italianRandomQuestion?: Maybe<ItalianRandomQuestion>;
  /** An edge for our `ItalianRandomQuestion`. May be used by Relay 1. */
  italianRandomQuestionEdge?: Maybe<ItalianRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `ItalianRandomQuestion` mutation. */
export type DeleteItalianRandomQuestionPayloadItalianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianRandomQuestionsOrderBy>>;
};

/** All input for the `deleteItalianWordByNodeId` mutation. */
export type DeleteItalianWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ItalianWord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteItalianWordByUuid` mutation. */
export type DeleteItalianWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteItalianWord` mutation. */
export type DeleteItalianWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ItalianWord` mutation. */
export type DeleteItalianWordPayload = {
  __typename?: 'DeleteItalianWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWordsItNodeId?: Maybe<Scalars['ID']>;
  /** The `ItalianWord` that was deleted by this mutation. */
  italianWord?: Maybe<ItalianWord>;
  /** An edge for our `ItalianWord`. May be used by Relay 1. */
  italianWordEdge?: Maybe<ItalianWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `ItalianWord` mutation. */
export type DeleteItalianWordPayloadItalianWordEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWordsOrderBy>>;
};

/** All input for the `deleteItalianWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteItalianWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ItalianWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteItalianWouldYouRatherQuestionByUuid` mutation. */
export type DeleteItalianWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteItalianWouldYouRatherQuestion` mutation. */
export type DeleteItalianWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ItalianWouldYouRatherQuestion` mutation. */
export type DeleteItalianWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteItalianWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsItNodeId?: Maybe<Scalars['ID']>;
  /** The `ItalianWouldYouRatherQuestion` that was deleted by this mutation. */
  italianWouldYouRatherQuestion?: Maybe<ItalianWouldYouRatherQuestion>;
  /** An edge for our `ItalianWouldYouRatherQuestion`. May be used by Relay 1. */
  italianWouldYouRatherQuestionEdge?: Maybe<ItalianWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `ItalianWouldYouRatherQuestion` mutation. */
export type DeleteItalianWouldYouRatherQuestionPayloadItalianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteJapaneseRandomQuestionByNodeId` mutation. */
export type DeleteJapaneseRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `JapaneseRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteJapaneseRandomQuestionByUuid` mutation. */
export type DeleteJapaneseRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteJapaneseRandomQuestion` mutation. */
export type DeleteJapaneseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `JapaneseRandomQuestion` mutation. */
export type DeleteJapaneseRandomQuestionPayload = {
  __typename?: 'DeleteJapaneseRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsJaNodeId?: Maybe<Scalars['ID']>;
  /** The `JapaneseRandomQuestion` that was deleted by this mutation. */
  japaneseRandomQuestion?: Maybe<JapaneseRandomQuestion>;
  /** An edge for our `JapaneseRandomQuestion`. May be used by Relay 1. */
  japaneseRandomQuestionEdge?: Maybe<JapaneseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `JapaneseRandomQuestion` mutation. */
export type DeleteJapaneseRandomQuestionPayloadJapaneseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseRandomQuestionsOrderBy>>;
};

/** All input for the `deleteJapaneseWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteJapaneseWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `JapaneseWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteJapaneseWouldYouRatherQuestionByUuid` mutation. */
export type DeleteJapaneseWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteJapaneseWouldYouRatherQuestion` mutation. */
export type DeleteJapaneseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `JapaneseWouldYouRatherQuestion` mutation. */
export type DeleteJapaneseWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteJapaneseWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsJaNodeId?: Maybe<Scalars['ID']>;
  /** The `JapaneseWouldYouRatherQuestion` that was deleted by this mutation. */
  japaneseWouldYouRatherQuestion?: Maybe<JapaneseWouldYouRatherQuestion>;
  /** An edge for our `JapaneseWouldYouRatherQuestion`. May be used by Relay 1. */
  japaneseWouldYouRatherQuestionEdge?: Maybe<JapaneseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `JapaneseWouldYouRatherQuestion` mutation. */
export type DeleteJapaneseWouldYouRatherQuestionPayloadJapaneseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteKoreanRandomQuestionByNodeId` mutation. */
export type DeleteKoreanRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `KoreanRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteKoreanRandomQuestionByUuid` mutation. */
export type DeleteKoreanRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteKoreanRandomQuestion` mutation. */
export type DeleteKoreanRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `KoreanRandomQuestion` mutation. */
export type DeleteKoreanRandomQuestionPayload = {
  __typename?: 'DeleteKoreanRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsKoNodeId?: Maybe<Scalars['ID']>;
  /** The `KoreanRandomQuestion` that was deleted by this mutation. */
  koreanRandomQuestion?: Maybe<KoreanRandomQuestion>;
  /** An edge for our `KoreanRandomQuestion`. May be used by Relay 1. */
  koreanRandomQuestionEdge?: Maybe<KoreanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `KoreanRandomQuestion` mutation. */
export type DeleteKoreanRandomQuestionPayloadKoreanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanRandomQuestionsOrderBy>>;
};

/** All input for the `deleteKoreanWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteKoreanWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `KoreanWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteKoreanWouldYouRatherQuestionByUuid` mutation. */
export type DeleteKoreanWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteKoreanWouldYouRatherQuestion` mutation. */
export type DeleteKoreanWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `KoreanWouldYouRatherQuestion` mutation. */
export type DeleteKoreanWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteKoreanWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsKoNodeId?: Maybe<Scalars['ID']>;
  /** The `KoreanWouldYouRatherQuestion` that was deleted by this mutation. */
  koreanWouldYouRatherQuestion?: Maybe<KoreanWouldYouRatherQuestion>;
  /** An edge for our `KoreanWouldYouRatherQuestion`. May be used by Relay 1. */
  koreanWouldYouRatherQuestionEdge?: Maybe<KoreanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `KoreanWouldYouRatherQuestion` mutation. */
export type DeleteKoreanWouldYouRatherQuestionPayloadKoreanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteLanguageByAlpha2` mutation. */
export type DeleteLanguageByAlpha2Input = {
  /** ISO 3166-1 alpha-2 standardized code */
  alpha2: Scalars['String'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** All input for the `deleteLanguageByEnglishName` mutation. */
export type DeleteLanguageByEnglishNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  englishName: Scalars['String'];
};

/** All input for the `deleteLanguageByNodeId` mutation. */
export type DeleteLanguageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Language` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLanguage` mutation. */
export type DeleteLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Language` mutation. */
export type DeleteLanguagePayload = {
  __typename?: 'DeleteLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedLanguageNodeId?: Maybe<Scalars['ID']>;
  /** The `Language` that was deleted by this mutation. */
  language?: Maybe<Language>;
  /** An edge for our `Language`. May be used by Relay 1. */
  languageEdge?: Maybe<LanguagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Language` mutation. */
export type DeleteLanguagePayloadLanguageEdgeArgs = {
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};

/** All input for the `deleteLanguageSkillLevelByNodeId` mutation. */
export type DeleteLanguageSkillLevelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LanguageSkillLevel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLanguageSkillLevel` mutation. */
export type DeleteLanguageSkillLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `LanguageSkillLevel` mutation. */
export type DeleteLanguageSkillLevelPayload = {
  __typename?: 'DeleteLanguageSkillLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedLanguageSkillLevelNodeId?: Maybe<Scalars['ID']>;
  /** The `LanguageSkillLevel` that was deleted by this mutation. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** An edge for our `LanguageSkillLevel`. May be used by Relay 1. */
  languageSkillLevelEdge?: Maybe<LanguageSkillLevelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `LanguageSkillLevel` mutation. */
export type DeleteLanguageSkillLevelPayloadLanguageSkillLevelEdgeArgs = {
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};

/** All input for the `deleteMessageByNodeId` mutation. */
export type DeleteMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Message` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMessageByUuid` mutation. */
export type DeleteMessageByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteMessage` mutation. */
export type DeleteMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Message` mutation. */
export type DeleteMessagePayload = {
  __typename?: 'DeleteMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedMessageNodeId?: Maybe<Scalars['ID']>;
  /** The `Message` that was deleted by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Reads a single `Message` that is related to this `Message`. */
  parentMessage?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Message`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Message`. */
  recipientGroup?: Maybe<Group>;
  /** Reads a single `User` that is related to this `Message`. */
  sender?: Maybe<User>;
};


/** The output of our delete `Message` mutation. */
export type DeleteMessagePayloadMessageEdgeArgs = {
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** All input for the `deleteMessagePreviewByNodeId` mutation. */
export type DeleteMessagePreviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MessagePreview` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMessagePreviewByUuid` mutation. */
export type DeleteMessagePreviewByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteMessagePreview` mutation. */
export type DeleteMessagePreviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `MessagePreview` mutation. */
export type DeleteMessagePreviewPayload = {
  __typename?: 'DeleteMessagePreviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedMessagePreviewNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Message` that is related to this `MessagePreview`. */
  message?: Maybe<Message>;
  /** The `MessagePreview` that was deleted by this mutation. */
  messagePreview?: Maybe<MessagePreview>;
  /** An edge for our `MessagePreview`. May be used by Relay 1. */
  messagePreviewEdge?: Maybe<MessagePreviewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `MessagePreview` mutation. */
export type DeleteMessagePreviewPayloadMessagePreviewEdgeArgs = {
  orderBy?: Maybe<Array<MessagePreviewsOrderBy>>;
};

/** All input for the `deleteNotificationByNodeId` mutation. */
export type DeleteNotificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Notification` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNotificationByUuid` mutation. */
export type DeleteNotificationByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteNotificationChannelByName` mutation. */
export type DeleteNotificationChannelByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteNotificationChannelByNodeId` mutation. */
export type DeleteNotificationChannelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NotificationChannel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNotificationChannelByUuid` mutation. */
export type DeleteNotificationChannelByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteNotificationChannel` mutation. */
export type DeleteNotificationChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `NotificationChannel` mutation. */
export type DeleteNotificationChannelPayload = {
  __typename?: 'DeleteNotificationChannelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedNotificationChannelNodeId?: Maybe<Scalars['ID']>;
  /** The `NotificationChannel` that was deleted by this mutation. */
  notificationChannel?: Maybe<NotificationChannel>;
  /** An edge for our `NotificationChannel`. May be used by Relay 1. */
  notificationChannelEdge?: Maybe<NotificationChannelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `NotificationChannel` mutation. */
export type DeleteNotificationChannelPayloadNotificationChannelEdgeArgs = {
  orderBy?: Maybe<Array<NotificationChannelsOrderBy>>;
};

/** All input for the `deleteNotification` mutation. */
export type DeleteNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayload = {
  __typename?: 'DeleteNotificationPayload';
  /** Reads a single `NotificationChannel` that is related to this `Notification`. */
  channel?: Maybe<NotificationChannel>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedNotificationNodeId?: Maybe<Scalars['ID']>;
  /** The `Notification` that was deleted by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Notification`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Notification`. */
  recipientGroup?: Maybe<Group>;
};


/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayloadNotificationEdgeArgs = {
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** All input for the `deletePortugueseRandomQuestionByNodeId` mutation. */
export type DeletePortugueseRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PortugueseRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePortugueseRandomQuestionByUuid` mutation. */
export type DeletePortugueseRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePortugueseRandomQuestion` mutation. */
export type DeletePortugueseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PortugueseRandomQuestion` mutation. */
export type DeletePortugueseRandomQuestionPayload = {
  __typename?: 'DeletePortugueseRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsPtNodeId?: Maybe<Scalars['ID']>;
  /** The `PortugueseRandomQuestion` that was deleted by this mutation. */
  portugueseRandomQuestion?: Maybe<PortugueseRandomQuestion>;
  /** An edge for our `PortugueseRandomQuestion`. May be used by Relay 1. */
  portugueseRandomQuestionEdge?: Maybe<PortugueseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `PortugueseRandomQuestion` mutation. */
export type DeletePortugueseRandomQuestionPayloadPortugueseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseRandomQuestionsOrderBy>>;
};

/** All input for the `deletePortugueseWordByNodeId` mutation. */
export type DeletePortugueseWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PortugueseWord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePortugueseWordByUuid` mutation. */
export type DeletePortugueseWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePortugueseWord` mutation. */
export type DeletePortugueseWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PortugueseWord` mutation. */
export type DeletePortugueseWordPayload = {
  __typename?: 'DeletePortugueseWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWordsPtNodeId?: Maybe<Scalars['ID']>;
  /** The `PortugueseWord` that was deleted by this mutation. */
  portugueseWord?: Maybe<PortugueseWord>;
  /** An edge for our `PortugueseWord`. May be used by Relay 1. */
  portugueseWordEdge?: Maybe<PortugueseWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `PortugueseWord` mutation. */
export type DeletePortugueseWordPayloadPortugueseWordEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWordsOrderBy>>;
};

/** All input for the `deletePortugueseWouldYouRatherQuestionByNodeId` mutation. */
export type DeletePortugueseWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PortugueseWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePortugueseWouldYouRatherQuestionByUuid` mutation. */
export type DeletePortugueseWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePortugueseWouldYouRatherQuestion` mutation. */
export type DeletePortugueseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PortugueseWouldYouRatherQuestion` mutation. */
export type DeletePortugueseWouldYouRatherQuestionPayload = {
  __typename?: 'DeletePortugueseWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsPtNodeId?: Maybe<Scalars['ID']>;
  /** The `PortugueseWouldYouRatherQuestion` that was deleted by this mutation. */
  portugueseWouldYouRatherQuestion?: Maybe<PortugueseWouldYouRatherQuestion>;
  /** An edge for our `PortugueseWouldYouRatherQuestion`. May be used by Relay 1. */
  portugueseWouldYouRatherQuestionEdge?: Maybe<PortugueseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `PortugueseWouldYouRatherQuestion` mutation. */
export type DeletePortugueseWouldYouRatherQuestionPayloadPortugueseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deletePostByNodeId` mutation. */
export type DeletePostByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Post` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostBySnowflakeId` mutation. */
export type DeletePostBySnowflakeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  snowflakeId: Scalars['BigInt'];
};

/** All input for the `deletePostByUuid` mutation. */
export type DeletePostByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePostCorrectionByNodeId` mutation. */
export type DeletePostCorrectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostCorrection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostCorrectionByUuid` mutation. */
export type DeletePostCorrectionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePostCorrection` mutation. */
export type DeletePostCorrectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PostCorrection` mutation. */
export type DeletePostCorrectionPayload = {
  __typename?: 'DeletePostCorrectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostCorrectionNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Post` that is related to this `PostCorrection`. */
  post?: Maybe<Post>;
  /** The `PostCorrection` that was deleted by this mutation. */
  postCorrection?: Maybe<PostCorrection>;
  /** An edge for our `PostCorrection`. May be used by Relay 1. */
  postCorrectionEdge?: Maybe<PostCorrectionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostCorrection`. */
  user?: Maybe<User>;
};


/** The output of our delete `PostCorrection` mutation. */
export type DeletePostCorrectionPayloadPostCorrectionEdgeArgs = {
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};

/** All input for the `deletePostGameAnswerByNodeId` mutation. */
export type DeletePostGameAnswerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostGameAnswer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostGameAnswerByUuid` mutation. */
export type DeletePostGameAnswerByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePostGameAnswer` mutation. */
export type DeletePostGameAnswerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PostGameAnswer` mutation. */
export type DeletePostGameAnswerPayload = {
  __typename?: 'DeletePostGameAnswerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostGameAnswerNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `PostGame` that is related to this `PostGameAnswer`. */
  game?: Maybe<PostGame>;
  /** The `PostGameAnswer` that was deleted by this mutation. */
  postGameAnswer?: Maybe<PostGameAnswer>;
  /** An edge for our `PostGameAnswer`. May be used by Relay 1. */
  postGameAnswerEdge?: Maybe<PostGameAnswersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PostGameRange` that is related to this `PostGameAnswer`. */
  range?: Maybe<PostGameRange>;
  /** Reads a single `User` that is related to this `PostGameAnswer`. */
  user?: Maybe<User>;
};


/** The output of our delete `PostGameAnswer` mutation. */
export type DeletePostGameAnswerPayloadPostGameAnswerEdgeArgs = {
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** All input for the `deletePostGameByNodeId` mutation. */
export type DeletePostGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostGame` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostGameByUuid` mutation. */
export type DeletePostGameByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePostGame` mutation. */
export type DeletePostGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PostGame` mutation. */
export type DeletePostGamePayload = {
  __typename?: 'DeletePostGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostGameNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Post` that is related to this `PostGame`. */
  post?: Maybe<Post>;
  /** The `PostGame` that was deleted by this mutation. */
  postGame?: Maybe<PostGame>;
  /** An edge for our `PostGame`. May be used by Relay 1. */
  postGameEdge?: Maybe<PostGamesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PostGame` mutation. */
export type DeletePostGamePayloadPostGameEdgeArgs = {
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};

/** All input for the `deletePostGameRangeByNodeId` mutation. */
export type DeletePostGameRangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostGameRange` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostGameRangeByUuid` mutation. */
export type DeletePostGameRangeByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePostGameRange` mutation. */
export type DeletePostGameRangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PostGameRange` mutation. */
export type DeletePostGameRangePayload = {
  __typename?: 'DeletePostGameRangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostGameRangeNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `PostGame` that is related to this `PostGameRange`. */
  game?: Maybe<PostGame>;
  /** The `PostGameRange` that was deleted by this mutation. */
  postGameRange?: Maybe<PostGameRange>;
  /** An edge for our `PostGameRange`. May be used by Relay 1. */
  postGameRangeEdge?: Maybe<PostGameRangesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PostGameRange` mutation. */
export type DeletePostGameRangePayloadPostGameRangeEdgeArgs = {
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};

/** All input for the `deletePost` mutation. */
export type DeletePostInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** All input for the `deletePostLikeByNodeId` mutation. */
export type DeletePostLikeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostLike` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostLike` mutation. */
export type DeletePostLikeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PostLike` mutation. */
export type DeletePostLikePayload = {
  __typename?: 'DeletePostLikePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostLikeNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Post` that is related to this `PostLike`. */
  post?: Maybe<Post>;
  /** The `PostLike` that was deleted by this mutation. */
  postLike?: Maybe<PostLike>;
  /** An edge for our `PostLike`. May be used by Relay 1. */
  postLikeEdge?: Maybe<PostLikesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostLike`. */
  user?: Maybe<User>;
};


/** The output of our delete `PostLike` mutation. */
export type DeletePostLikePayloadPostLikeEdgeArgs = {
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};

/** The output of our delete `Post` mutation. */
export type DeletePostPayload = {
  __typename?: 'DeletePostPayload';
  /** Reads a single `User` that is related to this `Post`. */
  author?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Language` that is related to this `Post`. */
  language?: Maybe<Language>;
  /** Reads a single `Post` that is related to this `Post`. */
  parentPost?: Maybe<Post>;
  /** The `Post` that was deleted by this mutation. */
  post?: Maybe<Post>;
  /** An edge for our `Post`. May be used by Relay 1. */
  postEdge?: Maybe<PostsEdge>;
  /** Reads a single `Prompt` that is related to this `Post`. */
  prompt?: Maybe<Prompt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Post` mutation. */
export type DeletePostPayloadPostEdgeArgs = {
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** All input for the `deletePostRecordingByNodeId` mutation. */
export type DeletePostRecordingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostRecording` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostRecordingByUuid` mutation. */
export type DeletePostRecordingByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePostRecording` mutation. */
export type DeletePostRecordingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PostRecording` mutation. */
export type DeletePostRecordingPayload = {
  __typename?: 'DeletePostRecordingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostRecordingNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Post` that is related to this `PostRecording`. */
  post?: Maybe<Post>;
  /** The `PostRecording` that was deleted by this mutation. */
  postRecording?: Maybe<PostRecording>;
  /** An edge for our `PostRecording`. May be used by Relay 1. */
  postRecordingEdge?: Maybe<PostRecordingsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostRecording`. */
  user?: Maybe<User>;
};


/** The output of our delete `PostRecording` mutation. */
export type DeletePostRecordingPayloadPostRecordingEdgeArgs = {
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};

/** All input for the `deletePostUserMentionByNodeId` mutation. */
export type DeletePostUserMentionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostUserMention` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePostUserMentionByUuid` mutation. */
export type DeletePostUserMentionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePostUserMention` mutation. */
export type DeletePostUserMentionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PostUserMention` mutation. */
export type DeletePostUserMentionPayload = {
  __typename?: 'DeletePostUserMentionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPostUserMentionNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Post` that is related to this `PostUserMention`. */
  post?: Maybe<Post>;
  /** The `PostUserMention` that was deleted by this mutation. */
  postUserMention?: Maybe<PostUserMention>;
  /** An edge for our `PostUserMention`. May be used by Relay 1. */
  postUserMentionEdge?: Maybe<PostUserMentionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostUserMention`. */
  user?: Maybe<User>;
};


/** The output of our delete `PostUserMention` mutation. */
export type DeletePostUserMentionPayloadPostUserMentionEdgeArgs = {
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};

/** All input for the `deletePromptByNodeId` mutation. */
export type DeletePromptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Prompt` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePromptByUuid` mutation. */
export type DeletePromptByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deletePrompt` mutation. */
export type DeletePromptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Prompt` mutation. */
export type DeletePromptPayload = {
  __typename?: 'DeletePromptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedPromptNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Language` that is related to this `Prompt`. */
  language?: Maybe<Language>;
  /** The `Prompt` that was deleted by this mutation. */
  prompt?: Maybe<Prompt>;
  /** An edge for our `Prompt`. May be used by Relay 1. */
  promptEdge?: Maybe<PromptsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Prompt`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our delete `Prompt` mutation. */
export type DeletePromptPayloadPromptEdgeArgs = {
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};

/** All input for the `deleteRussianRandomQuestionByNodeId` mutation. */
export type DeleteRussianRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RussianRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRussianRandomQuestionByUuid` mutation. */
export type DeleteRussianRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteRussianRandomQuestion` mutation. */
export type DeleteRussianRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `RussianRandomQuestion` mutation. */
export type DeleteRussianRandomQuestionPayload = {
  __typename?: 'DeleteRussianRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsRuNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianRandomQuestion` that was deleted by this mutation. */
  russianRandomQuestion?: Maybe<RussianRandomQuestion>;
  /** An edge for our `RussianRandomQuestion`. May be used by Relay 1. */
  russianRandomQuestionEdge?: Maybe<RussianRandomQuestionsEdge>;
};


/** The output of our delete `RussianRandomQuestion` mutation. */
export type DeleteRussianRandomQuestionPayloadRussianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianRandomQuestionsOrderBy>>;
};

/** All input for the `deleteRussianWordByNodeId` mutation. */
export type DeleteRussianWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RussianWord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRussianWordByUuid` mutation. */
export type DeleteRussianWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteRussianWord` mutation. */
export type DeleteRussianWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `RussianWord` mutation. */
export type DeleteRussianWordPayload = {
  __typename?: 'DeleteRussianWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWordsRuNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWord` that was deleted by this mutation. */
  russianWord?: Maybe<RussianWord>;
  /** An edge for our `RussianWord`. May be used by Relay 1. */
  russianWordEdge?: Maybe<RussianWordsEdge>;
};


/** The output of our delete `RussianWord` mutation. */
export type DeleteRussianWordPayloadRussianWordEdgeArgs = {
  orderBy?: Maybe<Array<RussianWordsOrderBy>>;
};

/** All input for the `deleteRussianWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteRussianWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RussianWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRussianWouldYouRatherQuestionByUuid` mutation. */
export type DeleteRussianWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteRussianWouldYouRatherQuestion` mutation. */
export type DeleteRussianWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `RussianWouldYouRatherQuestion` mutation. */
export type DeleteRussianWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteRussianWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsRuNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWouldYouRatherQuestion` that was deleted by this mutation. */
  russianWouldYouRatherQuestion?: Maybe<RussianWouldYouRatherQuestion>;
  /** An edge for our `RussianWouldYouRatherQuestion`. May be used by Relay 1. */
  russianWouldYouRatherQuestionEdge?: Maybe<RussianWouldYouRatherQuestionsEdge>;
};


/** The output of our delete `RussianWouldYouRatherQuestion` mutation. */
export type DeleteRussianWouldYouRatherQuestionPayloadRussianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteSpanishRandomQuestionByNodeId` mutation. */
export type DeleteSpanishRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpanishRandomQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSpanishRandomQuestionByUuid` mutation. */
export type DeleteSpanishRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteSpanishRandomQuestion` mutation. */
export type DeleteSpanishRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `SpanishRandomQuestion` mutation. */
export type DeleteSpanishRandomQuestionPayload = {
  __typename?: 'DeleteSpanishRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRandomQuestionsENodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishRandomQuestion` that was deleted by this mutation. */
  spanishRandomQuestion?: Maybe<SpanishRandomQuestion>;
  /** An edge for our `SpanishRandomQuestion`. May be used by Relay 1. */
  spanishRandomQuestionEdge?: Maybe<SpanishRandomQuestionsEdge>;
};


/** The output of our delete `SpanishRandomQuestion` mutation. */
export type DeleteSpanishRandomQuestionPayloadSpanishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishRandomQuestionsOrderBy>>;
};

/** All input for the `deleteSpanishWordByNodeId` mutation. */
export type DeleteSpanishWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpanishWord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSpanishWordByUuid` mutation. */
export type DeleteSpanishWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteSpanishWord` mutation. */
export type DeleteSpanishWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `SpanishWord` mutation. */
export type DeleteSpanishWordPayload = {
  __typename?: 'DeleteSpanishWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWordsENodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWord` that was deleted by this mutation. */
  spanishWord?: Maybe<SpanishWord>;
  /** An edge for our `SpanishWord`. May be used by Relay 1. */
  spanishWordEdge?: Maybe<SpanishWordsEdge>;
};


/** The output of our delete `SpanishWord` mutation. */
export type DeleteSpanishWordPayloadSpanishWordEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWordsOrderBy>>;
};

/** All input for the `deleteSpanishWouldYouRatherQuestionByNodeId` mutation. */
export type DeleteSpanishWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpanishWouldYouRatherQuestion` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSpanishWouldYouRatherQuestionByUuid` mutation. */
export type DeleteSpanishWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteSpanishWouldYouRatherQuestion` mutation. */
export type DeleteSpanishWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `SpanishWouldYouRatherQuestion` mutation. */
export type DeleteSpanishWouldYouRatherQuestionPayload = {
  __typename?: 'DeleteSpanishWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWouldYouRatherQuestionsENodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWouldYouRatherQuestion` that was deleted by this mutation. */
  spanishWouldYouRatherQuestion?: Maybe<SpanishWouldYouRatherQuestion>;
  /** An edge for our `SpanishWouldYouRatherQuestion`. May be used by Relay 1. */
  spanishWouldYouRatherQuestionEdge?: Maybe<SpanishWouldYouRatherQuestionsEdge>;
};


/** The output of our delete `SpanishWouldYouRatherQuestion` mutation. */
export type DeleteSpanishWouldYouRatherQuestionPayloadSpanishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `deleteUserByEmail` mutation. */
export type DeleteUserByEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
};

/** All input for the `deleteUserByEmailUnsubscribeToken` mutation. */
export type DeleteUserByEmailUnsubscribeTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  emailUnsubscribeToken: Scalars['String'];
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserByResetPasswordToken` mutation. */
export type DeleteUserByResetPasswordTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  resetPasswordToken: Scalars['String'];
};

/** All input for the `deleteUserByUsername` mutation. */
export type DeleteUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};

/** All input for the `deleteUserByUuid` mutation. */
export type DeleteUserByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteUserDeviceByFcmToken` mutation. */
export type DeleteUserDeviceByFcmTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  fcmToken: Scalars['String'];
};

/** All input for the `deleteUserDeviceByNodeId` mutation. */
export type DeleteUserDeviceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserDevice` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserDeviceByUuid` mutation. */
export type DeleteUserDeviceByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
};

/** All input for the `deleteUserDevice` mutation. */
export type DeleteUserDeviceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `UserDevice` mutation. */
export type DeleteUserDevicePayload = {
  __typename?: 'DeleteUserDevicePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserDeviceNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserDevice`. */
  user?: Maybe<User>;
  /** The `UserDevice` that was deleted by this mutation. */
  userDevice?: Maybe<UserDevice>;
  /** An edge for our `UserDevice`. May be used by Relay 1. */
  userDeviceEdge?: Maybe<UserDevicesEdge>;
};


/** The output of our delete `UserDevice` mutation. */
export type DeleteUserDevicePayloadUserDeviceEdgeArgs = {
  orderBy?: Maybe<Array<UserDevicesOrderBy>>;
};

/** All input for the `deleteUserFollowerByNodeId` mutation. */
export type DeleteUserFollowerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserFollower` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserFollower` mutation. */
export type DeleteUserFollowerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `UserFollower` mutation. */
export type DeleteUserFollowerPayload = {
  __typename?: 'DeleteUserFollowerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserFollowerNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  follower?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  user?: Maybe<User>;
  /** The `UserFollower` that was deleted by this mutation. */
  userFollower?: Maybe<UserFollower>;
  /** An edge for our `UserFollower`. May be used by Relay 1. */
  userFollowerEdge?: Maybe<UserFollowersEdge>;
};


/** The output of our delete `UserFollower` mutation. */
export type DeleteUserFollowerPayloadUserFollowerEdgeArgs = {
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** All input for the `deleteUserLanguageByNodeId` mutation. */
export type DeleteUserLanguageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserLanguage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserLanguage` mutation. */
export type DeleteUserLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `UserLanguage` mutation. */
export type DeleteUserLanguagePayload = {
  __typename?: 'DeleteUserLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserLanguageNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Language` that is related to this `UserLanguage`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `UserLanguage`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserLanguage`. */
  user?: Maybe<User>;
  /** The `UserLanguage` that was deleted by this mutation. */
  userLanguage?: Maybe<UserLanguage>;
  /** An edge for our `UserLanguage`. May be used by Relay 1. */
  userLanguageEdge?: Maybe<UserLanguagesEdge>;
};


/** The output of our delete `UserLanguage` mutation. */
export type DeleteUserLanguagePayloadUserLanguageEdgeArgs = {
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Language` that is related to this `User`. */
  languageByLocale?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `InviteToken` that is related to this `User`. */
  signedUpWithToken?: Maybe<InviteToken>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUserPreferenceByNodeId` mutation. */
export type DeleteUserPreferenceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserPreference` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserPreferenceByUserId` mutation. */
export type DeleteUserPreferenceByUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  userId: Scalars['Int'];
};

/** All input for the `deleteUserPreference` mutation. */
export type DeleteUserPreferenceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `UserPreference` mutation. */
export type DeleteUserPreferencePayload = {
  __typename?: 'DeleteUserPreferencePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserPreferenceNodeId?: Maybe<Scalars['ID']>;
  /** Reads a single `Language` that is related to this `UserPreference`. */
  feedLanguage?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserPreference`. */
  user?: Maybe<User>;
  /** The `UserPreference` that was deleted by this mutation. */
  userPreference?: Maybe<UserPreference>;
  /** An edge for our `UserPreference`. May be used by Relay 1. */
  userPreferenceEdge?: Maybe<UserPreferencesEdge>;
};


/** The output of our delete `UserPreference` mutation. */
export type DeleteUserPreferencePayloadUserPreferenceEdgeArgs = {
  orderBy?: Maybe<Array<UserPreferencesOrderBy>>;
};

/** All input for the `deleteUserSessionByNodeId` mutation. */
export type DeleteUserSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserSession` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserSession` mutation. */
export type DeleteUserSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  sid: Scalars['String'];
};

/** The output of our delete `UserSession` mutation. */
export type DeleteUserSessionPayload = {
  __typename?: 'DeleteUserSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserSessionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserSession` that was deleted by this mutation. */
  userSession?: Maybe<UserSession>;
  /** An edge for our `UserSession`. May be used by Relay 1. */
  userSessionEdge?: Maybe<UserSessionsEdge>;
};


/** The output of our delete `UserSession` mutation. */
export type DeleteUserSessionPayloadUserSessionEdgeArgs = {
  orderBy?: Maybe<Array<UserSessionsOrderBy>>;
};

export type EnglishRandomQuestion = Node & {
  __typename?: 'EnglishRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `EnglishRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type EnglishRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `EnglishRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type EnglishRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EnglishRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<EnglishRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EnglishRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `EnglishRandomQuestion` */
export type EnglishRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `EnglishRandomQuestion`. Fields that are set will be updated. */
export type EnglishRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `EnglishRandomQuestion` values. */
export type EnglishRandomQuestionsConnection = {
  __typename?: 'EnglishRandomQuestionsConnection';
  /** A list of edges which contains the `EnglishRandomQuestion` and cursor to aid in pagination. */
  edges: Array<EnglishRandomQuestionsEdge>;
  /** A list of `EnglishRandomQuestion` objects. */
  nodes: Array<Maybe<EnglishRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EnglishRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EnglishRandomQuestion` edge in the connection. */
export type EnglishRandomQuestionsEdge = {
  __typename?: 'EnglishRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `EnglishRandomQuestion` at the end of the edge. */
  node?: Maybe<EnglishRandomQuestion>;
};

/** Methods to use when ordering `EnglishRandomQuestion`. */
export enum EnglishRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type EnglishWord = Node & {
  __typename?: 'EnglishWord';
  createdAt: Scalars['Datetime'];
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id: Scalars['Int'];
  length?: Maybe<Scalars['Int']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  word: Scalars['String'];
};

/**
 * A condition to be used against `EnglishWord` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type EnglishWordCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `word` field. */
  word?: Maybe<Scalars['String']>;
};

/** A filter to be used against `EnglishWord` object types. All fields are combined with a logical ‘and.’ */
export type EnglishWordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EnglishWordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `frequency` field. */
  frequency?: Maybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `length` field. */
  length?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<EnglishWordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EnglishWordFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `word` field. */
  word?: Maybe<StringFilter>;
};

/** An input for mutations affecting `EnglishWord` */
export type EnglishWordInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word: Scalars['String'];
};

/** Represents an update to a `EnglishWord`. Fields that are set will be updated. */
export type EnglishWordPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word?: Maybe<Scalars['String']>;
};

/** A connection to a list of `EnglishWord` values. */
export type EnglishWordsConnection = {
  __typename?: 'EnglishWordsConnection';
  /** A list of edges which contains the `EnglishWord` and cursor to aid in pagination. */
  edges: Array<EnglishWordsEdge>;
  /** A list of `EnglishWord` objects. */
  nodes: Array<Maybe<EnglishWord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EnglishWord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EnglishWord` edge in the connection. */
export type EnglishWordsEdge = {
  __typename?: 'EnglishWordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `EnglishWord` at the end of the edge. */
  node?: Maybe<EnglishWord>;
};

/** Methods to use when ordering `EnglishWord`. */
export enum EnglishWordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FrequencyAsc = 'FREQUENCY_ASC',
  FrequencyDesc = 'FREQUENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WordAsc = 'WORD_ASC',
  WordDesc = 'WORD_DESC'
}

export type EnglishWouldYouRatherQuestion = Node & {
  __typename?: 'EnglishWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `EnglishWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type EnglishWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `EnglishWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type EnglishWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EnglishWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<EnglishWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EnglishWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `EnglishWouldYouRatherQuestion` */
export type EnglishWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `EnglishWouldYouRatherQuestion`. Fields that are set will be updated. */
export type EnglishWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `EnglishWouldYouRatherQuestion` values. */
export type EnglishWouldYouRatherQuestionsConnection = {
  __typename?: 'EnglishWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `EnglishWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<EnglishWouldYouRatherQuestionsEdge>;
  /** A list of `EnglishWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<EnglishWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EnglishWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EnglishWouldYouRatherQuestion` edge in the connection. */
export type EnglishWouldYouRatherQuestionsEdge = {
  __typename?: 'EnglishWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `EnglishWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<EnglishWouldYouRatherQuestion>;
};

/** Methods to use when ordering `EnglishWouldYouRatherQuestion`. */
export enum EnglishWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Float']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Float']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Float']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Float']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Float']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Float']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Float']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Float']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Float']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export type FrenchRandomQuestion = Node & {
  __typename?: 'FrenchRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `FrenchRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FrenchRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `FrenchRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type FrenchRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FrenchRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<FrenchRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FrenchRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `FrenchRandomQuestion` */
export type FrenchRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `FrenchRandomQuestion`. Fields that are set will be updated. */
export type FrenchRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `FrenchRandomQuestion` values. */
export type FrenchRandomQuestionsConnection = {
  __typename?: 'FrenchRandomQuestionsConnection';
  /** A list of edges which contains the `FrenchRandomQuestion` and cursor to aid in pagination. */
  edges: Array<FrenchRandomQuestionsEdge>;
  /** A list of `FrenchRandomQuestion` objects. */
  nodes: Array<Maybe<FrenchRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FrenchRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `FrenchRandomQuestion` edge in the connection. */
export type FrenchRandomQuestionsEdge = {
  __typename?: 'FrenchRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FrenchRandomQuestion` at the end of the edge. */
  node?: Maybe<FrenchRandomQuestion>;
};

/** Methods to use when ordering `FrenchRandomQuestion`. */
export enum FrenchRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type FrenchWord = Node & {
  __typename?: 'FrenchWord';
  createdAt: Scalars['Datetime'];
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id: Scalars['Int'];
  length?: Maybe<Scalars['Int']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  word: Scalars['String'];
};

/**
 * A condition to be used against `FrenchWord` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FrenchWordCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `word` field. */
  word?: Maybe<Scalars['String']>;
};

/** A filter to be used against `FrenchWord` object types. All fields are combined with a logical ‘and.’ */
export type FrenchWordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FrenchWordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `frequency` field. */
  frequency?: Maybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `length` field. */
  length?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<FrenchWordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FrenchWordFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `word` field. */
  word?: Maybe<StringFilter>;
};

/** An input for mutations affecting `FrenchWord` */
export type FrenchWordInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word: Scalars['String'];
};

/** Represents an update to a `FrenchWord`. Fields that are set will be updated. */
export type FrenchWordPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word?: Maybe<Scalars['String']>;
};

/** A connection to a list of `FrenchWord` values. */
export type FrenchWordsConnection = {
  __typename?: 'FrenchWordsConnection';
  /** A list of edges which contains the `FrenchWord` and cursor to aid in pagination. */
  edges: Array<FrenchWordsEdge>;
  /** A list of `FrenchWord` objects. */
  nodes: Array<Maybe<FrenchWord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FrenchWord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `FrenchWord` edge in the connection. */
export type FrenchWordsEdge = {
  __typename?: 'FrenchWordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FrenchWord` at the end of the edge. */
  node?: Maybe<FrenchWord>;
};

/** Methods to use when ordering `FrenchWord`. */
export enum FrenchWordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FrequencyAsc = 'FREQUENCY_ASC',
  FrequencyDesc = 'FREQUENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WordAsc = 'WORD_ASC',
  WordDesc = 'WORD_DESC'
}

export type FrenchWouldYouRatherQuestion = Node & {
  __typename?: 'FrenchWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `FrenchWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FrenchWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `FrenchWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type FrenchWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FrenchWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<FrenchWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FrenchWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `FrenchWouldYouRatherQuestion` */
export type FrenchWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `FrenchWouldYouRatherQuestion`. Fields that are set will be updated. */
export type FrenchWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `FrenchWouldYouRatherQuestion` values. */
export type FrenchWouldYouRatherQuestionsConnection = {
  __typename?: 'FrenchWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `FrenchWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<FrenchWouldYouRatherQuestionsEdge>;
  /** A list of `FrenchWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<FrenchWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FrenchWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `FrenchWouldYouRatherQuestion` edge in the connection. */
export type FrenchWouldYouRatherQuestionsEdge = {
  __typename?: 'FrenchWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FrenchWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<FrenchWouldYouRatherQuestion>;
};

/** Methods to use when ordering `FrenchWouldYouRatherQuestion`. */
export enum FrenchWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** All input for the `generateSnowflakeId` mutation. */
export type GenerateSnowflakeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our `generateSnowflakeId` mutation. */
export type GenerateSnowflakeIdPayload = {
  __typename?: 'GenerateSnowflakeIdPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  result?: Maybe<Scalars['BigInt']>;
};

export type GermanRandomQuestion = Node & {
  __typename?: 'GermanRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `GermanRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type GermanRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `GermanRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type GermanRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GermanRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<GermanRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GermanRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `GermanRandomQuestion` */
export type GermanRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `GermanRandomQuestion`. Fields that are set will be updated. */
export type GermanRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `GermanRandomQuestion` values. */
export type GermanRandomQuestionsConnection = {
  __typename?: 'GermanRandomQuestionsConnection';
  /** A list of edges which contains the `GermanRandomQuestion` and cursor to aid in pagination. */
  edges: Array<GermanRandomQuestionsEdge>;
  /** A list of `GermanRandomQuestion` objects. */
  nodes: Array<Maybe<GermanRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GermanRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GermanRandomQuestion` edge in the connection. */
export type GermanRandomQuestionsEdge = {
  __typename?: 'GermanRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GermanRandomQuestion` at the end of the edge. */
  node?: Maybe<GermanRandomQuestion>;
};

/** Methods to use when ordering `GermanRandomQuestion`. */
export enum GermanRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type GermanWord = Node & {
  __typename?: 'GermanWord';
  createdAt: Scalars['Datetime'];
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id: Scalars['Int'];
  length?: Maybe<Scalars['Int']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  word: Scalars['String'];
};

/**
 * A condition to be used against `GermanWord` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GermanWordCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `word` field. */
  word?: Maybe<Scalars['String']>;
};

/** A filter to be used against `GermanWord` object types. All fields are combined with a logical ‘and.’ */
export type GermanWordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GermanWordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `frequency` field. */
  frequency?: Maybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `length` field. */
  length?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<GermanWordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GermanWordFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `word` field. */
  word?: Maybe<StringFilter>;
};

/** An input for mutations affecting `GermanWord` */
export type GermanWordInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word: Scalars['String'];
};

/** Represents an update to a `GermanWord`. Fields that are set will be updated. */
export type GermanWordPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word?: Maybe<Scalars['String']>;
};

/** A connection to a list of `GermanWord` values. */
export type GermanWordsConnection = {
  __typename?: 'GermanWordsConnection';
  /** A list of edges which contains the `GermanWord` and cursor to aid in pagination. */
  edges: Array<GermanWordsEdge>;
  /** A list of `GermanWord` objects. */
  nodes: Array<Maybe<GermanWord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GermanWord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GermanWord` edge in the connection. */
export type GermanWordsEdge = {
  __typename?: 'GermanWordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GermanWord` at the end of the edge. */
  node?: Maybe<GermanWord>;
};

/** Methods to use when ordering `GermanWord`. */
export enum GermanWordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FrequencyAsc = 'FREQUENCY_ASC',
  FrequencyDesc = 'FREQUENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WordAsc = 'WORD_ASC',
  WordDesc = 'WORD_DESC'
}

export type GermanWouldYouRatherQuestion = Node & {
  __typename?: 'GermanWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `GermanWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type GermanWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `GermanWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type GermanWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GermanWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<GermanWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GermanWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `GermanWouldYouRatherQuestion` */
export type GermanWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `GermanWouldYouRatherQuestion`. Fields that are set will be updated. */
export type GermanWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `GermanWouldYouRatherQuestion` values. */
export type GermanWouldYouRatherQuestionsConnection = {
  __typename?: 'GermanWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `GermanWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<GermanWouldYouRatherQuestionsEdge>;
  /** A list of `GermanWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<GermanWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GermanWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GermanWouldYouRatherQuestion` edge in the connection. */
export type GermanWouldYouRatherQuestionsEdge = {
  __typename?: 'GermanWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GermanWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<GermanWouldYouRatherQuestion>;
};

/** Methods to use when ordering `GermanWouldYouRatherQuestion`. */
export enum GermanWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export enum GrammaticalCase {
  Ablative = 'ABLATIVE',
  Accusative = 'ACCUSATIVE',
  Comitative = 'COMITATIVE',
  Dative = 'DATIVE',
  Essive = 'ESSIVE',
  Genitive = 'GENITIVE',
  Lative = 'LATIVE',
  Nominative = 'NOMINATIVE',
  Vocative = 'VOCATIVE'
}

/** A filter to be used against GrammaticalCase fields. All fields are combined with a logical ‘and.’ */
export type GrammaticalCaseFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<GrammaticalCase>;
  /** Equal to the specified value. */
  equalTo?: Maybe<GrammaticalCase>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<GrammaticalCase>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<GrammaticalCase>;
  /** Included in the specified list. */
  in?: Maybe<Array<GrammaticalCase>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<GrammaticalCase>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<GrammaticalCase>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<GrammaticalCase>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<GrammaticalCase>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<GrammaticalCase>>;
};

export enum GrammaticalGender {
  Feminine = 'FEMININE',
  FemininePlural = 'FEMININE_PLURAL',
  FeminineSingular = 'FEMININE_SINGULAR',
  Masculine = 'MASCULINE',
  MasculinePlural = 'MASCULINE_PLURAL',
  MasculineSingular = 'MASCULINE_SINGULAR',
  Neutral = 'NEUTRAL',
  NeutralPlural = 'NEUTRAL_PLURAL',
  NeutralSingular = 'NEUTRAL_SINGULAR'
}

/** A filter to be used against GrammaticalGender fields. All fields are combined with a logical ‘and.’ */
export type GrammaticalGenderFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<GrammaticalGender>;
  /** Equal to the specified value. */
  equalTo?: Maybe<GrammaticalGender>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<GrammaticalGender>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<GrammaticalGender>;
  /** Included in the specified list. */
  in?: Maybe<Array<GrammaticalGender>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<GrammaticalGender>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<GrammaticalGender>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<GrammaticalGender>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<GrammaticalGender>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<GrammaticalGender>>;
};

export type Group = Node & {
  __typename?: 'Group';
  createdAt: Scalars['Datetime'];
  global: Scalars['Boolean'];
  groupName?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  id: Scalars['Int'];
  /** Reads a single `Language` that is related to this `Group`. */
  language?: Maybe<Language>;
  languageId: Scalars['Int'];
  /** Reads a single `LanguageSkillLevel` that is related to this `Group`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByMessageRecipientGroupIdAndParentMessageId: GroupMessagesByMessageRecipientGroupIdAndParentMessageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientGroupId: MessagesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `NotificationChannel`. */
  notificationChannelsByNotificationRecipientGroupIdAndChannelId: GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByRecipientGroupId: NotificationsConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByGroupUserGroupIdAndUserId: GroupUsersByGroupUserGroupIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByMessageRecipientGroupIdAndRecipientId: GroupUsersByMessageRecipientGroupIdAndRecipientIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByMessageRecipientGroupIdAndSenderId: GroupUsersByMessageRecipientGroupIdAndSenderIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByNotificationRecipientGroupIdAndRecipientId: GroupUsersByNotificationRecipientGroupIdAndRecipientIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type GroupGroupUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupUserCondition>;
  filter?: Maybe<GroupUserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};


export type GroupMessagesByMessageRecipientGroupIdAndParentMessageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


export type GroupMessagesByRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


export type GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationChannelCondition>;
  filter?: Maybe<NotificationChannelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationChannelsOrderBy>>;
};


export type GroupNotificationsByRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};


export type GroupUsersByGroupUserGroupIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type GroupUsersByMessageRecipientGroupIdAndRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type GroupUsersByMessageRecipientGroupIdAndSenderIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type GroupUsersByNotificationRecipientGroupIdAndRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `global` field. */
  global?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `groupName` field. */
  groupName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `languageId` field. */
  languageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `languageSkillLevelId` field. */
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GroupFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `global` field. */
  global?: Maybe<BooleanFilter>;
  /** Filter by the object’s `groupName` field. */
  groupName?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `languageId` field. */
  languageId?: Maybe<IntFilter>;
  /** Filter by the object’s `languageSkillLevelId` field. */
  languageSkillLevelId?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<GroupFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GroupFilter>>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  global?: Maybe<Scalars['Boolean']>;
  groupName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  languageId?: Maybe<Scalars['Int']>;
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Message` values, with data from `Message`. */
export type GroupMessagesByMessageRecipientGroupIdAndParentMessageIdManyToManyConnection = {
  __typename?: 'GroupMessagesByMessageRecipientGroupIdAndParentMessageIdManyToManyConnection';
  /** A list of edges which contains the `Message`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<GroupMessagesByMessageRecipientGroupIdAndParentMessageIdManyToManyEdge>;
  /** A list of `Message` objects. */
  nodes: Array<Maybe<Message>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Message` edge in the connection, with data from `Message`. */
export type GroupMessagesByMessageRecipientGroupIdAndParentMessageIdManyToManyEdge = {
  __typename?: 'GroupMessagesByMessageRecipientGroupIdAndParentMessageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByParentMessageId: MessagesConnection;
  /** The `Message` at the end of the edge. */
  node?: Maybe<Message>;
};


/** A `Message` edge in the connection, with data from `Message`. */
export type GroupMessagesByMessageRecipientGroupIdAndParentMessageIdManyToManyEdgeMessagesByParentMessageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `NotificationChannel` values, with data from `Notification`. */
export type GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdManyToManyConnection = {
  __typename?: 'GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdManyToManyConnection';
  /** A list of edges which contains the `NotificationChannel`, info from the `Notification`, and the cursor to aid in pagination. */
  edges: Array<GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdManyToManyEdge>;
  /** A list of `NotificationChannel` objects. */
  nodes: Array<Maybe<NotificationChannel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NotificationChannel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `NotificationChannel` edge in the connection, with data from `Notification`. */
export type GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdManyToManyEdge = {
  __typename?: 'GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `NotificationChannel` at the end of the edge. */
  node?: Maybe<NotificationChannel>;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByChannelId: NotificationsConnection;
};


/** A `NotificationChannel` edge in the connection, with data from `Notification`. */
export type GroupNotificationChannelsByNotificationRecipientGroupIdAndChannelIdManyToManyEdgeNotificationsByChannelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  global?: Maybe<Scalars['Boolean']>;
  groupName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  languageId?: Maybe<Scalars['Int']>;
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

export type GroupUser = Node & {
  __typename?: 'GroupUser';
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  groupId: Scalars['Int'];
  id: Scalars['Int'];
  joinedOn: Scalars['Datetime'];
  lastActive?: Maybe<Scalars['Datetime']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
  userId: Scalars['Int'];
  userType: UserType;
};

/**
 * A condition to be used against `GroupUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GroupUserCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `joinedOn` field. */
  joinedOn?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `lastActive` field. */
  lastActive?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userType` field. */
  userType?: Maybe<UserType>;
};

/** A filter to be used against `GroupUser` object types. All fields are combined with a logical ‘and.’ */
export type GroupUserFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GroupUserFilter>>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `joinedOn` field. */
  joinedOn?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `lastActive` field. */
  lastActive?: Maybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: Maybe<GroupUserFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GroupUserFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `userType` field. */
  userType?: Maybe<UserTypeFilter>;
};

/** An input for mutations affecting `GroupUser` */
export type GroupUserInput = {
  groupId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  joinedOn?: Maybe<Scalars['Datetime']>;
  lastActive?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['Int']>;
  userType: UserType;
};

/** Represents an update to a `GroupUser`. Fields that are set will be updated. */
export type GroupUserPatch = {
  groupId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  joinedOn?: Maybe<Scalars['Datetime']>;
  lastActive?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['Int']>;
  userType?: Maybe<UserType>;
};

/** A connection to a list of `User` values, with data from `GroupUser`. */
export type GroupUsersByGroupUserGroupIdAndUserIdManyToManyConnection = {
  __typename?: 'GroupUsersByGroupUserGroupIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `GroupUser`, and the cursor to aid in pagination. */
  edges: Array<GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `GroupUser`. */
export type GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdge = {
  __typename?: 'GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `GroupUser`. */
export type GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdgeGroupUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupUserCondition>;
  filter?: Maybe<GroupUserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Message`. */
export type GroupUsersByMessageRecipientGroupIdAndRecipientIdManyToManyConnection = {
  __typename?: 'GroupUsersByMessageRecipientGroupIdAndRecipientIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<GroupUsersByMessageRecipientGroupIdAndRecipientIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Message`. */
export type GroupUsersByMessageRecipientGroupIdAndRecipientIdManyToManyEdge = {
  __typename?: 'GroupUsersByMessageRecipientGroupIdAndRecipientIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientId: MessagesConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Message`. */
export type GroupUsersByMessageRecipientGroupIdAndRecipientIdManyToManyEdgeMessagesByRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Message`. */
export type GroupUsersByMessageRecipientGroupIdAndSenderIdManyToManyConnection = {
  __typename?: 'GroupUsersByMessageRecipientGroupIdAndSenderIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<GroupUsersByMessageRecipientGroupIdAndSenderIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Message`. */
export type GroupUsersByMessageRecipientGroupIdAndSenderIdManyToManyEdge = {
  __typename?: 'GroupUsersByMessageRecipientGroupIdAndSenderIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesBySenderId: MessagesConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Message`. */
export type GroupUsersByMessageRecipientGroupIdAndSenderIdManyToManyEdgeMessagesBySenderIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Notification`. */
export type GroupUsersByNotificationRecipientGroupIdAndRecipientIdManyToManyConnection = {
  __typename?: 'GroupUsersByNotificationRecipientGroupIdAndRecipientIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Notification`, and the cursor to aid in pagination. */
  edges: Array<GroupUsersByNotificationRecipientGroupIdAndRecipientIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Notification`. */
export type GroupUsersByNotificationRecipientGroupIdAndRecipientIdManyToManyEdge = {
  __typename?: 'GroupUsersByNotificationRecipientGroupIdAndRecipientIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByRecipientId: NotificationsConnection;
};


/** A `User` edge in the connection, with data from `Notification`. */
export type GroupUsersByNotificationRecipientGroupIdAndRecipientIdManyToManyEdgeNotificationsByRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** A connection to a list of `GroupUser` values. */
export type GroupUsersConnection = {
  __typename?: 'GroupUsersConnection';
  /** A list of edges which contains the `GroupUser` and cursor to aid in pagination. */
  edges: Array<GroupUsersEdge>;
  /** A list of `GroupUser` objects. */
  nodes: Array<Maybe<GroupUser>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GroupUser` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `GroupUser` edge in the connection. */
export type GroupUsersEdge = {
  __typename?: 'GroupUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GroupUser` at the end of the edge. */
  node?: Maybe<GroupUser>;
};

/** Methods to use when ordering `GroupUser`. */
export enum GroupUsersOrderBy {
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  JoinedOnAsc = 'JOINED_ON_ASC',
  JoinedOnDesc = 'JOINED_ON_DESC',
  LastActiveAsc = 'LAST_ACTIVE_ASC',
  LastActiveDesc = 'LAST_ACTIVE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UserTypeAsc = 'USER_TYPE_ASC',
  UserTypeDesc = 'USER_TYPE_DESC'
}

/** A connection to a list of `Group` values. */
export type GroupsConnection = {
  __typename?: 'GroupsConnection';
  /** A list of edges which contains the `Group` and cursor to aid in pagination. */
  edges: Array<GroupsEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Maybe<Group>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection. */
export type GroupsEdge = {
  __typename?: 'GroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Group` at the end of the edge. */
  node?: Maybe<Group>;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  GlobalAsc = 'GLOBAL_ASC',
  GlobalDesc = 'GLOBAL_DESC',
  GroupNameAsc = 'GROUP_NAME_ASC',
  GroupNameDesc = 'GROUP_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LanguageIdAsc = 'LANGUAGE_ID_ASC',
  LanguageIdDesc = 'LANGUAGE_ID_DESC',
  LanguageSkillLevelIdAsc = 'LANGUAGE_SKILL_LEVEL_ID_ASC',
  LanguageSkillLevelIdDesc = 'LANGUAGE_SKILL_LEVEL_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type InviteToken = Node & {
  __typename?: 'InviteToken';
  createdAt: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  inviteToken: Scalars['String'];
  /** Reads and enables pagination through a set of `Language`. */
  languagesByUserSignedUpWithTokenIdAndLocale: InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `InviteToken`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `User`. */
  usersBySignedUpWithTokenId: UsersConnection;
};


export type InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type InviteTokenUsersBySignedUpWithTokenIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `InviteToken` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type InviteTokenCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `inviteToken` field. */
  inviteToken?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `InviteToken` object types. All fields are combined with a logical ‘and.’ */
export type InviteTokenFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InviteTokenFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `inviteToken` field. */
  inviteToken?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<InviteTokenFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InviteTokenFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
};

/** An input for mutations affecting `InviteToken` */
export type InviteTokenInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  inviteToken?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `Language` values, with data from `User`. */
export type InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleManyToManyConnection = {
  __typename?: 'InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `User`, and the cursor to aid in pagination. */
  edges: Array<InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `User`. */
export type InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleManyToManyEdge = {
  __typename?: 'InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
  /** Reads and enables pagination through a set of `User`. */
  usersByLocale: UsersConnection;
};


/** A `Language` edge in the connection, with data from `User`. */
export type InviteTokenLanguagesByUserSignedUpWithTokenIdAndLocaleManyToManyEdgeUsersByLocaleArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** Represents an update to a `InviteToken`. Fields that are set will be updated. */
export type InviteTokenPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  inviteToken?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `InviteToken` values. */
export type InviteTokensConnection = {
  __typename?: 'InviteTokensConnection';
  /** A list of edges which contains the `InviteToken` and cursor to aid in pagination. */
  edges: Array<InviteTokensEdge>;
  /** A list of `InviteToken` objects. */
  nodes: Array<Maybe<InviteToken>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InviteToken` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `InviteToken` edge in the connection. */
export type InviteTokensEdge = {
  __typename?: 'InviteTokensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InviteToken` at the end of the edge. */
  node?: Maybe<InviteToken>;
};

/** Methods to use when ordering `InviteToken`. */
export enum InviteTokensOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InviteTokenAsc = 'INVITE_TOKEN_ASC',
  InviteTokenDesc = 'INVITE_TOKEN_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type ItalianRandomQuestion = Node & {
  __typename?: 'ItalianRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `ItalianRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ItalianRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `ItalianRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type ItalianRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ItalianRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<ItalianRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ItalianRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `ItalianRandomQuestion` */
export type ItalianRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `ItalianRandomQuestion`. Fields that are set will be updated. */
export type ItalianRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `ItalianRandomQuestion` values. */
export type ItalianRandomQuestionsConnection = {
  __typename?: 'ItalianRandomQuestionsConnection';
  /** A list of edges which contains the `ItalianRandomQuestion` and cursor to aid in pagination. */
  edges: Array<ItalianRandomQuestionsEdge>;
  /** A list of `ItalianRandomQuestion` objects. */
  nodes: Array<Maybe<ItalianRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ItalianRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ItalianRandomQuestion` edge in the connection. */
export type ItalianRandomQuestionsEdge = {
  __typename?: 'ItalianRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ItalianRandomQuestion` at the end of the edge. */
  node?: Maybe<ItalianRandomQuestion>;
};

/** Methods to use when ordering `ItalianRandomQuestion`. */
export enum ItalianRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type ItalianWord = Node & {
  __typename?: 'ItalianWord';
  createdAt: Scalars['Datetime'];
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id: Scalars['Int'];
  length?: Maybe<Scalars['Int']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  word: Scalars['String'];
};

/**
 * A condition to be used against `ItalianWord` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ItalianWordCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `word` field. */
  word?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ItalianWord` object types. All fields are combined with a logical ‘and.’ */
export type ItalianWordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ItalianWordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `frequency` field. */
  frequency?: Maybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `length` field. */
  length?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<ItalianWordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ItalianWordFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `word` field. */
  word?: Maybe<StringFilter>;
};

/** An input for mutations affecting `ItalianWord` */
export type ItalianWordInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word: Scalars['String'];
};

/** Represents an update to a `ItalianWord`. Fields that are set will be updated. */
export type ItalianWordPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ItalianWord` values. */
export type ItalianWordsConnection = {
  __typename?: 'ItalianWordsConnection';
  /** A list of edges which contains the `ItalianWord` and cursor to aid in pagination. */
  edges: Array<ItalianWordsEdge>;
  /** A list of `ItalianWord` objects. */
  nodes: Array<Maybe<ItalianWord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ItalianWord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ItalianWord` edge in the connection. */
export type ItalianWordsEdge = {
  __typename?: 'ItalianWordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ItalianWord` at the end of the edge. */
  node?: Maybe<ItalianWord>;
};

/** Methods to use when ordering `ItalianWord`. */
export enum ItalianWordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FrequencyAsc = 'FREQUENCY_ASC',
  FrequencyDesc = 'FREQUENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WordAsc = 'WORD_ASC',
  WordDesc = 'WORD_DESC'
}

export type ItalianWouldYouRatherQuestion = Node & {
  __typename?: 'ItalianWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `ItalianWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ItalianWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `ItalianWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type ItalianWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ItalianWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<ItalianWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ItalianWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `ItalianWouldYouRatherQuestion` */
export type ItalianWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `ItalianWouldYouRatherQuestion`. Fields that are set will be updated. */
export type ItalianWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `ItalianWouldYouRatherQuestion` values. */
export type ItalianWouldYouRatherQuestionsConnection = {
  __typename?: 'ItalianWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `ItalianWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<ItalianWouldYouRatherQuestionsEdge>;
  /** A list of `ItalianWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<ItalianWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ItalianWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ItalianWouldYouRatherQuestion` edge in the connection. */
export type ItalianWouldYouRatherQuestionsEdge = {
  __typename?: 'ItalianWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ItalianWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<ItalianWouldYouRatherQuestion>;
};

/** Methods to use when ordering `ItalianWouldYouRatherQuestion`. */
export enum ItalianWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type JapaneseRandomQuestion = Node & {
  __typename?: 'JapaneseRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `JapaneseRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type JapaneseRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `JapaneseRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type JapaneseRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<JapaneseRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<JapaneseRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<JapaneseRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `JapaneseRandomQuestion` */
export type JapaneseRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `JapaneseRandomQuestion`. Fields that are set will be updated. */
export type JapaneseRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `JapaneseRandomQuestion` values. */
export type JapaneseRandomQuestionsConnection = {
  __typename?: 'JapaneseRandomQuestionsConnection';
  /** A list of edges which contains the `JapaneseRandomQuestion` and cursor to aid in pagination. */
  edges: Array<JapaneseRandomQuestionsEdge>;
  /** A list of `JapaneseRandomQuestion` objects. */
  nodes: Array<Maybe<JapaneseRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JapaneseRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `JapaneseRandomQuestion` edge in the connection. */
export type JapaneseRandomQuestionsEdge = {
  __typename?: 'JapaneseRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `JapaneseRandomQuestion` at the end of the edge. */
  node?: Maybe<JapaneseRandomQuestion>;
};

/** Methods to use when ordering `JapaneseRandomQuestion`. */
export enum JapaneseRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type JapaneseWouldYouRatherQuestion = Node & {
  __typename?: 'JapaneseWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `JapaneseWouldYouRatherQuestion` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type JapaneseWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `JapaneseWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type JapaneseWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<JapaneseWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<JapaneseWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<JapaneseWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `JapaneseWouldYouRatherQuestion` */
export type JapaneseWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `JapaneseWouldYouRatherQuestion`. Fields that are set will be updated. */
export type JapaneseWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `JapaneseWouldYouRatherQuestion` values. */
export type JapaneseWouldYouRatherQuestionsConnection = {
  __typename?: 'JapaneseWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `JapaneseWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<JapaneseWouldYouRatherQuestionsEdge>;
  /** A list of `JapaneseWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<JapaneseWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JapaneseWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `JapaneseWouldYouRatherQuestion` edge in the connection. */
export type JapaneseWouldYouRatherQuestionsEdge = {
  __typename?: 'JapaneseWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `JapaneseWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<JapaneseWouldYouRatherQuestion>;
};

/** Methods to use when ordering `JapaneseWouldYouRatherQuestion`. */
export enum JapaneseWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** All input for the `joinGlobalGroup` mutation. */
export type JoinGlobalGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupUuid: Scalars['UUID'];
};

/** The output of our `joinGlobalGroup` mutation. */
export type JoinGlobalGroupPayload = {
  __typename?: 'JoinGlobalGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  groupUser?: Maybe<GroupUser>;
  /** An edge for our `GroupUser`. May be used by Relay 1. */
  groupUserEdge?: Maybe<GroupUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
};


/** The output of our `joinGlobalGroup` mutation. */
export type JoinGlobalGroupPayloadGroupUserEdgeArgs = {
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};

export type KoreanRandomQuestion = Node & {
  __typename?: 'KoreanRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `KoreanRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type KoreanRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `KoreanRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type KoreanRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<KoreanRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<KoreanRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<KoreanRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `KoreanRandomQuestion` */
export type KoreanRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `KoreanRandomQuestion`. Fields that are set will be updated. */
export type KoreanRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `KoreanRandomQuestion` values. */
export type KoreanRandomQuestionsConnection = {
  __typename?: 'KoreanRandomQuestionsConnection';
  /** A list of edges which contains the `KoreanRandomQuestion` and cursor to aid in pagination. */
  edges: Array<KoreanRandomQuestionsEdge>;
  /** A list of `KoreanRandomQuestion` objects. */
  nodes: Array<Maybe<KoreanRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `KoreanRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `KoreanRandomQuestion` edge in the connection. */
export type KoreanRandomQuestionsEdge = {
  __typename?: 'KoreanRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `KoreanRandomQuestion` at the end of the edge. */
  node?: Maybe<KoreanRandomQuestion>;
};

/** Methods to use when ordering `KoreanRandomQuestion`. */
export enum KoreanRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type KoreanWouldYouRatherQuestion = Node & {
  __typename?: 'KoreanWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `KoreanWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type KoreanWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `KoreanWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type KoreanWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<KoreanWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<KoreanWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<KoreanWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `KoreanWouldYouRatherQuestion` */
export type KoreanWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `KoreanWouldYouRatherQuestion`. Fields that are set will be updated. */
export type KoreanWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `KoreanWouldYouRatherQuestion` values. */
export type KoreanWouldYouRatherQuestionsConnection = {
  __typename?: 'KoreanWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `KoreanWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<KoreanWouldYouRatherQuestionsEdge>;
  /** A list of `KoreanWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<KoreanWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `KoreanWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `KoreanWouldYouRatherQuestion` edge in the connection. */
export type KoreanWouldYouRatherQuestionsEdge = {
  __typename?: 'KoreanWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `KoreanWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<KoreanWouldYouRatherQuestion>;
};

/** Methods to use when ordering `KoreanWouldYouRatherQuestion`. */
export enum KoreanWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Language = Node & {
  __typename?: 'Language';
  /** ISO 3166-1 alpha-2 standardized code */
  alpha2: Scalars['String'];
  createdAt: Scalars['Datetime'];
  englishName: Scalars['String'];
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  id: Scalars['Int'];
  /** Reads and enables pagination through a set of `InviteToken`. */
  inviteTokensByUserLocaleAndSignedUpWithTokenId: LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdManyToManyConnection;
  /** Reads and enables pagination through a set of `LanguageSkillLevel`. */
  languageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelId: LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdManyToManyConnection;
  /** Reads and enables pagination through a set of `LanguageSkillLevel`. */
  languageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelId: LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdManyToManyConnection;
  /** Reads and enables pagination through a set of `LanguageSkillLevel`. */
  languageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelId: LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
  /** Reads and enables pagination through a set of `Post`. */
  postsByPostLanguageIdAndParentPostId: LanguagePostsByPostLanguageIdAndParentPostIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Prompt`. */
  prompts: PromptsConnection;
  /** Reads and enables pagination through a set of `Prompt`. */
  promptsByPostLanguageIdAndPromptId: LanguagePromptsByPostLanguageIdAndPromptIdManyToManyConnection;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
  /** Reads and enables pagination through a set of `UserPreference`. */
  userPreferencesByFeedLanguageId: UserPreferencesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByLocale: UsersConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostLanguageIdAndAuthorId: LanguageUsersByPostLanguageIdAndAuthorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserLanguageLanguageIdAndUserId: LanguageUsersByUserLanguageLanguageIdAndUserIdManyToManyConnection;
};


export type LanguageGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<InviteTokenCondition>;
  filter?: Maybe<InviteTokenFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<InviteTokensOrderBy>>;
};


export type LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageSkillLevelCondition>;
  filter?: Maybe<LanguageSkillLevelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};


export type LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageSkillLevelCondition>;
  filter?: Maybe<LanguageSkillLevelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};


export type LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageSkillLevelCondition>;
  filter?: Maybe<LanguageSkillLevelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};


export type LanguagePostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type LanguagePostsByPostLanguageIdAndParentPostIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type LanguagePromptsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};


export type LanguagePromptsByPostLanguageIdAndPromptIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};


export type LanguageUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};


export type LanguageUserPreferencesByFeedLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserPreferenceCondition>;
  filter?: Maybe<UserPreferenceFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserPreferencesOrderBy>>;
};


export type LanguageUsersByLocaleArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type LanguageUsersByPostLanguageIdAndAuthorIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type LanguageUsersByUserLanguageLanguageIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `Language` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LanguageCondition = {
  /** Checks for equality with the object’s `alpha2` field. */
  alpha2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `englishName` field. */
  englishName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `Language` object types. All fields are combined with a logical ‘and.’ */
export type LanguageFilter = {
  /** Filter by the object’s `alpha2` field. */
  alpha2?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LanguageFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `englishName` field. */
  englishName?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<LanguageFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LanguageFilter>>;
};

/** An input for mutations affecting `Language` */
export type LanguageInput = {
  /** ISO 3166-1 alpha-2 standardized code */
  alpha2: Scalars['String'];
  createdAt?: Maybe<Scalars['Datetime']>;
  englishName: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `InviteToken` values, with data from `User`. */
export type LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdManyToManyConnection = {
  __typename?: 'LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdManyToManyConnection';
  /** A list of edges which contains the `InviteToken`, info from the `User`, and the cursor to aid in pagination. */
  edges: Array<LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdManyToManyEdge>;
  /** A list of `InviteToken` objects. */
  nodes: Array<Maybe<InviteToken>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InviteToken` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `InviteToken` edge in the connection, with data from `User`. */
export type LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdManyToManyEdge = {
  __typename?: 'LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InviteToken` at the end of the edge. */
  node?: Maybe<InviteToken>;
  /** Reads and enables pagination through a set of `User`. */
  usersBySignedUpWithTokenId: UsersConnection;
};


/** A `InviteToken` edge in the connection, with data from `User`. */
export type LanguageInviteTokensByUserLocaleAndSignedUpWithTokenIdManyToManyEdgeUsersBySignedUpWithTokenIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `LanguageSkillLevel` values, with data from `Group`. */
export type LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdManyToManyConnection = {
  __typename?: 'LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdManyToManyConnection';
  /** A list of edges which contains the `LanguageSkillLevel`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdManyToManyEdge>;
  /** A list of `LanguageSkillLevel` objects. */
  nodes: Array<Maybe<LanguageSkillLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LanguageSkillLevel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LanguageSkillLevel` edge in the connection, with data from `Group`. */
export type LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdManyToManyEdge = {
  __typename?: 'LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** The `LanguageSkillLevel` at the end of the edge. */
  node?: Maybe<LanguageSkillLevel>;
};


/** A `LanguageSkillLevel` edge in the connection, with data from `Group`. */
export type LanguageLanguageSkillLevelsByGroupLanguageIdAndLanguageSkillLevelIdManyToManyEdgeGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `LanguageSkillLevel` values, with data from `Prompt`. */
export type LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdManyToManyConnection = {
  __typename?: 'LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdManyToManyConnection';
  /** A list of edges which contains the `LanguageSkillLevel`, info from the `Prompt`, and the cursor to aid in pagination. */
  edges: Array<LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdManyToManyEdge>;
  /** A list of `LanguageSkillLevel` objects. */
  nodes: Array<Maybe<LanguageSkillLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LanguageSkillLevel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LanguageSkillLevel` edge in the connection, with data from `Prompt`. */
export type LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdManyToManyEdge = {
  __typename?: 'LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LanguageSkillLevel` at the end of the edge. */
  node?: Maybe<LanguageSkillLevel>;
  /** Reads and enables pagination through a set of `Prompt`. */
  promptsByRecommendedSkillLevelId: PromptsConnection;
};


/** A `LanguageSkillLevel` edge in the connection, with data from `Prompt`. */
export type LanguageLanguageSkillLevelsByPromptLanguageIdAndRecommendedSkillLevelIdManyToManyEdgePromptsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};

/** A connection to a list of `LanguageSkillLevel` values, with data from `UserLanguage`. */
export type LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdManyToManyConnection = {
  __typename?: 'LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdManyToManyConnection';
  /** A list of edges which contains the `LanguageSkillLevel`, info from the `UserLanguage`, and the cursor to aid in pagination. */
  edges: Array<LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdManyToManyEdge>;
  /** A list of `LanguageSkillLevel` objects. */
  nodes: Array<Maybe<LanguageSkillLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LanguageSkillLevel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LanguageSkillLevel` edge in the connection, with data from `UserLanguage`. */
export type LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdManyToManyEdge = {
  __typename?: 'LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LanguageSkillLevel` at the end of the edge. */
  node?: Maybe<LanguageSkillLevel>;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
};


/** A `LanguageSkillLevel` edge in the connection, with data from `UserLanguage`. */
export type LanguageLanguageSkillLevelsByUserLanguageLanguageIdAndLanguageSkillLevelIdManyToManyEdgeUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** Represents an update to a `Language`. Fields that are set will be updated. */
export type LanguagePatch = {
  /** ISO 3166-1 alpha-2 standardized code */
  alpha2?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  englishName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `Post` values, with data from `Post`. */
export type LanguagePostsByPostLanguageIdAndParentPostIdManyToManyConnection = {
  __typename?: 'LanguagePostsByPostLanguageIdAndParentPostIdManyToManyConnection';
  /** A list of edges which contains the `Post`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<LanguagePostsByPostLanguageIdAndParentPostIdManyToManyEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection, with data from `Post`. */
export type LanguagePostsByPostLanguageIdAndParentPostIdManyToManyEdge = {
  __typename?: 'LanguagePostsByPostLanguageIdAndParentPostIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
  /** Reads and enables pagination through a set of `Post`. */
  replies: PostsConnection;
};


/** A `Post` edge in the connection, with data from `Post`. */
export type LanguagePostsByPostLanguageIdAndParentPostIdManyToManyEdgeRepliesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** A connection to a list of `Prompt` values, with data from `Post`. */
export type LanguagePromptsByPostLanguageIdAndPromptIdManyToManyConnection = {
  __typename?: 'LanguagePromptsByPostLanguageIdAndPromptIdManyToManyConnection';
  /** A list of edges which contains the `Prompt`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<LanguagePromptsByPostLanguageIdAndPromptIdManyToManyEdge>;
  /** A list of `Prompt` objects. */
  nodes: Array<Maybe<Prompt>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Prompt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Prompt` edge in the connection, with data from `Post`. */
export type LanguagePromptsByPostLanguageIdAndPromptIdManyToManyEdge = {
  __typename?: 'LanguagePromptsByPostLanguageIdAndPromptIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Prompt` at the end of the edge. */
  node?: Maybe<Prompt>;
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
};


/** A `Prompt` edge in the connection, with data from `Post`. */
export type LanguagePromptsByPostLanguageIdAndPromptIdManyToManyEdgePostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

export type LanguageSkillLevel = Node & {
  __typename?: 'LanguageSkillLevel';
  /** Reads and enables pagination through a set of `ChineseGuessCharacterQuestion`. */
  chineseGuessCharacterQuestionsByRecommendedSkillLevelId: ChineseGuessCharacterQuestionsConnection;
  /** Reads and enables pagination through a set of `ChineseRandomQuestion`. */
  chineseRandomQuestionsByRecommendedSkillLevelId: ChineseRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `ChineseWouldYouRatherQuestion`. */
  chineseWouldYouRatherQuestionsByRecommendedSkillLevelId: ChineseWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `EnglishRandomQuestion`. */
  englishRandomQuestionsByRecommendedSkillLevelId: EnglishRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `EnglishWord`. */
  englishWordsByRecommendedSkillLevelId: EnglishWordsConnection;
  /** Reads and enables pagination through a set of `EnglishWouldYouRatherQuestion`. */
  englishWouldYouRatherQuestionsByRecommendedSkillLevelId: EnglishWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `FrenchRandomQuestion`. */
  frenchRandomQuestionsByRecommendedSkillLevelId: FrenchRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `FrenchWord`. */
  frenchWordsByRecommendedSkillLevelId: FrenchWordsConnection;
  /** Reads and enables pagination through a set of `FrenchWouldYouRatherQuestion`. */
  frenchWouldYouRatherQuestionsByRecommendedSkillLevelId: FrenchWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `GermanRandomQuestion`. */
  germanRandomQuestionsByRecommendedSkillLevelId: GermanRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `GermanWord`. */
  germanWordsByRecommendedSkillLevelId: GermanWordsConnection;
  /** Reads and enables pagination through a set of `GermanWouldYouRatherQuestion`. */
  germanWouldYouRatherQuestionsByRecommendedSkillLevelId: GermanWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  id: Scalars['Int'];
  /** Reads and enables pagination through a set of `ItalianRandomQuestion`. */
  italianRandomQuestionsByRecommendedSkillLevelId: ItalianRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `ItalianWord`. */
  italianWordsByRecommendedSkillLevelId: ItalianWordsConnection;
  /** Reads and enables pagination through a set of `ItalianWouldYouRatherQuestion`. */
  italianWouldYouRatherQuestionsByRecommendedSkillLevelId: ItalianWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `JapaneseRandomQuestion`. */
  japaneseRandomQuestionsByRecommendedSkillLevelId: JapaneseRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `JapaneseWouldYouRatherQuestion`. */
  japaneseWouldYouRatherQuestionsByRecommendedSkillLevelId: JapaneseWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `KoreanRandomQuestion`. */
  koreanRandomQuestionsByRecommendedSkillLevelId: KoreanRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `KoreanWouldYouRatherQuestion`. */
  koreanWouldYouRatherQuestionsByRecommendedSkillLevelId: KoreanWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `Language`. */
  languagesByGroupLanguageSkillLevelIdAndLanguageId: LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Language`. */
  languagesByPromptRecommendedSkillLevelIdAndLanguageId: LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Language`. */
  languagesByUserLanguageLanguageSkillLevelIdAndLanguageId: LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdManyToManyConnection;
  name?: Maybe<Scalars['String']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `PortugueseRandomQuestion`. */
  portugueseRandomQuestionsByRecommendedSkillLevelId: PortugueseRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `PortugueseWord`. */
  portugueseWordsByRecommendedSkillLevelId: PortugueseWordsConnection;
  /** Reads and enables pagination through a set of `PortugueseWouldYouRatherQuestion`. */
  portugueseWouldYouRatherQuestionsByRecommendedSkillLevelId: PortugueseWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `Prompt`. */
  promptsByRecommendedSkillLevelId: PromptsConnection;
  /** Reads and enables pagination through a set of `RussianRandomQuestion`. */
  russianRandomQuestionsByRecommendedSkillLevelId: RussianRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `RussianWord`. */
  russianWordsByRecommendedSkillLevelId: RussianWordsConnection;
  /** Reads and enables pagination through a set of `RussianWouldYouRatherQuestion`. */
  russianWouldYouRatherQuestionsByRecommendedSkillLevelId: RussianWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `SpanishRandomQuestion`. */
  spanishRandomQuestionsByRecommendedSkillLevelId: SpanishRandomQuestionsConnection;
  /** Reads and enables pagination through a set of `SpanishWord`. */
  spanishWordsByRecommendedSkillLevelId: SpanishWordsConnection;
  /** Reads and enables pagination through a set of `SpanishWouldYouRatherQuestion`. */
  spanishWouldYouRatherQuestionsByRecommendedSkillLevelId: SpanishWouldYouRatherQuestionsConnection;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserLanguageLanguageSkillLevelIdAndUserId: LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdManyToManyConnection;
};


export type LanguageSkillLevelChineseGuessCharacterQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ChineseGuessCharacterQuestionCondition>;
  filter?: Maybe<ChineseGuessCharacterQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ChineseGuessCharacterQuestionsOrderBy>>;
};


export type LanguageSkillLevelChineseRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ChineseRandomQuestionCondition>;
  filter?: Maybe<ChineseRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ChineseRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelChineseWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ChineseWouldYouRatherQuestionCondition>;
  filter?: Maybe<ChineseWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ChineseWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelEnglishRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EnglishRandomQuestionCondition>;
  filter?: Maybe<EnglishRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EnglishRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelEnglishWordsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EnglishWordCondition>;
  filter?: Maybe<EnglishWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EnglishWordsOrderBy>>;
};


export type LanguageSkillLevelEnglishWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EnglishWouldYouRatherQuestionCondition>;
  filter?: Maybe<EnglishWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EnglishWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelFrenchRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<FrenchRandomQuestionCondition>;
  filter?: Maybe<FrenchRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FrenchRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelFrenchWordsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<FrenchWordCondition>;
  filter?: Maybe<FrenchWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FrenchWordsOrderBy>>;
};


export type LanguageSkillLevelFrenchWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<FrenchWouldYouRatherQuestionCondition>;
  filter?: Maybe<FrenchWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FrenchWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelGermanRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GermanRandomQuestionCondition>;
  filter?: Maybe<GermanRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GermanRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelGermanWordsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GermanWordCondition>;
  filter?: Maybe<GermanWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GermanWordsOrderBy>>;
};


export type LanguageSkillLevelGermanWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GermanWouldYouRatherQuestionCondition>;
  filter?: Maybe<GermanWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GermanWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type LanguageSkillLevelItalianRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ItalianRandomQuestionCondition>;
  filter?: Maybe<ItalianRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ItalianRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelItalianWordsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ItalianWordCondition>;
  filter?: Maybe<ItalianWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ItalianWordsOrderBy>>;
};


export type LanguageSkillLevelItalianWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ItalianWouldYouRatherQuestionCondition>;
  filter?: Maybe<ItalianWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ItalianWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelJapaneseRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<JapaneseRandomQuestionCondition>;
  filter?: Maybe<JapaneseRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<JapaneseRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelJapaneseWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<JapaneseWouldYouRatherQuestionCondition>;
  filter?: Maybe<JapaneseWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<JapaneseWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelKoreanRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<KoreanRandomQuestionCondition>;
  filter?: Maybe<KoreanRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<KoreanRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelKoreanWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<KoreanWouldYouRatherQuestionCondition>;
  filter?: Maybe<KoreanWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<KoreanWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type LanguageSkillLevelPortugueseRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PortugueseRandomQuestionCondition>;
  filter?: Maybe<PortugueseRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PortugueseRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelPortugueseWordsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PortugueseWordCondition>;
  filter?: Maybe<PortugueseWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PortugueseWordsOrderBy>>;
};


export type LanguageSkillLevelPortugueseWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PortugueseWouldYouRatherQuestionCondition>;
  filter?: Maybe<PortugueseWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PortugueseWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelPromptsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};


export type LanguageSkillLevelRussianRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<RussianRandomQuestionCondition>;
  filter?: Maybe<RussianRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<RussianRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelRussianWordsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<RussianWordCondition>;
  filter?: Maybe<RussianWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<RussianWordsOrderBy>>;
};


export type LanguageSkillLevelRussianWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<RussianWouldYouRatherQuestionCondition>;
  filter?: Maybe<RussianWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<RussianWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelSpanishRandomQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<SpanishRandomQuestionCondition>;
  filter?: Maybe<SpanishRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SpanishRandomQuestionsOrderBy>>;
};


export type LanguageSkillLevelSpanishWordsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<SpanishWordCondition>;
  filter?: Maybe<SpanishWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SpanishWordsOrderBy>>;
};


export type LanguageSkillLevelSpanishWouldYouRatherQuestionsByRecommendedSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<SpanishWouldYouRatherQuestionCondition>;
  filter?: Maybe<SpanishWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SpanishWouldYouRatherQuestionsOrderBy>>;
};


export type LanguageSkillLevelUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};


export type LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `LanguageSkillLevel` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LanguageSkillLevelCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A filter to be used against `LanguageSkillLevel` object types. All fields are combined with a logical ‘and.’ */
export type LanguageSkillLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LanguageSkillLevelFilter>>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<LanguageSkillLevelFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LanguageSkillLevelFilter>>;
};

/** An input for mutations affecting `LanguageSkillLevel` */
export type LanguageSkillLevelInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Language` values, with data from `Group`. */
export type LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdManyToManyConnection = {
  __typename?: 'LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `Group`. */
export type LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdManyToManyEdge = {
  __typename?: 'LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
};


/** A `Language` edge in the connection, with data from `Group`. */
export type LanguageSkillLevelLanguagesByGroupLanguageSkillLevelIdAndLanguageIdManyToManyEdgeGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `Language` values, with data from `Prompt`. */
export type LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdManyToManyConnection = {
  __typename?: 'LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `Prompt`, and the cursor to aid in pagination. */
  edges: Array<LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `Prompt`. */
export type LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdManyToManyEdge = {
  __typename?: 'LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
  /** Reads and enables pagination through a set of `Prompt`. */
  prompts: PromptsConnection;
};


/** A `Language` edge in the connection, with data from `Prompt`. */
export type LanguageSkillLevelLanguagesByPromptRecommendedSkillLevelIdAndLanguageIdManyToManyEdgePromptsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};

/** A connection to a list of `Language` values, with data from `UserLanguage`. */
export type LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdManyToManyConnection = {
  __typename?: 'LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `UserLanguage`, and the cursor to aid in pagination. */
  edges: Array<LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `UserLanguage`. */
export type LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdManyToManyEdge = {
  __typename?: 'LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
};


/** A `Language` edge in the connection, with data from `UserLanguage`. */
export type LanguageSkillLevelLanguagesByUserLanguageLanguageSkillLevelIdAndLanguageIdManyToManyEdgeUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** Represents an update to a `LanguageSkillLevel`. Fields that are set will be updated. */
export type LanguageSkillLevelPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** A connection to a list of `User` values, with data from `UserLanguage`. */
export type LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdManyToManyConnection = {
  __typename?: 'LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserLanguage`, and the cursor to aid in pagination. */
  edges: Array<LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `UserLanguage`. */
export type LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdManyToManyEdge = {
  __typename?: 'LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
};


/** A `User` edge in the connection, with data from `UserLanguage`. */
export type LanguageSkillLevelUsersByUserLanguageLanguageSkillLevelIdAndUserIdManyToManyEdgeUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** A connection to a list of `LanguageSkillLevel` values. */
export type LanguageSkillLevelsConnection = {
  __typename?: 'LanguageSkillLevelsConnection';
  /** A list of edges which contains the `LanguageSkillLevel` and cursor to aid in pagination. */
  edges: Array<LanguageSkillLevelsEdge>;
  /** A list of `LanguageSkillLevel` objects. */
  nodes: Array<Maybe<LanguageSkillLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LanguageSkillLevel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LanguageSkillLevel` edge in the connection. */
export type LanguageSkillLevelsEdge = {
  __typename?: 'LanguageSkillLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LanguageSkillLevel` at the end of the edge. */
  node?: Maybe<LanguageSkillLevel>;
};

/** Methods to use when ordering `LanguageSkillLevel`. */
export enum LanguageSkillLevelsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `User` values, with data from `Post`. */
export type LanguageUsersByPostLanguageIdAndAuthorIdManyToManyConnection = {
  __typename?: 'LanguageUsersByPostLanguageIdAndAuthorIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<LanguageUsersByPostLanguageIdAndAuthorIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Post`. */
export type LanguageUsersByPostLanguageIdAndAuthorIdManyToManyEdge = {
  __typename?: 'LanguageUsersByPostLanguageIdAndAuthorIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Post`. */
  authoredPosts: PostsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Post`. */
export type LanguageUsersByPostLanguageIdAndAuthorIdManyToManyEdgeAuthoredPostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `UserLanguage`. */
export type LanguageUsersByUserLanguageLanguageIdAndUserIdManyToManyConnection = {
  __typename?: 'LanguageUsersByUserLanguageLanguageIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserLanguage`, and the cursor to aid in pagination. */
  edges: Array<LanguageUsersByUserLanguageLanguageIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `UserLanguage`. */
export type LanguageUsersByUserLanguageLanguageIdAndUserIdManyToManyEdge = {
  __typename?: 'LanguageUsersByUserLanguageLanguageIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
};


/** A `User` edge in the connection, with data from `UserLanguage`. */
export type LanguageUsersByUserLanguageLanguageIdAndUserIdManyToManyEdgeUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** A connection to a list of `Language` values. */
export type LanguagesConnection = {
  __typename?: 'LanguagesConnection';
  /** A list of edges which contains the `Language` and cursor to aid in pagination. */
  edges: Array<LanguagesEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection. */
export type LanguagesEdge = {
  __typename?: 'LanguagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
};

/** Methods to use when ordering `Language`. */
export enum LanguagesOrderBy {
  Alpha2Asc = 'ALPHA2_ASC',
  Alpha2Desc = 'ALPHA2_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EnglishNameAsc = 'ENGLISH_NAME_ASC',
  EnglishNameDesc = 'ENGLISH_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Message = Node & {
  __typename?: 'Message';
  body: Scalars['String'];
  createdAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `Group`. */
  groupsByMessageParentMessageIdAndRecipientGroupId: MessageGroupsByMessageParentMessageIdAndRecipientGroupIdManyToManyConnection;
  id: Scalars['Int'];
  /** Reads and enables pagination through a set of `MessagePreview`. */
  messagePreviews: MessagePreviewsConnection;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByParentMessageId: MessagesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Message` that is related to this `Message`. */
  parentMessage?: Maybe<Message>;
  parentMessageId?: Maybe<Scalars['Int']>;
  /** Reads a single `User` that is related to this `Message`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Message`. */
  recipientGroup?: Maybe<Group>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  recipientId?: Maybe<Scalars['Int']>;
  /** Reads a single `User` that is related to this `Message`. */
  sender?: Maybe<User>;
  senderId?: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByMessageParentMessageIdAndRecipientId: MessageUsersByMessageParentMessageIdAndRecipientIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByMessageParentMessageIdAndSenderId: MessageUsersByMessageParentMessageIdAndSenderIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type MessageGroupsByMessageParentMessageIdAndRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type MessageMessagePreviewsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessagePreviewCondition>;
  filter?: Maybe<MessagePreviewFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagePreviewsOrderBy>>;
};


export type MessageMessagesByParentMessageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


export type MessageUsersByMessageParentMessageIdAndRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type MessageUsersByMessageParentMessageIdAndSenderIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MessageCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `parentMessageId` field. */
  parentMessageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recipientGroupId` field. */
  recipientGroupId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recipientId` field. */
  recipientId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `senderId` field. */
  senderId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `Message` object types. All fields are combined with a logical ‘and.’ */
export type MessageFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MessageFilter>>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<MessageFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MessageFilter>>;
  /** Filter by the object’s `parentMessageId` field. */
  parentMessageId?: Maybe<IntFilter>;
  /** Filter by the object’s `recipientGroupId` field. */
  recipientGroupId?: Maybe<IntFilter>;
  /** Filter by the object’s `recipientId` field. */
  recipientId?: Maybe<IntFilter>;
  /** Filter by the object’s `senderId` field. */
  senderId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** A connection to a list of `Group` values, with data from `Message`. */
export type MessageGroupsByMessageParentMessageIdAndRecipientGroupIdManyToManyConnection = {
  __typename?: 'MessageGroupsByMessageParentMessageIdAndRecipientGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<MessageGroupsByMessageParentMessageIdAndRecipientGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Maybe<Group>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection, with data from `Message`. */
export type MessageGroupsByMessageParentMessageIdAndRecipientGroupIdManyToManyEdge = {
  __typename?: 'MessageGroupsByMessageParentMessageIdAndRecipientGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientGroupId: MessagesConnection;
  /** The `Group` at the end of the edge. */
  node?: Maybe<Group>;
};


/** A `Group` edge in the connection, with data from `Message`. */
export type MessageGroupsByMessageParentMessageIdAndRecipientGroupIdManyToManyEdgeMessagesByRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** An input for mutations affecting `Message` */
export type MessageInput = {
  body: Scalars['String'];
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  parentMessageId?: Maybe<Scalars['Int']>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  recipientId?: Maybe<Scalars['Int']>;
  senderId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `Message`. Fields that are set will be updated. */
export type MessagePatch = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  parentMessageId?: Maybe<Scalars['Int']>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  recipientId?: Maybe<Scalars['Int']>;
  senderId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

export type MessagePreview = Node & {
  __typename?: 'MessagePreview';
  createdAt: Scalars['Datetime'];
  /** Extension without leading dot */
  extension?: Maybe<Scalars['String']>;
  /** Basename without extension */
  filename: Scalars['String'];
  id: Scalars['Int'];
  /** Reads a single `Message` that is related to this `MessagePreview`. */
  message?: Maybe<Message>;
  messageId: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `MessagePreview` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MessagePreviewCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `extension` field. */
  extension?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `MessagePreview` object types. All fields are combined with a logical ‘and.’ */
export type MessagePreviewFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MessagePreviewFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `extension` field. */
  extension?: Maybe<StringFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<MessagePreviewFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MessagePreviewFilter>>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `MessagePreview` */
export type MessagePreviewInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Extension without leading dot */
  extension?: Maybe<Scalars['String']>;
  /** Basename without extension */
  filename: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  messageId: Scalars['Int'];
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `MessagePreview`. Fields that are set will be updated. */
export type MessagePreviewPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Extension without leading dot */
  extension?: Maybe<Scalars['String']>;
  /** Basename without extension */
  filename?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  messageId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `MessagePreview` values. */
export type MessagePreviewsConnection = {
  __typename?: 'MessagePreviewsConnection';
  /** A list of edges which contains the `MessagePreview` and cursor to aid in pagination. */
  edges: Array<MessagePreviewsEdge>;
  /** A list of `MessagePreview` objects. */
  nodes: Array<Maybe<MessagePreview>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MessagePreview` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `MessagePreview` edge in the connection. */
export type MessagePreviewsEdge = {
  __typename?: 'MessagePreviewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `MessagePreview` at the end of the edge. */
  node?: Maybe<MessagePreview>;
};

/** Methods to use when ordering `MessagePreview`. */
export enum MessagePreviewsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExtensionAsc = 'EXTENSION_ASC',
  ExtensionDesc = 'EXTENSION_DESC',
  FilenameAsc = 'FILENAME_ASC',
  FilenameDesc = 'FILENAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MessageIdAsc = 'MESSAGE_ID_ASC',
  MessageIdDesc = 'MESSAGE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A connection to a list of `User` values, with data from `Message`. */
export type MessageUsersByMessageParentMessageIdAndRecipientIdManyToManyConnection = {
  __typename?: 'MessageUsersByMessageParentMessageIdAndRecipientIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<MessageUsersByMessageParentMessageIdAndRecipientIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Message`. */
export type MessageUsersByMessageParentMessageIdAndRecipientIdManyToManyEdge = {
  __typename?: 'MessageUsersByMessageParentMessageIdAndRecipientIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientId: MessagesConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Message`. */
export type MessageUsersByMessageParentMessageIdAndRecipientIdManyToManyEdgeMessagesByRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Message`. */
export type MessageUsersByMessageParentMessageIdAndSenderIdManyToManyConnection = {
  __typename?: 'MessageUsersByMessageParentMessageIdAndSenderIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<MessageUsersByMessageParentMessageIdAndSenderIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Message`. */
export type MessageUsersByMessageParentMessageIdAndSenderIdManyToManyEdge = {
  __typename?: 'MessageUsersByMessageParentMessageIdAndSenderIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesBySenderId: MessagesConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Message`. */
export type MessageUsersByMessageParentMessageIdAndSenderIdManyToManyEdgeMessagesBySenderIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `Message` values. */
export type MessagesConnection = {
  __typename?: 'MessagesConnection';
  /** A list of edges which contains the `Message` and cursor to aid in pagination. */
  edges: Array<MessagesEdge>;
  /** A list of `Message` objects. */
  nodes: Array<Maybe<Message>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Message` edge in the connection. */
export type MessagesEdge = {
  __typename?: 'MessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Message` at the end of the edge. */
  node?: Maybe<Message>;
};

/** Methods to use when ordering `Message`. */
export enum MessagesOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ParentMessageIdAsc = 'PARENT_MESSAGE_ID_ASC',
  ParentMessageIdDesc = 'PARENT_MESSAGE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientGroupIdAsc = 'RECIPIENT_GROUP_ID_ASC',
  RecipientGroupIdDesc = 'RECIPIENT_GROUP_ID_DESC',
  RecipientIdAsc = 'RECIPIENT_ID_ASC',
  RecipientIdDesc = 'RECIPIENT_ID_DESC',
  SenderIdAsc = 'SENDER_ID_ASC',
  SenderIdDesc = 'SENDER_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `ChineseGuessCharacterQuestion`. */
  createChineseGuessCharacterQuestion?: Maybe<CreateChineseGuessCharacterQuestionPayload>;
  /** Creates a single `ChineseRandomQuestion`. */
  createChineseRandomQuestion?: Maybe<CreateChineseRandomQuestionPayload>;
  /** Creates a single `ChineseWouldYouRatherQuestion`. */
  createChineseWouldYouRatherQuestion?: Maybe<CreateChineseWouldYouRatherQuestionPayload>;
  /** Creates a single `EnglishRandomQuestion`. */
  createEnglishRandomQuestion?: Maybe<CreateEnglishRandomQuestionPayload>;
  /** Creates a single `EnglishWord`. */
  createEnglishWord?: Maybe<CreateEnglishWordPayload>;
  /** Creates a single `EnglishWouldYouRatherQuestion`. */
  createEnglishWouldYouRatherQuestion?: Maybe<CreateEnglishWouldYouRatherQuestionPayload>;
  /** Creates a single `FrenchRandomQuestion`. */
  createFrenchRandomQuestion?: Maybe<CreateFrenchRandomQuestionPayload>;
  /** Creates a single `FrenchWord`. */
  createFrenchWord?: Maybe<CreateFrenchWordPayload>;
  /** Creates a single `FrenchWouldYouRatherQuestion`. */
  createFrenchWouldYouRatherQuestion?: Maybe<CreateFrenchWouldYouRatherQuestionPayload>;
  /** Creates a single `GermanRandomQuestion`. */
  createGermanRandomQuestion?: Maybe<CreateGermanRandomQuestionPayload>;
  /** Creates a single `GermanWord`. */
  createGermanWord?: Maybe<CreateGermanWordPayload>;
  /** Creates a single `GermanWouldYouRatherQuestion`. */
  createGermanWouldYouRatherQuestion?: Maybe<CreateGermanWouldYouRatherQuestionPayload>;
  /** Creates a single `Group`. */
  createGroup?: Maybe<CreateGroupPayload>;
  /** Creates a single `GroupUser`. */
  createGroupUser?: Maybe<CreateGroupUserPayload>;
  /** Creates a single `InviteToken`. */
  createInviteToken?: Maybe<CreateInviteTokenPayload>;
  /** Creates a single `ItalianRandomQuestion`. */
  createItalianRandomQuestion?: Maybe<CreateItalianRandomQuestionPayload>;
  /** Creates a single `ItalianWord`. */
  createItalianWord?: Maybe<CreateItalianWordPayload>;
  /** Creates a single `ItalianWouldYouRatherQuestion`. */
  createItalianWouldYouRatherQuestion?: Maybe<CreateItalianWouldYouRatherQuestionPayload>;
  /** Creates a single `JapaneseRandomQuestion`. */
  createJapaneseRandomQuestion?: Maybe<CreateJapaneseRandomQuestionPayload>;
  /** Creates a single `JapaneseWouldYouRatherQuestion`. */
  createJapaneseWouldYouRatherQuestion?: Maybe<CreateJapaneseWouldYouRatherQuestionPayload>;
  /** Creates a single `KoreanRandomQuestion`. */
  createKoreanRandomQuestion?: Maybe<CreateKoreanRandomQuestionPayload>;
  /** Creates a single `KoreanWouldYouRatherQuestion`. */
  createKoreanWouldYouRatherQuestion?: Maybe<CreateKoreanWouldYouRatherQuestionPayload>;
  /** Creates a single `Language`. */
  createLanguage?: Maybe<CreateLanguagePayload>;
  /** Creates a single `LanguageSkillLevel`. */
  createLanguageSkillLevel?: Maybe<CreateLanguageSkillLevelPayload>;
  /** Creates a single `Message`. */
  createMessage?: Maybe<CreateMessagePayload>;
  /** Creates a single `MessagePreview`. */
  createMessagePreview?: Maybe<CreateMessagePreviewPayload>;
  /** Creates a single `Notification`. */
  createNotification?: Maybe<CreateNotificationPayload>;
  /** Creates a single `NotificationChannel`. */
  createNotificationChannel?: Maybe<CreateNotificationChannelPayload>;
  /** Creates a single `PortugueseRandomQuestion`. */
  createPortugueseRandomQuestion?: Maybe<CreatePortugueseRandomQuestionPayload>;
  /** Creates a single `PortugueseWord`. */
  createPortugueseWord?: Maybe<CreatePortugueseWordPayload>;
  /** Creates a single `PortugueseWouldYouRatherQuestion`. */
  createPortugueseWouldYouRatherQuestion?: Maybe<CreatePortugueseWouldYouRatherQuestionPayload>;
  /** Creates a single `Post`. */
  createPost?: Maybe<CreatePostPayload>;
  /** Creates a single `PostCorrection`. */
  createPostCorrection?: Maybe<CreatePostCorrectionPayload>;
  /** Creates a single `PostGame`. */
  createPostGame?: Maybe<CreatePostGamePayload>;
  /** Creates a single `PostGameAnswer`. */
  createPostGameAnswer?: Maybe<CreatePostGameAnswerPayload>;
  /** Creates a single `PostGameRange`. */
  createPostGameRange?: Maybe<CreatePostGameRangePayload>;
  /** Creates a single `PostLike`. */
  createPostLike?: Maybe<CreatePostLikePayload>;
  /** Creates a single `PostRecording`. */
  createPostRecording?: Maybe<CreatePostRecordingPayload>;
  /** Creates a single `PostUserMention`. */
  createPostUserMention?: Maybe<CreatePostUserMentionPayload>;
  /** Creates a single `Prompt`. */
  createPrompt?: Maybe<CreatePromptPayload>;
  /** Creates a single `RussianRandomQuestion`. */
  createRussianRandomQuestion?: Maybe<CreateRussianRandomQuestionPayload>;
  /** Creates a single `RussianWord`. */
  createRussianWord?: Maybe<CreateRussianWordPayload>;
  /** Creates a single `RussianWouldYouRatherQuestion`. */
  createRussianWouldYouRatherQuestion?: Maybe<CreateRussianWouldYouRatherQuestionPayload>;
  /** Creates a single `SpanishRandomQuestion`. */
  createSpanishRandomQuestion?: Maybe<CreateSpanishRandomQuestionPayload>;
  /** Creates a single `SpanishWord`. */
  createSpanishWord?: Maybe<CreateSpanishWordPayload>;
  /** Creates a single `SpanishWouldYouRatherQuestion`. */
  createSpanishWouldYouRatherQuestion?: Maybe<CreateSpanishWouldYouRatherQuestionPayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserDevice`. */
  createUserDevice?: Maybe<CreateUserDevicePayload>;
  /** Creates a single `UserFollower`. */
  createUserFollower?: Maybe<CreateUserFollowerPayload>;
  /** Creates a single `UserLanguage`. */
  createUserLanguage?: Maybe<CreateUserLanguagePayload>;
  /** Creates a single `UserPreference`. */
  createUserPreference?: Maybe<CreateUserPreferencePayload>;
  /** Creates a single `UserSession`. */
  createUserSession?: Maybe<CreateUserSessionPayload>;
  /** Deletes a single `ChineseGuessCharacterQuestion` using a unique key. */
  deleteChineseGuessCharacterQuestion?: Maybe<DeleteChineseGuessCharacterQuestionPayload>;
  /** Deletes a single `ChineseGuessCharacterQuestion` using its globally unique id. */
  deleteChineseGuessCharacterQuestionByNodeId?: Maybe<DeleteChineseGuessCharacterQuestionPayload>;
  /** Deletes a single `ChineseGuessCharacterQuestion` using a unique key. */
  deleteChineseGuessCharacterQuestionByUuid?: Maybe<DeleteChineseGuessCharacterQuestionPayload>;
  /** Deletes a single `ChineseRandomQuestion` using a unique key. */
  deleteChineseRandomQuestion?: Maybe<DeleteChineseRandomQuestionPayload>;
  /** Deletes a single `ChineseRandomQuestion` using its globally unique id. */
  deleteChineseRandomQuestionByNodeId?: Maybe<DeleteChineseRandomQuestionPayload>;
  /** Deletes a single `ChineseRandomQuestion` using a unique key. */
  deleteChineseRandomQuestionByUuid?: Maybe<DeleteChineseRandomQuestionPayload>;
  /** Deletes a single `ChineseWouldYouRatherQuestion` using a unique key. */
  deleteChineseWouldYouRatherQuestion?: Maybe<DeleteChineseWouldYouRatherQuestionPayload>;
  /** Deletes a single `ChineseWouldYouRatherQuestion` using its globally unique id. */
  deleteChineseWouldYouRatherQuestionByNodeId?: Maybe<DeleteChineseWouldYouRatherQuestionPayload>;
  /** Deletes a single `ChineseWouldYouRatherQuestion` using a unique key. */
  deleteChineseWouldYouRatherQuestionByUuid?: Maybe<DeleteChineseWouldYouRatherQuestionPayload>;
  /** Deletes a single `EnglishRandomQuestion` using a unique key. */
  deleteEnglishRandomQuestion?: Maybe<DeleteEnglishRandomQuestionPayload>;
  /** Deletes a single `EnglishRandomQuestion` using its globally unique id. */
  deleteEnglishRandomQuestionByNodeId?: Maybe<DeleteEnglishRandomQuestionPayload>;
  /** Deletes a single `EnglishRandomQuestion` using a unique key. */
  deleteEnglishRandomQuestionByUuid?: Maybe<DeleteEnglishRandomQuestionPayload>;
  /** Deletes a single `EnglishWord` using a unique key. */
  deleteEnglishWord?: Maybe<DeleteEnglishWordPayload>;
  /** Deletes a single `EnglishWord` using its globally unique id. */
  deleteEnglishWordByNodeId?: Maybe<DeleteEnglishWordPayload>;
  /** Deletes a single `EnglishWord` using a unique key. */
  deleteEnglishWordByUuid?: Maybe<DeleteEnglishWordPayload>;
  /** Deletes a single `EnglishWouldYouRatherQuestion` using a unique key. */
  deleteEnglishWouldYouRatherQuestion?: Maybe<DeleteEnglishWouldYouRatherQuestionPayload>;
  /** Deletes a single `EnglishWouldYouRatherQuestion` using its globally unique id. */
  deleteEnglishWouldYouRatherQuestionByNodeId?: Maybe<DeleteEnglishWouldYouRatherQuestionPayload>;
  /** Deletes a single `EnglishWouldYouRatherQuestion` using a unique key. */
  deleteEnglishWouldYouRatherQuestionByUuid?: Maybe<DeleteEnglishWouldYouRatherQuestionPayload>;
  /** Deletes a single `FrenchRandomQuestion` using a unique key. */
  deleteFrenchRandomQuestion?: Maybe<DeleteFrenchRandomQuestionPayload>;
  /** Deletes a single `FrenchRandomQuestion` using its globally unique id. */
  deleteFrenchRandomQuestionByNodeId?: Maybe<DeleteFrenchRandomQuestionPayload>;
  /** Deletes a single `FrenchRandomQuestion` using a unique key. */
  deleteFrenchRandomQuestionByUuid?: Maybe<DeleteFrenchRandomQuestionPayload>;
  /** Deletes a single `FrenchWord` using a unique key. */
  deleteFrenchWord?: Maybe<DeleteFrenchWordPayload>;
  /** Deletes a single `FrenchWord` using its globally unique id. */
  deleteFrenchWordByNodeId?: Maybe<DeleteFrenchWordPayload>;
  /** Deletes a single `FrenchWord` using a unique key. */
  deleteFrenchWordByUuid?: Maybe<DeleteFrenchWordPayload>;
  /** Deletes a single `FrenchWouldYouRatherQuestion` using a unique key. */
  deleteFrenchWouldYouRatherQuestion?: Maybe<DeleteFrenchWouldYouRatherQuestionPayload>;
  /** Deletes a single `FrenchWouldYouRatherQuestion` using its globally unique id. */
  deleteFrenchWouldYouRatherQuestionByNodeId?: Maybe<DeleteFrenchWouldYouRatherQuestionPayload>;
  /** Deletes a single `FrenchWouldYouRatherQuestion` using a unique key. */
  deleteFrenchWouldYouRatherQuestionByUuid?: Maybe<DeleteFrenchWouldYouRatherQuestionPayload>;
  /** Deletes a single `GermanRandomQuestion` using a unique key. */
  deleteGermanRandomQuestion?: Maybe<DeleteGermanRandomQuestionPayload>;
  /** Deletes a single `GermanRandomQuestion` using its globally unique id. */
  deleteGermanRandomQuestionByNodeId?: Maybe<DeleteGermanRandomQuestionPayload>;
  /** Deletes a single `GermanRandomQuestion` using a unique key. */
  deleteGermanRandomQuestionByUuid?: Maybe<DeleteGermanRandomQuestionPayload>;
  /** Deletes a single `GermanWord` using a unique key. */
  deleteGermanWord?: Maybe<DeleteGermanWordPayload>;
  /** Deletes a single `GermanWord` using its globally unique id. */
  deleteGermanWordByNodeId?: Maybe<DeleteGermanWordPayload>;
  /** Deletes a single `GermanWord` using a unique key. */
  deleteGermanWordByUuid?: Maybe<DeleteGermanWordPayload>;
  /** Deletes a single `GermanWouldYouRatherQuestion` using a unique key. */
  deleteGermanWouldYouRatherQuestion?: Maybe<DeleteGermanWouldYouRatherQuestionPayload>;
  /** Deletes a single `GermanWouldYouRatherQuestion` using its globally unique id. */
  deleteGermanWouldYouRatherQuestionByNodeId?: Maybe<DeleteGermanWouldYouRatherQuestionPayload>;
  /** Deletes a single `GermanWouldYouRatherQuestion` using a unique key. */
  deleteGermanWouldYouRatherQuestionByUuid?: Maybe<DeleteGermanWouldYouRatherQuestionPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup?: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using its globally unique id. */
  deleteGroupByNodeId?: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroupByUuid?: Maybe<DeleteGroupPayload>;
  /** Deletes a single `GroupUser` using a unique key. */
  deleteGroupUser?: Maybe<DeleteGroupUserPayload>;
  /** Deletes a single `GroupUser` using its globally unique id. */
  deleteGroupUserByNodeId?: Maybe<DeleteGroupUserPayload>;
  /** Deletes a single `InviteToken` using a unique key. */
  deleteInviteToken?: Maybe<DeleteInviteTokenPayload>;
  /** Deletes a single `InviteToken` using its globally unique id. */
  deleteInviteTokenByNodeId?: Maybe<DeleteInviteTokenPayload>;
  /** Deletes a single `ItalianRandomQuestion` using a unique key. */
  deleteItalianRandomQuestion?: Maybe<DeleteItalianRandomQuestionPayload>;
  /** Deletes a single `ItalianRandomQuestion` using its globally unique id. */
  deleteItalianRandomQuestionByNodeId?: Maybe<DeleteItalianRandomQuestionPayload>;
  /** Deletes a single `ItalianRandomQuestion` using a unique key. */
  deleteItalianRandomQuestionByUuid?: Maybe<DeleteItalianRandomQuestionPayload>;
  /** Deletes a single `ItalianWord` using a unique key. */
  deleteItalianWord?: Maybe<DeleteItalianWordPayload>;
  /** Deletes a single `ItalianWord` using its globally unique id. */
  deleteItalianWordByNodeId?: Maybe<DeleteItalianWordPayload>;
  /** Deletes a single `ItalianWord` using a unique key. */
  deleteItalianWordByUuid?: Maybe<DeleteItalianWordPayload>;
  /** Deletes a single `ItalianWouldYouRatherQuestion` using a unique key. */
  deleteItalianWouldYouRatherQuestion?: Maybe<DeleteItalianWouldYouRatherQuestionPayload>;
  /** Deletes a single `ItalianWouldYouRatherQuestion` using its globally unique id. */
  deleteItalianWouldYouRatherQuestionByNodeId?: Maybe<DeleteItalianWouldYouRatherQuestionPayload>;
  /** Deletes a single `ItalianWouldYouRatherQuestion` using a unique key. */
  deleteItalianWouldYouRatherQuestionByUuid?: Maybe<DeleteItalianWouldYouRatherQuestionPayload>;
  /** Deletes a single `JapaneseRandomQuestion` using a unique key. */
  deleteJapaneseRandomQuestion?: Maybe<DeleteJapaneseRandomQuestionPayload>;
  /** Deletes a single `JapaneseRandomQuestion` using its globally unique id. */
  deleteJapaneseRandomQuestionByNodeId?: Maybe<DeleteJapaneseRandomQuestionPayload>;
  /** Deletes a single `JapaneseRandomQuestion` using a unique key. */
  deleteJapaneseRandomQuestionByUuid?: Maybe<DeleteJapaneseRandomQuestionPayload>;
  /** Deletes a single `JapaneseWouldYouRatherQuestion` using a unique key. */
  deleteJapaneseWouldYouRatherQuestion?: Maybe<DeleteJapaneseWouldYouRatherQuestionPayload>;
  /** Deletes a single `JapaneseWouldYouRatherQuestion` using its globally unique id. */
  deleteJapaneseWouldYouRatherQuestionByNodeId?: Maybe<DeleteJapaneseWouldYouRatherQuestionPayload>;
  /** Deletes a single `JapaneseWouldYouRatherQuestion` using a unique key. */
  deleteJapaneseWouldYouRatherQuestionByUuid?: Maybe<DeleteJapaneseWouldYouRatherQuestionPayload>;
  /** Deletes a single `KoreanRandomQuestion` using a unique key. */
  deleteKoreanRandomQuestion?: Maybe<DeleteKoreanRandomQuestionPayload>;
  /** Deletes a single `KoreanRandomQuestion` using its globally unique id. */
  deleteKoreanRandomQuestionByNodeId?: Maybe<DeleteKoreanRandomQuestionPayload>;
  /** Deletes a single `KoreanRandomQuestion` using a unique key. */
  deleteKoreanRandomQuestionByUuid?: Maybe<DeleteKoreanRandomQuestionPayload>;
  /** Deletes a single `KoreanWouldYouRatherQuestion` using a unique key. */
  deleteKoreanWouldYouRatherQuestion?: Maybe<DeleteKoreanWouldYouRatherQuestionPayload>;
  /** Deletes a single `KoreanWouldYouRatherQuestion` using its globally unique id. */
  deleteKoreanWouldYouRatherQuestionByNodeId?: Maybe<DeleteKoreanWouldYouRatherQuestionPayload>;
  /** Deletes a single `KoreanWouldYouRatherQuestion` using a unique key. */
  deleteKoreanWouldYouRatherQuestionByUuid?: Maybe<DeleteKoreanWouldYouRatherQuestionPayload>;
  /** Deletes a single `Language` using a unique key. */
  deleteLanguage?: Maybe<DeleteLanguagePayload>;
  /** Deletes a single `Language` using a unique key. */
  deleteLanguageByAlpha2?: Maybe<DeleteLanguagePayload>;
  /** Deletes a single `Language` using a unique key. */
  deleteLanguageByEnglishName?: Maybe<DeleteLanguagePayload>;
  /** Deletes a single `Language` using its globally unique id. */
  deleteLanguageByNodeId?: Maybe<DeleteLanguagePayload>;
  /** Deletes a single `LanguageSkillLevel` using a unique key. */
  deleteLanguageSkillLevel?: Maybe<DeleteLanguageSkillLevelPayload>;
  /** Deletes a single `LanguageSkillLevel` using its globally unique id. */
  deleteLanguageSkillLevelByNodeId?: Maybe<DeleteLanguageSkillLevelPayload>;
  /** Deletes a single `Message` using a unique key. */
  deleteMessage?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Message` using its globally unique id. */
  deleteMessageByNodeId?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Message` using a unique key. */
  deleteMessageByUuid?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `MessagePreview` using a unique key. */
  deleteMessagePreview?: Maybe<DeleteMessagePreviewPayload>;
  /** Deletes a single `MessagePreview` using its globally unique id. */
  deleteMessagePreviewByNodeId?: Maybe<DeleteMessagePreviewPayload>;
  /** Deletes a single `MessagePreview` using a unique key. */
  deleteMessagePreviewByUuid?: Maybe<DeleteMessagePreviewPayload>;
  /** Deletes a single `Notification` using a unique key. */
  deleteNotification?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Notification` using its globally unique id. */
  deleteNotificationByNodeId?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Notification` using a unique key. */
  deleteNotificationByUuid?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `NotificationChannel` using a unique key. */
  deleteNotificationChannel?: Maybe<DeleteNotificationChannelPayload>;
  /** Deletes a single `NotificationChannel` using a unique key. */
  deleteNotificationChannelByName?: Maybe<DeleteNotificationChannelPayload>;
  /** Deletes a single `NotificationChannel` using its globally unique id. */
  deleteNotificationChannelByNodeId?: Maybe<DeleteNotificationChannelPayload>;
  /** Deletes a single `NotificationChannel` using a unique key. */
  deleteNotificationChannelByUuid?: Maybe<DeleteNotificationChannelPayload>;
  /** Deletes a single `PortugueseRandomQuestion` using a unique key. */
  deletePortugueseRandomQuestion?: Maybe<DeletePortugueseRandomQuestionPayload>;
  /** Deletes a single `PortugueseRandomQuestion` using its globally unique id. */
  deletePortugueseRandomQuestionByNodeId?: Maybe<DeletePortugueseRandomQuestionPayload>;
  /** Deletes a single `PortugueseRandomQuestion` using a unique key. */
  deletePortugueseRandomQuestionByUuid?: Maybe<DeletePortugueseRandomQuestionPayload>;
  /** Deletes a single `PortugueseWord` using a unique key. */
  deletePortugueseWord?: Maybe<DeletePortugueseWordPayload>;
  /** Deletes a single `PortugueseWord` using its globally unique id. */
  deletePortugueseWordByNodeId?: Maybe<DeletePortugueseWordPayload>;
  /** Deletes a single `PortugueseWord` using a unique key. */
  deletePortugueseWordByUuid?: Maybe<DeletePortugueseWordPayload>;
  /** Deletes a single `PortugueseWouldYouRatherQuestion` using a unique key. */
  deletePortugueseWouldYouRatherQuestion?: Maybe<DeletePortugueseWouldYouRatherQuestionPayload>;
  /** Deletes a single `PortugueseWouldYouRatherQuestion` using its globally unique id. */
  deletePortugueseWouldYouRatherQuestionByNodeId?: Maybe<DeletePortugueseWouldYouRatherQuestionPayload>;
  /** Deletes a single `PortugueseWouldYouRatherQuestion` using a unique key. */
  deletePortugueseWouldYouRatherQuestionByUuid?: Maybe<DeletePortugueseWouldYouRatherQuestionPayload>;
  /** Deletes a single `Post` using a unique key. */
  deletePost?: Maybe<DeletePostPayload>;
  /** Deletes a single `Post` using its globally unique id. */
  deletePostByNodeId?: Maybe<DeletePostPayload>;
  /** Deletes a single `Post` using a unique key. */
  deletePostBySnowflakeId?: Maybe<DeletePostPayload>;
  /** Deletes a single `Post` using a unique key. */
  deletePostByUuid?: Maybe<DeletePostPayload>;
  /** Deletes a single `PostCorrection` using a unique key. */
  deletePostCorrection?: Maybe<DeletePostCorrectionPayload>;
  /** Deletes a single `PostCorrection` using its globally unique id. */
  deletePostCorrectionByNodeId?: Maybe<DeletePostCorrectionPayload>;
  /** Deletes a single `PostCorrection` using a unique key. */
  deletePostCorrectionByUuid?: Maybe<DeletePostCorrectionPayload>;
  /** Deletes a single `PostGame` using a unique key. */
  deletePostGame?: Maybe<DeletePostGamePayload>;
  /** Deletes a single `PostGameAnswer` using a unique key. */
  deletePostGameAnswer?: Maybe<DeletePostGameAnswerPayload>;
  /** Deletes a single `PostGameAnswer` using its globally unique id. */
  deletePostGameAnswerByNodeId?: Maybe<DeletePostGameAnswerPayload>;
  /** Deletes a single `PostGameAnswer` using a unique key. */
  deletePostGameAnswerByUuid?: Maybe<DeletePostGameAnswerPayload>;
  /** Deletes a single `PostGame` using its globally unique id. */
  deletePostGameByNodeId?: Maybe<DeletePostGamePayload>;
  /** Deletes a single `PostGame` using a unique key. */
  deletePostGameByUuid?: Maybe<DeletePostGamePayload>;
  /** Deletes a single `PostGameRange` using a unique key. */
  deletePostGameRange?: Maybe<DeletePostGameRangePayload>;
  /** Deletes a single `PostGameRange` using its globally unique id. */
  deletePostGameRangeByNodeId?: Maybe<DeletePostGameRangePayload>;
  /** Deletes a single `PostGameRange` using a unique key. */
  deletePostGameRangeByUuid?: Maybe<DeletePostGameRangePayload>;
  /** Deletes a single `PostLike` using a unique key. */
  deletePostLike?: Maybe<DeletePostLikePayload>;
  /** Deletes a single `PostLike` using its globally unique id. */
  deletePostLikeByNodeId?: Maybe<DeletePostLikePayload>;
  /** Deletes a single `PostRecording` using a unique key. */
  deletePostRecording?: Maybe<DeletePostRecordingPayload>;
  /** Deletes a single `PostRecording` using its globally unique id. */
  deletePostRecordingByNodeId?: Maybe<DeletePostRecordingPayload>;
  /** Deletes a single `PostRecording` using a unique key. */
  deletePostRecordingByUuid?: Maybe<DeletePostRecordingPayload>;
  /** Deletes a single `PostUserMention` using a unique key. */
  deletePostUserMention?: Maybe<DeletePostUserMentionPayload>;
  /** Deletes a single `PostUserMention` using its globally unique id. */
  deletePostUserMentionByNodeId?: Maybe<DeletePostUserMentionPayload>;
  /** Deletes a single `PostUserMention` using a unique key. */
  deletePostUserMentionByUuid?: Maybe<DeletePostUserMentionPayload>;
  /** Deletes a single `Prompt` using a unique key. */
  deletePrompt?: Maybe<DeletePromptPayload>;
  /** Deletes a single `Prompt` using its globally unique id. */
  deletePromptByNodeId?: Maybe<DeletePromptPayload>;
  /** Deletes a single `Prompt` using a unique key. */
  deletePromptByUuid?: Maybe<DeletePromptPayload>;
  /** Deletes a single `RussianRandomQuestion` using a unique key. */
  deleteRussianRandomQuestion?: Maybe<DeleteRussianRandomQuestionPayload>;
  /** Deletes a single `RussianRandomQuestion` using its globally unique id. */
  deleteRussianRandomQuestionByNodeId?: Maybe<DeleteRussianRandomQuestionPayload>;
  /** Deletes a single `RussianRandomQuestion` using a unique key. */
  deleteRussianRandomQuestionByUuid?: Maybe<DeleteRussianRandomQuestionPayload>;
  /** Deletes a single `RussianWord` using a unique key. */
  deleteRussianWord?: Maybe<DeleteRussianWordPayload>;
  /** Deletes a single `RussianWord` using its globally unique id. */
  deleteRussianWordByNodeId?: Maybe<DeleteRussianWordPayload>;
  /** Deletes a single `RussianWord` using a unique key. */
  deleteRussianWordByUuid?: Maybe<DeleteRussianWordPayload>;
  /** Deletes a single `RussianWouldYouRatherQuestion` using a unique key. */
  deleteRussianWouldYouRatherQuestion?: Maybe<DeleteRussianWouldYouRatherQuestionPayload>;
  /** Deletes a single `RussianWouldYouRatherQuestion` using its globally unique id. */
  deleteRussianWouldYouRatherQuestionByNodeId?: Maybe<DeleteRussianWouldYouRatherQuestionPayload>;
  /** Deletes a single `RussianWouldYouRatherQuestion` using a unique key. */
  deleteRussianWouldYouRatherQuestionByUuid?: Maybe<DeleteRussianWouldYouRatherQuestionPayload>;
  /** Deletes a single `SpanishRandomQuestion` using a unique key. */
  deleteSpanishRandomQuestion?: Maybe<DeleteSpanishRandomQuestionPayload>;
  /** Deletes a single `SpanishRandomQuestion` using its globally unique id. */
  deleteSpanishRandomQuestionByNodeId?: Maybe<DeleteSpanishRandomQuestionPayload>;
  /** Deletes a single `SpanishRandomQuestion` using a unique key. */
  deleteSpanishRandomQuestionByUuid?: Maybe<DeleteSpanishRandomQuestionPayload>;
  /** Deletes a single `SpanishWord` using a unique key. */
  deleteSpanishWord?: Maybe<DeleteSpanishWordPayload>;
  /** Deletes a single `SpanishWord` using its globally unique id. */
  deleteSpanishWordByNodeId?: Maybe<DeleteSpanishWordPayload>;
  /** Deletes a single `SpanishWord` using a unique key. */
  deleteSpanishWordByUuid?: Maybe<DeleteSpanishWordPayload>;
  /** Deletes a single `SpanishWouldYouRatherQuestion` using a unique key. */
  deleteSpanishWouldYouRatherQuestion?: Maybe<DeleteSpanishWouldYouRatherQuestionPayload>;
  /** Deletes a single `SpanishWouldYouRatherQuestion` using its globally unique id. */
  deleteSpanishWouldYouRatherQuestionByNodeId?: Maybe<DeleteSpanishWouldYouRatherQuestionPayload>;
  /** Deletes a single `SpanishWouldYouRatherQuestion` using a unique key. */
  deleteSpanishWouldYouRatherQuestionByUuid?: Maybe<DeleteSpanishWouldYouRatherQuestionPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByEmail?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByEmailUnsubscribeToken?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByResetPasswordToken?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByUsername?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByUuid?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserDevice` using a unique key. */
  deleteUserDevice?: Maybe<DeleteUserDevicePayload>;
  /** Deletes a single `UserDevice` using a unique key. */
  deleteUserDeviceByFcmToken?: Maybe<DeleteUserDevicePayload>;
  /** Deletes a single `UserDevice` using its globally unique id. */
  deleteUserDeviceByNodeId?: Maybe<DeleteUserDevicePayload>;
  /** Deletes a single `UserDevice` using a unique key. */
  deleteUserDeviceByUuid?: Maybe<DeleteUserDevicePayload>;
  /** Deletes a single `UserFollower` using a unique key. */
  deleteUserFollower?: Maybe<DeleteUserFollowerPayload>;
  /** Deletes a single `UserFollower` using its globally unique id. */
  deleteUserFollowerByNodeId?: Maybe<DeleteUserFollowerPayload>;
  /** Deletes a single `UserLanguage` using a unique key. */
  deleteUserLanguage?: Maybe<DeleteUserLanguagePayload>;
  /** Deletes a single `UserLanguage` using its globally unique id. */
  deleteUserLanguageByNodeId?: Maybe<DeleteUserLanguagePayload>;
  /** Deletes a single `UserPreference` using a unique key. */
  deleteUserPreference?: Maybe<DeleteUserPreferencePayload>;
  /** Deletes a single `UserPreference` using its globally unique id. */
  deleteUserPreferenceByNodeId?: Maybe<DeleteUserPreferencePayload>;
  /** Deletes a single `UserPreference` using a unique key. */
  deleteUserPreferenceByUserId?: Maybe<DeleteUserPreferencePayload>;
  /** Deletes a single `UserSession` using a unique key. */
  deleteUserSession?: Maybe<DeleteUserSessionPayload>;
  /** Deletes a single `UserSession` using its globally unique id. */
  deleteUserSessionByNodeId?: Maybe<DeleteUserSessionPayload>;
  generateSnowflakeId?: Maybe<GenerateSnowflakeIdPayload>;
  joinGlobalGroup?: Maybe<JoinGlobalGroupPayload>;
  registerUserActivity?: Maybe<RegisterUserActivityPayload>;
  /** Updates a single `ChineseGuessCharacterQuestion` using a unique key and a patch. */
  updateChineseGuessCharacterQuestion?: Maybe<UpdateChineseGuessCharacterQuestionPayload>;
  /** Updates a single `ChineseGuessCharacterQuestion` using its globally unique id and a patch. */
  updateChineseGuessCharacterQuestionByNodeId?: Maybe<UpdateChineseGuessCharacterQuestionPayload>;
  /** Updates a single `ChineseGuessCharacterQuestion` using a unique key and a patch. */
  updateChineseGuessCharacterQuestionByUuid?: Maybe<UpdateChineseGuessCharacterQuestionPayload>;
  /** Updates a single `ChineseRandomQuestion` using a unique key and a patch. */
  updateChineseRandomQuestion?: Maybe<UpdateChineseRandomQuestionPayload>;
  /** Updates a single `ChineseRandomQuestion` using its globally unique id and a patch. */
  updateChineseRandomQuestionByNodeId?: Maybe<UpdateChineseRandomQuestionPayload>;
  /** Updates a single `ChineseRandomQuestion` using a unique key and a patch. */
  updateChineseRandomQuestionByUuid?: Maybe<UpdateChineseRandomQuestionPayload>;
  /** Updates a single `ChineseWouldYouRatherQuestion` using a unique key and a patch. */
  updateChineseWouldYouRatherQuestion?: Maybe<UpdateChineseWouldYouRatherQuestionPayload>;
  /** Updates a single `ChineseWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateChineseWouldYouRatherQuestionByNodeId?: Maybe<UpdateChineseWouldYouRatherQuestionPayload>;
  /** Updates a single `ChineseWouldYouRatherQuestion` using a unique key and a patch. */
  updateChineseWouldYouRatherQuestionByUuid?: Maybe<UpdateChineseWouldYouRatherQuestionPayload>;
  /** Updates a single `EnglishRandomQuestion` using a unique key and a patch. */
  updateEnglishRandomQuestion?: Maybe<UpdateEnglishRandomQuestionPayload>;
  /** Updates a single `EnglishRandomQuestion` using its globally unique id and a patch. */
  updateEnglishRandomQuestionByNodeId?: Maybe<UpdateEnglishRandomQuestionPayload>;
  /** Updates a single `EnglishRandomQuestion` using a unique key and a patch. */
  updateEnglishRandomQuestionByUuid?: Maybe<UpdateEnglishRandomQuestionPayload>;
  /** Updates a single `EnglishWord` using a unique key and a patch. */
  updateEnglishWord?: Maybe<UpdateEnglishWordPayload>;
  /** Updates a single `EnglishWord` using its globally unique id and a patch. */
  updateEnglishWordByNodeId?: Maybe<UpdateEnglishWordPayload>;
  /** Updates a single `EnglishWord` using a unique key and a patch. */
  updateEnglishWordByUuid?: Maybe<UpdateEnglishWordPayload>;
  /** Updates a single `EnglishWouldYouRatherQuestion` using a unique key and a patch. */
  updateEnglishWouldYouRatherQuestion?: Maybe<UpdateEnglishWouldYouRatherQuestionPayload>;
  /** Updates a single `EnglishWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateEnglishWouldYouRatherQuestionByNodeId?: Maybe<UpdateEnglishWouldYouRatherQuestionPayload>;
  /** Updates a single `EnglishWouldYouRatherQuestion` using a unique key and a patch. */
  updateEnglishWouldYouRatherQuestionByUuid?: Maybe<UpdateEnglishWouldYouRatherQuestionPayload>;
  /** Updates a single `FrenchRandomQuestion` using a unique key and a patch. */
  updateFrenchRandomQuestion?: Maybe<UpdateFrenchRandomQuestionPayload>;
  /** Updates a single `FrenchRandomQuestion` using its globally unique id and a patch. */
  updateFrenchRandomQuestionByNodeId?: Maybe<UpdateFrenchRandomQuestionPayload>;
  /** Updates a single `FrenchRandomQuestion` using a unique key and a patch. */
  updateFrenchRandomQuestionByUuid?: Maybe<UpdateFrenchRandomQuestionPayload>;
  /** Updates a single `FrenchWord` using a unique key and a patch. */
  updateFrenchWord?: Maybe<UpdateFrenchWordPayload>;
  /** Updates a single `FrenchWord` using its globally unique id and a patch. */
  updateFrenchWordByNodeId?: Maybe<UpdateFrenchWordPayload>;
  /** Updates a single `FrenchWord` using a unique key and a patch. */
  updateFrenchWordByUuid?: Maybe<UpdateFrenchWordPayload>;
  /** Updates a single `FrenchWouldYouRatherQuestion` using a unique key and a patch. */
  updateFrenchWouldYouRatherQuestion?: Maybe<UpdateFrenchWouldYouRatherQuestionPayload>;
  /** Updates a single `FrenchWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateFrenchWouldYouRatherQuestionByNodeId?: Maybe<UpdateFrenchWouldYouRatherQuestionPayload>;
  /** Updates a single `FrenchWouldYouRatherQuestion` using a unique key and a patch. */
  updateFrenchWouldYouRatherQuestionByUuid?: Maybe<UpdateFrenchWouldYouRatherQuestionPayload>;
  /** Updates a single `GermanRandomQuestion` using a unique key and a patch. */
  updateGermanRandomQuestion?: Maybe<UpdateGermanRandomQuestionPayload>;
  /** Updates a single `GermanRandomQuestion` using its globally unique id and a patch. */
  updateGermanRandomQuestionByNodeId?: Maybe<UpdateGermanRandomQuestionPayload>;
  /** Updates a single `GermanRandomQuestion` using a unique key and a patch. */
  updateGermanRandomQuestionByUuid?: Maybe<UpdateGermanRandomQuestionPayload>;
  /** Updates a single `GermanWord` using a unique key and a patch. */
  updateGermanWord?: Maybe<UpdateGermanWordPayload>;
  /** Updates a single `GermanWord` using its globally unique id and a patch. */
  updateGermanWordByNodeId?: Maybe<UpdateGermanWordPayload>;
  /** Updates a single `GermanWord` using a unique key and a patch. */
  updateGermanWordByUuid?: Maybe<UpdateGermanWordPayload>;
  /** Updates a single `GermanWouldYouRatherQuestion` using a unique key and a patch. */
  updateGermanWouldYouRatherQuestion?: Maybe<UpdateGermanWouldYouRatherQuestionPayload>;
  /** Updates a single `GermanWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateGermanWouldYouRatherQuestionByNodeId?: Maybe<UpdateGermanWouldYouRatherQuestionPayload>;
  /** Updates a single `GermanWouldYouRatherQuestion` using a unique key and a patch. */
  updateGermanWouldYouRatherQuestionByUuid?: Maybe<UpdateGermanWouldYouRatherQuestionPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup?: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using its globally unique id and a patch. */
  updateGroupByNodeId?: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroupByUuid?: Maybe<UpdateGroupPayload>;
  /** Updates a single `GroupUser` using a unique key and a patch. */
  updateGroupUser?: Maybe<UpdateGroupUserPayload>;
  /** Updates a single `GroupUser` using its globally unique id and a patch. */
  updateGroupUserByNodeId?: Maybe<UpdateGroupUserPayload>;
  /** Updates a single `InviteToken` using a unique key and a patch. */
  updateInviteToken?: Maybe<UpdateInviteTokenPayload>;
  /** Updates a single `InviteToken` using its globally unique id and a patch. */
  updateInviteTokenByNodeId?: Maybe<UpdateInviteTokenPayload>;
  /** Updates a single `ItalianRandomQuestion` using a unique key and a patch. */
  updateItalianRandomQuestion?: Maybe<UpdateItalianRandomQuestionPayload>;
  /** Updates a single `ItalianRandomQuestion` using its globally unique id and a patch. */
  updateItalianRandomQuestionByNodeId?: Maybe<UpdateItalianRandomQuestionPayload>;
  /** Updates a single `ItalianRandomQuestion` using a unique key and a patch. */
  updateItalianRandomQuestionByUuid?: Maybe<UpdateItalianRandomQuestionPayload>;
  /** Updates a single `ItalianWord` using a unique key and a patch. */
  updateItalianWord?: Maybe<UpdateItalianWordPayload>;
  /** Updates a single `ItalianWord` using its globally unique id and a patch. */
  updateItalianWordByNodeId?: Maybe<UpdateItalianWordPayload>;
  /** Updates a single `ItalianWord` using a unique key and a patch. */
  updateItalianWordByUuid?: Maybe<UpdateItalianWordPayload>;
  /** Updates a single `ItalianWouldYouRatherQuestion` using a unique key and a patch. */
  updateItalianWouldYouRatherQuestion?: Maybe<UpdateItalianWouldYouRatherQuestionPayload>;
  /** Updates a single `ItalianWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateItalianWouldYouRatherQuestionByNodeId?: Maybe<UpdateItalianWouldYouRatherQuestionPayload>;
  /** Updates a single `ItalianWouldYouRatherQuestion` using a unique key and a patch. */
  updateItalianWouldYouRatherQuestionByUuid?: Maybe<UpdateItalianWouldYouRatherQuestionPayload>;
  /** Updates a single `JapaneseRandomQuestion` using a unique key and a patch. */
  updateJapaneseRandomQuestion?: Maybe<UpdateJapaneseRandomQuestionPayload>;
  /** Updates a single `JapaneseRandomQuestion` using its globally unique id and a patch. */
  updateJapaneseRandomQuestionByNodeId?: Maybe<UpdateJapaneseRandomQuestionPayload>;
  /** Updates a single `JapaneseRandomQuestion` using a unique key and a patch. */
  updateJapaneseRandomQuestionByUuid?: Maybe<UpdateJapaneseRandomQuestionPayload>;
  /** Updates a single `JapaneseWouldYouRatherQuestion` using a unique key and a patch. */
  updateJapaneseWouldYouRatherQuestion?: Maybe<UpdateJapaneseWouldYouRatherQuestionPayload>;
  /** Updates a single `JapaneseWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateJapaneseWouldYouRatherQuestionByNodeId?: Maybe<UpdateJapaneseWouldYouRatherQuestionPayload>;
  /** Updates a single `JapaneseWouldYouRatherQuestion` using a unique key and a patch. */
  updateJapaneseWouldYouRatherQuestionByUuid?: Maybe<UpdateJapaneseWouldYouRatherQuestionPayload>;
  /** Updates a single `KoreanRandomQuestion` using a unique key and a patch. */
  updateKoreanRandomQuestion?: Maybe<UpdateKoreanRandomQuestionPayload>;
  /** Updates a single `KoreanRandomQuestion` using its globally unique id and a patch. */
  updateKoreanRandomQuestionByNodeId?: Maybe<UpdateKoreanRandomQuestionPayload>;
  /** Updates a single `KoreanRandomQuestion` using a unique key and a patch. */
  updateKoreanRandomQuestionByUuid?: Maybe<UpdateKoreanRandomQuestionPayload>;
  /** Updates a single `KoreanWouldYouRatherQuestion` using a unique key and a patch. */
  updateKoreanWouldYouRatherQuestion?: Maybe<UpdateKoreanWouldYouRatherQuestionPayload>;
  /** Updates a single `KoreanWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateKoreanWouldYouRatherQuestionByNodeId?: Maybe<UpdateKoreanWouldYouRatherQuestionPayload>;
  /** Updates a single `KoreanWouldYouRatherQuestion` using a unique key and a patch. */
  updateKoreanWouldYouRatherQuestionByUuid?: Maybe<UpdateKoreanWouldYouRatherQuestionPayload>;
  /** Updates a single `Language` using a unique key and a patch. */
  updateLanguage?: Maybe<UpdateLanguagePayload>;
  /** Updates a single `Language` using a unique key and a patch. */
  updateLanguageByAlpha2?: Maybe<UpdateLanguagePayload>;
  /** Updates a single `Language` using a unique key and a patch. */
  updateLanguageByEnglishName?: Maybe<UpdateLanguagePayload>;
  /** Updates a single `Language` using its globally unique id and a patch. */
  updateLanguageByNodeId?: Maybe<UpdateLanguagePayload>;
  /** Updates a single `LanguageSkillLevel` using a unique key and a patch. */
  updateLanguageSkillLevel?: Maybe<UpdateLanguageSkillLevelPayload>;
  /** Updates a single `LanguageSkillLevel` using its globally unique id and a patch. */
  updateLanguageSkillLevelByNodeId?: Maybe<UpdateLanguageSkillLevelPayload>;
  /** Updates a single `Message` using a unique key and a patch. */
  updateMessage?: Maybe<UpdateMessagePayload>;
  /** Updates a single `Message` using its globally unique id and a patch. */
  updateMessageByNodeId?: Maybe<UpdateMessagePayload>;
  /** Updates a single `Message` using a unique key and a patch. */
  updateMessageByUuid?: Maybe<UpdateMessagePayload>;
  /** Updates a single `MessagePreview` using a unique key and a patch. */
  updateMessagePreview?: Maybe<UpdateMessagePreviewPayload>;
  /** Updates a single `MessagePreview` using its globally unique id and a patch. */
  updateMessagePreviewByNodeId?: Maybe<UpdateMessagePreviewPayload>;
  /** Updates a single `MessagePreview` using a unique key and a patch. */
  updateMessagePreviewByUuid?: Maybe<UpdateMessagePreviewPayload>;
  /** Updates a single `Notification` using a unique key and a patch. */
  updateNotification?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Notification` using its globally unique id and a patch. */
  updateNotificationByNodeId?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Notification` using a unique key and a patch. */
  updateNotificationByUuid?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `NotificationChannel` using a unique key and a patch. */
  updateNotificationChannel?: Maybe<UpdateNotificationChannelPayload>;
  /** Updates a single `NotificationChannel` using a unique key and a patch. */
  updateNotificationChannelByName?: Maybe<UpdateNotificationChannelPayload>;
  /** Updates a single `NotificationChannel` using its globally unique id and a patch. */
  updateNotificationChannelByNodeId?: Maybe<UpdateNotificationChannelPayload>;
  /** Updates a single `NotificationChannel` using a unique key and a patch. */
  updateNotificationChannelByUuid?: Maybe<UpdateNotificationChannelPayload>;
  /** Updates a single `PortugueseRandomQuestion` using a unique key and a patch. */
  updatePortugueseRandomQuestion?: Maybe<UpdatePortugueseRandomQuestionPayload>;
  /** Updates a single `PortugueseRandomQuestion` using its globally unique id and a patch. */
  updatePortugueseRandomQuestionByNodeId?: Maybe<UpdatePortugueseRandomQuestionPayload>;
  /** Updates a single `PortugueseRandomQuestion` using a unique key and a patch. */
  updatePortugueseRandomQuestionByUuid?: Maybe<UpdatePortugueseRandomQuestionPayload>;
  /** Updates a single `PortugueseWord` using a unique key and a patch. */
  updatePortugueseWord?: Maybe<UpdatePortugueseWordPayload>;
  /** Updates a single `PortugueseWord` using its globally unique id and a patch. */
  updatePortugueseWordByNodeId?: Maybe<UpdatePortugueseWordPayload>;
  /** Updates a single `PortugueseWord` using a unique key and a patch. */
  updatePortugueseWordByUuid?: Maybe<UpdatePortugueseWordPayload>;
  /** Updates a single `PortugueseWouldYouRatherQuestion` using a unique key and a patch. */
  updatePortugueseWouldYouRatherQuestion?: Maybe<UpdatePortugueseWouldYouRatherQuestionPayload>;
  /** Updates a single `PortugueseWouldYouRatherQuestion` using its globally unique id and a patch. */
  updatePortugueseWouldYouRatherQuestionByNodeId?: Maybe<UpdatePortugueseWouldYouRatherQuestionPayload>;
  /** Updates a single `PortugueseWouldYouRatherQuestion` using a unique key and a patch. */
  updatePortugueseWouldYouRatherQuestionByUuid?: Maybe<UpdatePortugueseWouldYouRatherQuestionPayload>;
  /** Updates a single `Post` using a unique key and a patch. */
  updatePost?: Maybe<UpdatePostPayload>;
  /** Updates a single `Post` using its globally unique id and a patch. */
  updatePostByNodeId?: Maybe<UpdatePostPayload>;
  /** Updates a single `Post` using a unique key and a patch. */
  updatePostBySnowflakeId?: Maybe<UpdatePostPayload>;
  /** Updates a single `Post` using a unique key and a patch. */
  updatePostByUuid?: Maybe<UpdatePostPayload>;
  /** Updates a single `PostCorrection` using a unique key and a patch. */
  updatePostCorrection?: Maybe<UpdatePostCorrectionPayload>;
  /** Updates a single `PostCorrection` using its globally unique id and a patch. */
  updatePostCorrectionByNodeId?: Maybe<UpdatePostCorrectionPayload>;
  /** Updates a single `PostCorrection` using a unique key and a patch. */
  updatePostCorrectionByUuid?: Maybe<UpdatePostCorrectionPayload>;
  /** Updates a single `PostGame` using a unique key and a patch. */
  updatePostGame?: Maybe<UpdatePostGamePayload>;
  /** Updates a single `PostGameAnswer` using a unique key and a patch. */
  updatePostGameAnswer?: Maybe<UpdatePostGameAnswerPayload>;
  /** Updates a single `PostGameAnswer` using its globally unique id and a patch. */
  updatePostGameAnswerByNodeId?: Maybe<UpdatePostGameAnswerPayload>;
  /** Updates a single `PostGameAnswer` using a unique key and a patch. */
  updatePostGameAnswerByUuid?: Maybe<UpdatePostGameAnswerPayload>;
  /** Updates a single `PostGame` using its globally unique id and a patch. */
  updatePostGameByNodeId?: Maybe<UpdatePostGamePayload>;
  /** Updates a single `PostGame` using a unique key and a patch. */
  updatePostGameByUuid?: Maybe<UpdatePostGamePayload>;
  /** Updates a single `PostGameRange` using a unique key and a patch. */
  updatePostGameRange?: Maybe<UpdatePostGameRangePayload>;
  /** Updates a single `PostGameRange` using its globally unique id and a patch. */
  updatePostGameRangeByNodeId?: Maybe<UpdatePostGameRangePayload>;
  /** Updates a single `PostGameRange` using a unique key and a patch. */
  updatePostGameRangeByUuid?: Maybe<UpdatePostGameRangePayload>;
  /** Updates a single `PostLike` using a unique key and a patch. */
  updatePostLike?: Maybe<UpdatePostLikePayload>;
  /** Updates a single `PostLike` using its globally unique id and a patch. */
  updatePostLikeByNodeId?: Maybe<UpdatePostLikePayload>;
  /** Updates a single `PostRecording` using a unique key and a patch. */
  updatePostRecording?: Maybe<UpdatePostRecordingPayload>;
  /** Updates a single `PostRecording` using its globally unique id and a patch. */
  updatePostRecordingByNodeId?: Maybe<UpdatePostRecordingPayload>;
  /** Updates a single `PostRecording` using a unique key and a patch. */
  updatePostRecordingByUuid?: Maybe<UpdatePostRecordingPayload>;
  /** Updates a single `PostUserMention` using a unique key and a patch. */
  updatePostUserMention?: Maybe<UpdatePostUserMentionPayload>;
  /** Updates a single `PostUserMention` using its globally unique id and a patch. */
  updatePostUserMentionByNodeId?: Maybe<UpdatePostUserMentionPayload>;
  /** Updates a single `PostUserMention` using a unique key and a patch. */
  updatePostUserMentionByUuid?: Maybe<UpdatePostUserMentionPayload>;
  /** Updates a single `Prompt` using a unique key and a patch. */
  updatePrompt?: Maybe<UpdatePromptPayload>;
  /** Updates a single `Prompt` using its globally unique id and a patch. */
  updatePromptByNodeId?: Maybe<UpdatePromptPayload>;
  /** Updates a single `Prompt` using a unique key and a patch. */
  updatePromptByUuid?: Maybe<UpdatePromptPayload>;
  /** Updates a single `RussianRandomQuestion` using a unique key and a patch. */
  updateRussianRandomQuestion?: Maybe<UpdateRussianRandomQuestionPayload>;
  /** Updates a single `RussianRandomQuestion` using its globally unique id and a patch. */
  updateRussianRandomQuestionByNodeId?: Maybe<UpdateRussianRandomQuestionPayload>;
  /** Updates a single `RussianRandomQuestion` using a unique key and a patch. */
  updateRussianRandomQuestionByUuid?: Maybe<UpdateRussianRandomQuestionPayload>;
  /** Updates a single `RussianWord` using a unique key and a patch. */
  updateRussianWord?: Maybe<UpdateRussianWordPayload>;
  /** Updates a single `RussianWord` using its globally unique id and a patch. */
  updateRussianWordByNodeId?: Maybe<UpdateRussianWordPayload>;
  /** Updates a single `RussianWord` using a unique key and a patch. */
  updateRussianWordByUuid?: Maybe<UpdateRussianWordPayload>;
  /** Updates a single `RussianWouldYouRatherQuestion` using a unique key and a patch. */
  updateRussianWouldYouRatherQuestion?: Maybe<UpdateRussianWouldYouRatherQuestionPayload>;
  /** Updates a single `RussianWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateRussianWouldYouRatherQuestionByNodeId?: Maybe<UpdateRussianWouldYouRatherQuestionPayload>;
  /** Updates a single `RussianWouldYouRatherQuestion` using a unique key and a patch. */
  updateRussianWouldYouRatherQuestionByUuid?: Maybe<UpdateRussianWouldYouRatherQuestionPayload>;
  /** Updates a single `SpanishRandomQuestion` using a unique key and a patch. */
  updateSpanishRandomQuestion?: Maybe<UpdateSpanishRandomQuestionPayload>;
  /** Updates a single `SpanishRandomQuestion` using its globally unique id and a patch. */
  updateSpanishRandomQuestionByNodeId?: Maybe<UpdateSpanishRandomQuestionPayload>;
  /** Updates a single `SpanishRandomQuestion` using a unique key and a patch. */
  updateSpanishRandomQuestionByUuid?: Maybe<UpdateSpanishRandomQuestionPayload>;
  /** Updates a single `SpanishWord` using a unique key and a patch. */
  updateSpanishWord?: Maybe<UpdateSpanishWordPayload>;
  /** Updates a single `SpanishWord` using its globally unique id and a patch. */
  updateSpanishWordByNodeId?: Maybe<UpdateSpanishWordPayload>;
  /** Updates a single `SpanishWord` using a unique key and a patch. */
  updateSpanishWordByUuid?: Maybe<UpdateSpanishWordPayload>;
  /** Updates a single `SpanishWouldYouRatherQuestion` using a unique key and a patch. */
  updateSpanishWouldYouRatherQuestion?: Maybe<UpdateSpanishWouldYouRatherQuestionPayload>;
  /** Updates a single `SpanishWouldYouRatherQuestion` using its globally unique id and a patch. */
  updateSpanishWouldYouRatherQuestionByNodeId?: Maybe<UpdateSpanishWouldYouRatherQuestionPayload>;
  /** Updates a single `SpanishWouldYouRatherQuestion` using a unique key and a patch. */
  updateSpanishWouldYouRatherQuestionByUuid?: Maybe<UpdateSpanishWouldYouRatherQuestionPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByEmail?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByEmailUnsubscribeToken?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByResetPasswordToken?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByUsername?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByUuid?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserDevice` using a unique key and a patch. */
  updateUserDevice?: Maybe<UpdateUserDevicePayload>;
  /** Updates a single `UserDevice` using a unique key and a patch. */
  updateUserDeviceByFcmToken?: Maybe<UpdateUserDevicePayload>;
  /** Updates a single `UserDevice` using its globally unique id and a patch. */
  updateUserDeviceByNodeId?: Maybe<UpdateUserDevicePayload>;
  /** Updates a single `UserDevice` using a unique key and a patch. */
  updateUserDeviceByUuid?: Maybe<UpdateUserDevicePayload>;
  /** Updates a single `UserFollower` using a unique key and a patch. */
  updateUserFollower?: Maybe<UpdateUserFollowerPayload>;
  /** Updates a single `UserFollower` using its globally unique id and a patch. */
  updateUserFollowerByNodeId?: Maybe<UpdateUserFollowerPayload>;
  /** Updates a single `UserLanguage` using a unique key and a patch. */
  updateUserLanguage?: Maybe<UpdateUserLanguagePayload>;
  /** Updates a single `UserLanguage` using its globally unique id and a patch. */
  updateUserLanguageByNodeId?: Maybe<UpdateUserLanguagePayload>;
  /** Updates a single `UserPreference` using a unique key and a patch. */
  updateUserPreference?: Maybe<UpdateUserPreferencePayload>;
  /** Updates a single `UserPreference` using its globally unique id and a patch. */
  updateUserPreferenceByNodeId?: Maybe<UpdateUserPreferencePayload>;
  /** Updates a single `UserPreference` using a unique key and a patch. */
  updateUserPreferenceByUserId?: Maybe<UpdateUserPreferencePayload>;
  /** Updates a single `UserSession` using a unique key and a patch. */
  updateUserSession?: Maybe<UpdateUserSessionPayload>;
  /** Updates a single `UserSession` using its globally unique id and a patch. */
  updateUserSessionByNodeId?: Maybe<UpdateUserSessionPayload>;
  /** Upserts a single `ChineseGuessCharacterQuestion`. */
  upsertChineseGuessCharacterQuestion?: Maybe<UpsertChineseGuessCharacterQuestionPayload>;
  /** Upserts a single `ChineseRandomQuestion`. */
  upsertChineseRandomQuestion?: Maybe<UpsertChineseRandomQuestionPayload>;
  /** Upserts a single `ChineseWouldYouRatherQuestion`. */
  upsertChineseWouldYouRatherQuestion?: Maybe<UpsertChineseWouldYouRatherQuestionPayload>;
  /** Upserts a single `EnglishRandomQuestion`. */
  upsertEnglishRandomQuestion?: Maybe<UpsertEnglishRandomQuestionPayload>;
  /** Upserts a single `EnglishWord`. */
  upsertEnglishWord?: Maybe<UpsertEnglishWordPayload>;
  /** Upserts a single `EnglishWouldYouRatherQuestion`. */
  upsertEnglishWouldYouRatherQuestion?: Maybe<UpsertEnglishWouldYouRatherQuestionPayload>;
  /** Upserts a single `FrenchRandomQuestion`. */
  upsertFrenchRandomQuestion?: Maybe<UpsertFrenchRandomQuestionPayload>;
  /** Upserts a single `FrenchWord`. */
  upsertFrenchWord?: Maybe<UpsertFrenchWordPayload>;
  /** Upserts a single `FrenchWouldYouRatherQuestion`. */
  upsertFrenchWouldYouRatherQuestion?: Maybe<UpsertFrenchWouldYouRatherQuestionPayload>;
  /** Upserts a single `GermanRandomQuestion`. */
  upsertGermanRandomQuestion?: Maybe<UpsertGermanRandomQuestionPayload>;
  /** Upserts a single `GermanWord`. */
  upsertGermanWord?: Maybe<UpsertGermanWordPayload>;
  /** Upserts a single `GermanWouldYouRatherQuestion`. */
  upsertGermanWouldYouRatherQuestion?: Maybe<UpsertGermanWouldYouRatherQuestionPayload>;
  /** Upserts a single `Group`. */
  upsertGroup?: Maybe<UpsertGroupPayload>;
  /** Upserts a single `GroupUser`. */
  upsertGroupUser?: Maybe<UpsertGroupUserPayload>;
  /** Upserts a single `InviteToken`. */
  upsertInviteToken?: Maybe<UpsertInviteTokenPayload>;
  /** Upserts a single `ItalianRandomQuestion`. */
  upsertItalianRandomQuestion?: Maybe<UpsertItalianRandomQuestionPayload>;
  /** Upserts a single `ItalianWord`. */
  upsertItalianWord?: Maybe<UpsertItalianWordPayload>;
  /** Upserts a single `ItalianWouldYouRatherQuestion`. */
  upsertItalianWouldYouRatherQuestion?: Maybe<UpsertItalianWouldYouRatherQuestionPayload>;
  /** Upserts a single `JapaneseRandomQuestion`. */
  upsertJapaneseRandomQuestion?: Maybe<UpsertJapaneseRandomQuestionPayload>;
  /** Upserts a single `JapaneseWouldYouRatherQuestion`. */
  upsertJapaneseWouldYouRatherQuestion?: Maybe<UpsertJapaneseWouldYouRatherQuestionPayload>;
  /** Upserts a single `KoreanRandomQuestion`. */
  upsertKoreanRandomQuestion?: Maybe<UpsertKoreanRandomQuestionPayload>;
  /** Upserts a single `KoreanWouldYouRatherQuestion`. */
  upsertKoreanWouldYouRatherQuestion?: Maybe<UpsertKoreanWouldYouRatherQuestionPayload>;
  /** Upserts a single `Language`. */
  upsertLanguage?: Maybe<UpsertLanguagePayload>;
  /** Upserts a single `LanguageSkillLevel`. */
  upsertLanguageSkillLevel?: Maybe<UpsertLanguageSkillLevelPayload>;
  /** Upserts a single `Message`. */
  upsertMessage?: Maybe<UpsertMessagePayload>;
  /** Upserts a single `MessagePreview`. */
  upsertMessagePreview?: Maybe<UpsertMessagePreviewPayload>;
  /** Upserts a single `Notification`. */
  upsertNotification?: Maybe<UpsertNotificationPayload>;
  /** Upserts a single `NotificationChannel`. */
  upsertNotificationChannel?: Maybe<UpsertNotificationChannelPayload>;
  /** Upserts a single `PortugueseRandomQuestion`. */
  upsertPortugueseRandomQuestion?: Maybe<UpsertPortugueseRandomQuestionPayload>;
  /** Upserts a single `PortugueseWord`. */
  upsertPortugueseWord?: Maybe<UpsertPortugueseWordPayload>;
  /** Upserts a single `PortugueseWouldYouRatherQuestion`. */
  upsertPortugueseWouldYouRatherQuestion?: Maybe<UpsertPortugueseWouldYouRatherQuestionPayload>;
  /** Upserts a single `Post`. */
  upsertPost?: Maybe<UpsertPostPayload>;
  /** Upserts a single `PostCorrection`. */
  upsertPostCorrection?: Maybe<UpsertPostCorrectionPayload>;
  /** Upserts a single `PostGame`. */
  upsertPostGame?: Maybe<UpsertPostGamePayload>;
  /** Upserts a single `PostGameAnswer`. */
  upsertPostGameAnswer?: Maybe<UpsertPostGameAnswerPayload>;
  /** Upserts a single `PostGameRange`. */
  upsertPostGameRange?: Maybe<UpsertPostGameRangePayload>;
  /** Upserts a single `PostLike`. */
  upsertPostLike?: Maybe<UpsertPostLikePayload>;
  /** Upserts a single `PostRecording`. */
  upsertPostRecording?: Maybe<UpsertPostRecordingPayload>;
  /** Upserts a single `PostUserMention`. */
  upsertPostUserMention?: Maybe<UpsertPostUserMentionPayload>;
  /** Upserts a single `Prompt`. */
  upsertPrompt?: Maybe<UpsertPromptPayload>;
  /** Upserts a single `RussianRandomQuestion`. */
  upsertRussianRandomQuestion?: Maybe<UpsertRussianRandomQuestionPayload>;
  /** Upserts a single `RussianWord`. */
  upsertRussianWord?: Maybe<UpsertRussianWordPayload>;
  /** Upserts a single `RussianWouldYouRatherQuestion`. */
  upsertRussianWouldYouRatherQuestion?: Maybe<UpsertRussianWouldYouRatherQuestionPayload>;
  /** Upserts a single `SpanishRandomQuestion`. */
  upsertSpanishRandomQuestion?: Maybe<UpsertSpanishRandomQuestionPayload>;
  /** Upserts a single `SpanishWord`. */
  upsertSpanishWord?: Maybe<UpsertSpanishWordPayload>;
  /** Upserts a single `SpanishWouldYouRatherQuestion`. */
  upsertSpanishWouldYouRatherQuestion?: Maybe<UpsertSpanishWouldYouRatherQuestionPayload>;
  /** Upserts a single `User`. */
  upsertUser?: Maybe<UpsertUserPayload>;
  /** Upserts a single `UserDevice`. */
  upsertUserDevice?: Maybe<UpsertUserDevicePayload>;
  /** Upserts a single `UserFollower`. */
  upsertUserFollower?: Maybe<UpsertUserFollowerPayload>;
  /** Upserts a single `UserLanguage`. */
  upsertUserLanguage?: Maybe<UpsertUserLanguagePayload>;
  /** Upserts a single `UserPreference`. */
  upsertUserPreference?: Maybe<UpsertUserPreferencePayload>;
  /** Upserts a single `UserSession`. */
  upsertUserSession?: Maybe<UpsertUserSessionPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateChineseGuessCharacterQuestionArgs = {
  input: CreateChineseGuessCharacterQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateChineseRandomQuestionArgs = {
  input: CreateChineseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateChineseWouldYouRatherQuestionArgs = {
  input: CreateChineseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEnglishRandomQuestionArgs = {
  input: CreateEnglishRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEnglishWordArgs = {
  input: CreateEnglishWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEnglishWouldYouRatherQuestionArgs = {
  input: CreateEnglishWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFrenchRandomQuestionArgs = {
  input: CreateFrenchRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFrenchWordArgs = {
  input: CreateFrenchWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFrenchWouldYouRatherQuestionArgs = {
  input: CreateFrenchWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGermanRandomQuestionArgs = {
  input: CreateGermanRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGermanWordArgs = {
  input: CreateGermanWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGermanWouldYouRatherQuestionArgs = {
  input: CreateGermanWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupUserArgs = {
  input: CreateGroupUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInviteTokenArgs = {
  input: CreateInviteTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateItalianRandomQuestionArgs = {
  input: CreateItalianRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateItalianWordArgs = {
  input: CreateItalianWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateItalianWouldYouRatherQuestionArgs = {
  input: CreateItalianWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJapaneseRandomQuestionArgs = {
  input: CreateJapaneseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJapaneseWouldYouRatherQuestionArgs = {
  input: CreateJapaneseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateKoreanRandomQuestionArgs = {
  input: CreateKoreanRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateKoreanWouldYouRatherQuestionArgs = {
  input: CreateKoreanWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLanguageArgs = {
  input: CreateLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLanguageSkillLevelArgs = {
  input: CreateLanguageSkillLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageArgs = {
  input: CreateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessagePreviewArgs = {
  input: CreateMessagePreviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNotificationArgs = {
  input: CreateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNotificationChannelArgs = {
  input: CreateNotificationChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePortugueseRandomQuestionArgs = {
  input: CreatePortugueseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePortugueseWordArgs = {
  input: CreatePortugueseWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePortugueseWouldYouRatherQuestionArgs = {
  input: CreatePortugueseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostCorrectionArgs = {
  input: CreatePostCorrectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostGameArgs = {
  input: CreatePostGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostGameAnswerArgs = {
  input: CreatePostGameAnswerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostGameRangeArgs = {
  input: CreatePostGameRangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostLikeArgs = {
  input: CreatePostLikeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostRecordingArgs = {
  input: CreatePostRecordingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePostUserMentionArgs = {
  input: CreatePostUserMentionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePromptArgs = {
  input: CreatePromptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRussianRandomQuestionArgs = {
  input: CreateRussianRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRussianWordArgs = {
  input: CreateRussianWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRussianWouldYouRatherQuestionArgs = {
  input: CreateRussianWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpanishRandomQuestionArgs = {
  input: CreateSpanishRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpanishWordArgs = {
  input: CreateSpanishWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSpanishWouldYouRatherQuestionArgs = {
  input: CreateSpanishWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserDeviceArgs = {
  input: CreateUserDeviceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserFollowerArgs = {
  input: CreateUserFollowerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserLanguageArgs = {
  input: CreateUserLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserPreferenceArgs = {
  input: CreateUserPreferenceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserSessionArgs = {
  input: CreateUserSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseGuessCharacterQuestionArgs = {
  input: DeleteChineseGuessCharacterQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseGuessCharacterQuestionByNodeIdArgs = {
  input: DeleteChineseGuessCharacterQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseGuessCharacterQuestionByUuidArgs = {
  input: DeleteChineseGuessCharacterQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseRandomQuestionArgs = {
  input: DeleteChineseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseRandomQuestionByNodeIdArgs = {
  input: DeleteChineseRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseRandomQuestionByUuidArgs = {
  input: DeleteChineseRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseWouldYouRatherQuestionArgs = {
  input: DeleteChineseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteChineseWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChineseWouldYouRatherQuestionByUuidArgs = {
  input: DeleteChineseWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishRandomQuestionArgs = {
  input: DeleteEnglishRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishRandomQuestionByNodeIdArgs = {
  input: DeleteEnglishRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishRandomQuestionByUuidArgs = {
  input: DeleteEnglishRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishWordArgs = {
  input: DeleteEnglishWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishWordByNodeIdArgs = {
  input: DeleteEnglishWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishWordByUuidArgs = {
  input: DeleteEnglishWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishWouldYouRatherQuestionArgs = {
  input: DeleteEnglishWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteEnglishWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnglishWouldYouRatherQuestionByUuidArgs = {
  input: DeleteEnglishWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchRandomQuestionArgs = {
  input: DeleteFrenchRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchRandomQuestionByNodeIdArgs = {
  input: DeleteFrenchRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchRandomQuestionByUuidArgs = {
  input: DeleteFrenchRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchWordArgs = {
  input: DeleteFrenchWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchWordByNodeIdArgs = {
  input: DeleteFrenchWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchWordByUuidArgs = {
  input: DeleteFrenchWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchWouldYouRatherQuestionArgs = {
  input: DeleteFrenchWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteFrenchWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFrenchWouldYouRatherQuestionByUuidArgs = {
  input: DeleteFrenchWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanRandomQuestionArgs = {
  input: DeleteGermanRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanRandomQuestionByNodeIdArgs = {
  input: DeleteGermanRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanRandomQuestionByUuidArgs = {
  input: DeleteGermanRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanWordArgs = {
  input: DeleteGermanWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanWordByNodeIdArgs = {
  input: DeleteGermanWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanWordByUuidArgs = {
  input: DeleteGermanWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanWouldYouRatherQuestionArgs = {
  input: DeleteGermanWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteGermanWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGermanWouldYouRatherQuestionByUuidArgs = {
  input: DeleteGermanWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNodeIdArgs = {
  input: DeleteGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByUuidArgs = {
  input: DeleteGroupByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupUserArgs = {
  input: DeleteGroupUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupUserByNodeIdArgs = {
  input: DeleteGroupUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInviteTokenArgs = {
  input: DeleteInviteTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInviteTokenByNodeIdArgs = {
  input: DeleteInviteTokenByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianRandomQuestionArgs = {
  input: DeleteItalianRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianRandomQuestionByNodeIdArgs = {
  input: DeleteItalianRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianRandomQuestionByUuidArgs = {
  input: DeleteItalianRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianWordArgs = {
  input: DeleteItalianWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianWordByNodeIdArgs = {
  input: DeleteItalianWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianWordByUuidArgs = {
  input: DeleteItalianWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianWouldYouRatherQuestionArgs = {
  input: DeleteItalianWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteItalianWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItalianWouldYouRatherQuestionByUuidArgs = {
  input: DeleteItalianWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJapaneseRandomQuestionArgs = {
  input: DeleteJapaneseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJapaneseRandomQuestionByNodeIdArgs = {
  input: DeleteJapaneseRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJapaneseRandomQuestionByUuidArgs = {
  input: DeleteJapaneseRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJapaneseWouldYouRatherQuestionArgs = {
  input: DeleteJapaneseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJapaneseWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteJapaneseWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJapaneseWouldYouRatherQuestionByUuidArgs = {
  input: DeleteJapaneseWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKoreanRandomQuestionArgs = {
  input: DeleteKoreanRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKoreanRandomQuestionByNodeIdArgs = {
  input: DeleteKoreanRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKoreanRandomQuestionByUuidArgs = {
  input: DeleteKoreanRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKoreanWouldYouRatherQuestionArgs = {
  input: DeleteKoreanWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKoreanWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteKoreanWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKoreanWouldYouRatherQuestionByUuidArgs = {
  input: DeleteKoreanWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageArgs = {
  input: DeleteLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageByAlpha2Args = {
  input: DeleteLanguageByAlpha2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageByEnglishNameArgs = {
  input: DeleteLanguageByEnglishNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageByNodeIdArgs = {
  input: DeleteLanguageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageSkillLevelArgs = {
  input: DeleteLanguageSkillLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageSkillLevelByNodeIdArgs = {
  input: DeleteLanguageSkillLevelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageArgs = {
  input: DeleteMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageByNodeIdArgs = {
  input: DeleteMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageByUuidArgs = {
  input: DeleteMessageByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessagePreviewArgs = {
  input: DeleteMessagePreviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessagePreviewByNodeIdArgs = {
  input: DeleteMessagePreviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessagePreviewByUuidArgs = {
  input: DeleteMessagePreviewByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationArgs = {
  input: DeleteNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationByNodeIdArgs = {
  input: DeleteNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationByUuidArgs = {
  input: DeleteNotificationByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationChannelArgs = {
  input: DeleteNotificationChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationChannelByNameArgs = {
  input: DeleteNotificationChannelByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationChannelByNodeIdArgs = {
  input: DeleteNotificationChannelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationChannelByUuidArgs = {
  input: DeleteNotificationChannelByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseRandomQuestionArgs = {
  input: DeletePortugueseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseRandomQuestionByNodeIdArgs = {
  input: DeletePortugueseRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseRandomQuestionByUuidArgs = {
  input: DeletePortugueseRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseWordArgs = {
  input: DeletePortugueseWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseWordByNodeIdArgs = {
  input: DeletePortugueseWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseWordByUuidArgs = {
  input: DeletePortugueseWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseWouldYouRatherQuestionArgs = {
  input: DeletePortugueseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseWouldYouRatherQuestionByNodeIdArgs = {
  input: DeletePortugueseWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePortugueseWouldYouRatherQuestionByUuidArgs = {
  input: DeletePortugueseWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostArgs = {
  input: DeletePostInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostByNodeIdArgs = {
  input: DeletePostByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostBySnowflakeIdArgs = {
  input: DeletePostBySnowflakeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostByUuidArgs = {
  input: DeletePostByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostCorrectionArgs = {
  input: DeletePostCorrectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostCorrectionByNodeIdArgs = {
  input: DeletePostCorrectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostCorrectionByUuidArgs = {
  input: DeletePostCorrectionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameArgs = {
  input: DeletePostGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameAnswerArgs = {
  input: DeletePostGameAnswerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameAnswerByNodeIdArgs = {
  input: DeletePostGameAnswerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameAnswerByUuidArgs = {
  input: DeletePostGameAnswerByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameByNodeIdArgs = {
  input: DeletePostGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameByUuidArgs = {
  input: DeletePostGameByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameRangeArgs = {
  input: DeletePostGameRangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameRangeByNodeIdArgs = {
  input: DeletePostGameRangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostGameRangeByUuidArgs = {
  input: DeletePostGameRangeByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostLikeArgs = {
  input: DeletePostLikeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostLikeByNodeIdArgs = {
  input: DeletePostLikeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostRecordingArgs = {
  input: DeletePostRecordingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostRecordingByNodeIdArgs = {
  input: DeletePostRecordingByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostRecordingByUuidArgs = {
  input: DeletePostRecordingByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostUserMentionArgs = {
  input: DeletePostUserMentionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostUserMentionByNodeIdArgs = {
  input: DeletePostUserMentionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePostUserMentionByUuidArgs = {
  input: DeletePostUserMentionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePromptArgs = {
  input: DeletePromptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePromptByNodeIdArgs = {
  input: DeletePromptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePromptByUuidArgs = {
  input: DeletePromptByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianRandomQuestionArgs = {
  input: DeleteRussianRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianRandomQuestionByNodeIdArgs = {
  input: DeleteRussianRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianRandomQuestionByUuidArgs = {
  input: DeleteRussianRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianWordArgs = {
  input: DeleteRussianWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianWordByNodeIdArgs = {
  input: DeleteRussianWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianWordByUuidArgs = {
  input: DeleteRussianWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianWouldYouRatherQuestionArgs = {
  input: DeleteRussianWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteRussianWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRussianWouldYouRatherQuestionByUuidArgs = {
  input: DeleteRussianWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishRandomQuestionArgs = {
  input: DeleteSpanishRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishRandomQuestionByNodeIdArgs = {
  input: DeleteSpanishRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishRandomQuestionByUuidArgs = {
  input: DeleteSpanishRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishWordArgs = {
  input: DeleteSpanishWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishWordByNodeIdArgs = {
  input: DeleteSpanishWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishWordByUuidArgs = {
  input: DeleteSpanishWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishWouldYouRatherQuestionArgs = {
  input: DeleteSpanishWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishWouldYouRatherQuestionByNodeIdArgs = {
  input: DeleteSpanishWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSpanishWouldYouRatherQuestionByUuidArgs = {
  input: DeleteSpanishWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByEmailArgs = {
  input: DeleteUserByEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByEmailUnsubscribeTokenArgs = {
  input: DeleteUserByEmailUnsubscribeTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByResetPasswordTokenArgs = {
  input: DeleteUserByResetPasswordTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByUsernameArgs = {
  input: DeleteUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByUuidArgs = {
  input: DeleteUserByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserDeviceArgs = {
  input: DeleteUserDeviceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserDeviceByFcmTokenArgs = {
  input: DeleteUserDeviceByFcmTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserDeviceByNodeIdArgs = {
  input: DeleteUserDeviceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserDeviceByUuidArgs = {
  input: DeleteUserDeviceByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserFollowerArgs = {
  input: DeleteUserFollowerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserFollowerByNodeIdArgs = {
  input: DeleteUserFollowerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserLanguageArgs = {
  input: DeleteUserLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserLanguageByNodeIdArgs = {
  input: DeleteUserLanguageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserPreferenceArgs = {
  input: DeleteUserPreferenceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserPreferenceByNodeIdArgs = {
  input: DeleteUserPreferenceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserPreferenceByUserIdArgs = {
  input: DeleteUserPreferenceByUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserSessionArgs = {
  input: DeleteUserSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserSessionByNodeIdArgs = {
  input: DeleteUserSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationGenerateSnowflakeIdArgs = {
  input: GenerateSnowflakeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationJoinGlobalGroupArgs = {
  input: JoinGlobalGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterUserActivityArgs = {
  input: RegisterUserActivityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseGuessCharacterQuestionArgs = {
  input: UpdateChineseGuessCharacterQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseGuessCharacterQuestionByNodeIdArgs = {
  input: UpdateChineseGuessCharacterQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseGuessCharacterQuestionByUuidArgs = {
  input: UpdateChineseGuessCharacterQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseRandomQuestionArgs = {
  input: UpdateChineseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseRandomQuestionByNodeIdArgs = {
  input: UpdateChineseRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseRandomQuestionByUuidArgs = {
  input: UpdateChineseRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseWouldYouRatherQuestionArgs = {
  input: UpdateChineseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateChineseWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChineseWouldYouRatherQuestionByUuidArgs = {
  input: UpdateChineseWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishRandomQuestionArgs = {
  input: UpdateEnglishRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishRandomQuestionByNodeIdArgs = {
  input: UpdateEnglishRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishRandomQuestionByUuidArgs = {
  input: UpdateEnglishRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishWordArgs = {
  input: UpdateEnglishWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishWordByNodeIdArgs = {
  input: UpdateEnglishWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishWordByUuidArgs = {
  input: UpdateEnglishWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishWouldYouRatherQuestionArgs = {
  input: UpdateEnglishWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateEnglishWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnglishWouldYouRatherQuestionByUuidArgs = {
  input: UpdateEnglishWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchRandomQuestionArgs = {
  input: UpdateFrenchRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchRandomQuestionByNodeIdArgs = {
  input: UpdateFrenchRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchRandomQuestionByUuidArgs = {
  input: UpdateFrenchRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchWordArgs = {
  input: UpdateFrenchWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchWordByNodeIdArgs = {
  input: UpdateFrenchWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchWordByUuidArgs = {
  input: UpdateFrenchWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchWouldYouRatherQuestionArgs = {
  input: UpdateFrenchWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateFrenchWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFrenchWouldYouRatherQuestionByUuidArgs = {
  input: UpdateFrenchWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanRandomQuestionArgs = {
  input: UpdateGermanRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanRandomQuestionByNodeIdArgs = {
  input: UpdateGermanRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanRandomQuestionByUuidArgs = {
  input: UpdateGermanRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanWordArgs = {
  input: UpdateGermanWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanWordByNodeIdArgs = {
  input: UpdateGermanWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanWordByUuidArgs = {
  input: UpdateGermanWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanWouldYouRatherQuestionArgs = {
  input: UpdateGermanWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateGermanWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGermanWouldYouRatherQuestionByUuidArgs = {
  input: UpdateGermanWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNodeIdArgs = {
  input: UpdateGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByUuidArgs = {
  input: UpdateGroupByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupUserArgs = {
  input: UpdateGroupUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupUserByNodeIdArgs = {
  input: UpdateGroupUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInviteTokenArgs = {
  input: UpdateInviteTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInviteTokenByNodeIdArgs = {
  input: UpdateInviteTokenByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianRandomQuestionArgs = {
  input: UpdateItalianRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianRandomQuestionByNodeIdArgs = {
  input: UpdateItalianRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianRandomQuestionByUuidArgs = {
  input: UpdateItalianRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianWordArgs = {
  input: UpdateItalianWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianWordByNodeIdArgs = {
  input: UpdateItalianWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianWordByUuidArgs = {
  input: UpdateItalianWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianWouldYouRatherQuestionArgs = {
  input: UpdateItalianWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateItalianWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItalianWouldYouRatherQuestionByUuidArgs = {
  input: UpdateItalianWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJapaneseRandomQuestionArgs = {
  input: UpdateJapaneseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJapaneseRandomQuestionByNodeIdArgs = {
  input: UpdateJapaneseRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJapaneseRandomQuestionByUuidArgs = {
  input: UpdateJapaneseRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJapaneseWouldYouRatherQuestionArgs = {
  input: UpdateJapaneseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJapaneseWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateJapaneseWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJapaneseWouldYouRatherQuestionByUuidArgs = {
  input: UpdateJapaneseWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKoreanRandomQuestionArgs = {
  input: UpdateKoreanRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKoreanRandomQuestionByNodeIdArgs = {
  input: UpdateKoreanRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKoreanRandomQuestionByUuidArgs = {
  input: UpdateKoreanRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKoreanWouldYouRatherQuestionArgs = {
  input: UpdateKoreanWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKoreanWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateKoreanWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKoreanWouldYouRatherQuestionByUuidArgs = {
  input: UpdateKoreanWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageArgs = {
  input: UpdateLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageByAlpha2Args = {
  input: UpdateLanguageByAlpha2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageByEnglishNameArgs = {
  input: UpdateLanguageByEnglishNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageByNodeIdArgs = {
  input: UpdateLanguageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageSkillLevelArgs = {
  input: UpdateLanguageSkillLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageSkillLevelByNodeIdArgs = {
  input: UpdateLanguageSkillLevelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageArgs = {
  input: UpdateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageByNodeIdArgs = {
  input: UpdateMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageByUuidArgs = {
  input: UpdateMessageByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessagePreviewArgs = {
  input: UpdateMessagePreviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessagePreviewByNodeIdArgs = {
  input: UpdateMessagePreviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessagePreviewByUuidArgs = {
  input: UpdateMessagePreviewByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationArgs = {
  input: UpdateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationByNodeIdArgs = {
  input: UpdateNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationByUuidArgs = {
  input: UpdateNotificationByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationChannelArgs = {
  input: UpdateNotificationChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationChannelByNameArgs = {
  input: UpdateNotificationChannelByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationChannelByNodeIdArgs = {
  input: UpdateNotificationChannelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationChannelByUuidArgs = {
  input: UpdateNotificationChannelByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseRandomQuestionArgs = {
  input: UpdatePortugueseRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseRandomQuestionByNodeIdArgs = {
  input: UpdatePortugueseRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseRandomQuestionByUuidArgs = {
  input: UpdatePortugueseRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseWordArgs = {
  input: UpdatePortugueseWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseWordByNodeIdArgs = {
  input: UpdatePortugueseWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseWordByUuidArgs = {
  input: UpdatePortugueseWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseWouldYouRatherQuestionArgs = {
  input: UpdatePortugueseWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdatePortugueseWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePortugueseWouldYouRatherQuestionByUuidArgs = {
  input: UpdatePortugueseWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostArgs = {
  input: UpdatePostInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostByNodeIdArgs = {
  input: UpdatePostByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostBySnowflakeIdArgs = {
  input: UpdatePostBySnowflakeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostByUuidArgs = {
  input: UpdatePostByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostCorrectionArgs = {
  input: UpdatePostCorrectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostCorrectionByNodeIdArgs = {
  input: UpdatePostCorrectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostCorrectionByUuidArgs = {
  input: UpdatePostCorrectionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameArgs = {
  input: UpdatePostGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameAnswerArgs = {
  input: UpdatePostGameAnswerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameAnswerByNodeIdArgs = {
  input: UpdatePostGameAnswerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameAnswerByUuidArgs = {
  input: UpdatePostGameAnswerByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameByNodeIdArgs = {
  input: UpdatePostGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameByUuidArgs = {
  input: UpdatePostGameByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameRangeArgs = {
  input: UpdatePostGameRangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameRangeByNodeIdArgs = {
  input: UpdatePostGameRangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostGameRangeByUuidArgs = {
  input: UpdatePostGameRangeByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostLikeArgs = {
  input: UpdatePostLikeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostLikeByNodeIdArgs = {
  input: UpdatePostLikeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostRecordingArgs = {
  input: UpdatePostRecordingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostRecordingByNodeIdArgs = {
  input: UpdatePostRecordingByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostRecordingByUuidArgs = {
  input: UpdatePostRecordingByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostUserMentionArgs = {
  input: UpdatePostUserMentionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostUserMentionByNodeIdArgs = {
  input: UpdatePostUserMentionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePostUserMentionByUuidArgs = {
  input: UpdatePostUserMentionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePromptArgs = {
  input: UpdatePromptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePromptByNodeIdArgs = {
  input: UpdatePromptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePromptByUuidArgs = {
  input: UpdatePromptByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianRandomQuestionArgs = {
  input: UpdateRussianRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianRandomQuestionByNodeIdArgs = {
  input: UpdateRussianRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianRandomQuestionByUuidArgs = {
  input: UpdateRussianRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianWordArgs = {
  input: UpdateRussianWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianWordByNodeIdArgs = {
  input: UpdateRussianWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianWordByUuidArgs = {
  input: UpdateRussianWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianWouldYouRatherQuestionArgs = {
  input: UpdateRussianWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateRussianWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRussianWouldYouRatherQuestionByUuidArgs = {
  input: UpdateRussianWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishRandomQuestionArgs = {
  input: UpdateSpanishRandomQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishRandomQuestionByNodeIdArgs = {
  input: UpdateSpanishRandomQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishRandomQuestionByUuidArgs = {
  input: UpdateSpanishRandomQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishWordArgs = {
  input: UpdateSpanishWordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishWordByNodeIdArgs = {
  input: UpdateSpanishWordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishWordByUuidArgs = {
  input: UpdateSpanishWordByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishWouldYouRatherQuestionArgs = {
  input: UpdateSpanishWouldYouRatherQuestionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishWouldYouRatherQuestionByNodeIdArgs = {
  input: UpdateSpanishWouldYouRatherQuestionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSpanishWouldYouRatherQuestionByUuidArgs = {
  input: UpdateSpanishWouldYouRatherQuestionByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByEmailArgs = {
  input: UpdateUserByEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByEmailUnsubscribeTokenArgs = {
  input: UpdateUserByEmailUnsubscribeTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByResetPasswordTokenArgs = {
  input: UpdateUserByResetPasswordTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByUsernameArgs = {
  input: UpdateUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByUuidArgs = {
  input: UpdateUserByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserDeviceArgs = {
  input: UpdateUserDeviceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserDeviceByFcmTokenArgs = {
  input: UpdateUserDeviceByFcmTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserDeviceByNodeIdArgs = {
  input: UpdateUserDeviceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserDeviceByUuidArgs = {
  input: UpdateUserDeviceByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserFollowerArgs = {
  input: UpdateUserFollowerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserFollowerByNodeIdArgs = {
  input: UpdateUserFollowerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserLanguageArgs = {
  input: UpdateUserLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserLanguageByNodeIdArgs = {
  input: UpdateUserLanguageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserPreferenceArgs = {
  input: UpdateUserPreferenceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserPreferenceByNodeIdArgs = {
  input: UpdateUserPreferenceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserPreferenceByUserIdArgs = {
  input: UpdateUserPreferenceByUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserSessionArgs = {
  input: UpdateUserSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserSessionByNodeIdArgs = {
  input: UpdateUserSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertChineseGuessCharacterQuestionArgs = {
  input: UpsertChineseGuessCharacterQuestionInput;
  where?: Maybe<UpsertChineseGuessCharacterQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertChineseRandomQuestionArgs = {
  input: UpsertChineseRandomQuestionInput;
  where?: Maybe<UpsertChineseRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertChineseWouldYouRatherQuestionArgs = {
  input: UpsertChineseWouldYouRatherQuestionInput;
  where?: Maybe<UpsertChineseWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertEnglishRandomQuestionArgs = {
  input: UpsertEnglishRandomQuestionInput;
  where?: Maybe<UpsertEnglishRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertEnglishWordArgs = {
  input: UpsertEnglishWordInput;
  where?: Maybe<UpsertEnglishWordWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertEnglishWouldYouRatherQuestionArgs = {
  input: UpsertEnglishWouldYouRatherQuestionInput;
  where?: Maybe<UpsertEnglishWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertFrenchRandomQuestionArgs = {
  input: UpsertFrenchRandomQuestionInput;
  where?: Maybe<UpsertFrenchRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertFrenchWordArgs = {
  input: UpsertFrenchWordInput;
  where?: Maybe<UpsertFrenchWordWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertFrenchWouldYouRatherQuestionArgs = {
  input: UpsertFrenchWouldYouRatherQuestionInput;
  where?: Maybe<UpsertFrenchWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertGermanRandomQuestionArgs = {
  input: UpsertGermanRandomQuestionInput;
  where?: Maybe<UpsertGermanRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertGermanWordArgs = {
  input: UpsertGermanWordInput;
  where?: Maybe<UpsertGermanWordWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertGermanWouldYouRatherQuestionArgs = {
  input: UpsertGermanWouldYouRatherQuestionInput;
  where?: Maybe<UpsertGermanWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertGroupArgs = {
  input: UpsertGroupInput;
  where?: Maybe<UpsertGroupWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertGroupUserArgs = {
  input: UpsertGroupUserInput;
  where?: Maybe<UpsertGroupUserWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertInviteTokenArgs = {
  input: UpsertInviteTokenInput;
  where?: Maybe<UpsertInviteTokenWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertItalianRandomQuestionArgs = {
  input: UpsertItalianRandomQuestionInput;
  where?: Maybe<UpsertItalianRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertItalianWordArgs = {
  input: UpsertItalianWordInput;
  where?: Maybe<UpsertItalianWordWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertItalianWouldYouRatherQuestionArgs = {
  input: UpsertItalianWouldYouRatherQuestionInput;
  where?: Maybe<UpsertItalianWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertJapaneseRandomQuestionArgs = {
  input: UpsertJapaneseRandomQuestionInput;
  where?: Maybe<UpsertJapaneseRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertJapaneseWouldYouRatherQuestionArgs = {
  input: UpsertJapaneseWouldYouRatherQuestionInput;
  where?: Maybe<UpsertJapaneseWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertKoreanRandomQuestionArgs = {
  input: UpsertKoreanRandomQuestionInput;
  where?: Maybe<UpsertKoreanRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertKoreanWouldYouRatherQuestionArgs = {
  input: UpsertKoreanWouldYouRatherQuestionInput;
  where?: Maybe<UpsertKoreanWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertLanguageArgs = {
  input: UpsertLanguageInput;
  where?: Maybe<UpsertLanguageWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertLanguageSkillLevelArgs = {
  input: UpsertLanguageSkillLevelInput;
  where?: Maybe<UpsertLanguageSkillLevelWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertMessageArgs = {
  input: UpsertMessageInput;
  where?: Maybe<UpsertMessageWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertMessagePreviewArgs = {
  input: UpsertMessagePreviewInput;
  where?: Maybe<UpsertMessagePreviewWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertNotificationArgs = {
  input: UpsertNotificationInput;
  where?: Maybe<UpsertNotificationWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertNotificationChannelArgs = {
  input: UpsertNotificationChannelInput;
  where?: Maybe<UpsertNotificationChannelWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPortugueseRandomQuestionArgs = {
  input: UpsertPortugueseRandomQuestionInput;
  where?: Maybe<UpsertPortugueseRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPortugueseWordArgs = {
  input: UpsertPortugueseWordInput;
  where?: Maybe<UpsertPortugueseWordWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPortugueseWouldYouRatherQuestionArgs = {
  input: UpsertPortugueseWouldYouRatherQuestionInput;
  where?: Maybe<UpsertPortugueseWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostArgs = {
  input: UpsertPostInput;
  where?: Maybe<UpsertPostWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostCorrectionArgs = {
  input: UpsertPostCorrectionInput;
  where?: Maybe<UpsertPostCorrectionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostGameArgs = {
  input: UpsertPostGameInput;
  where?: Maybe<UpsertPostGameWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostGameAnswerArgs = {
  input: UpsertPostGameAnswerInput;
  where?: Maybe<UpsertPostGameAnswerWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostGameRangeArgs = {
  input: UpsertPostGameRangeInput;
  where?: Maybe<UpsertPostGameRangeWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostLikeArgs = {
  input: UpsertPostLikeInput;
  where?: Maybe<UpsertPostLikeWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostRecordingArgs = {
  input: UpsertPostRecordingInput;
  where?: Maybe<UpsertPostRecordingWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPostUserMentionArgs = {
  input: UpsertPostUserMentionInput;
  where?: Maybe<UpsertPostUserMentionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPromptArgs = {
  input: UpsertPromptInput;
  where?: Maybe<UpsertPromptWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRussianRandomQuestionArgs = {
  input: UpsertRussianRandomQuestionInput;
  where?: Maybe<UpsertRussianRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRussianWordArgs = {
  input: UpsertRussianWordInput;
  where?: Maybe<UpsertRussianWordWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRussianWouldYouRatherQuestionArgs = {
  input: UpsertRussianWouldYouRatherQuestionInput;
  where?: Maybe<UpsertRussianWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertSpanishRandomQuestionArgs = {
  input: UpsertSpanishRandomQuestionInput;
  where?: Maybe<UpsertSpanishRandomQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertSpanishWordArgs = {
  input: UpsertSpanishWordInput;
  where?: Maybe<UpsertSpanishWordWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertSpanishWouldYouRatherQuestionArgs = {
  input: UpsertSpanishWouldYouRatherQuestionInput;
  where?: Maybe<UpsertSpanishWouldYouRatherQuestionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserArgs = {
  input: UpsertUserInput;
  where?: Maybe<UpsertUserWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserDeviceArgs = {
  input: UpsertUserDeviceInput;
  where?: Maybe<UpsertUserDeviceWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserFollowerArgs = {
  input: UpsertUserFollowerInput;
  where?: Maybe<UpsertUserFollowerWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserLanguageArgs = {
  input: UpsertUserLanguageInput;
  where?: Maybe<UpsertUserLanguageWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserPreferenceArgs = {
  input: UpsertUserPreferenceInput;
  where?: Maybe<UpsertUserPreferenceWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserSessionArgs = {
  input: UpsertUserSessionInput;
  where?: Maybe<UpsertUserSessionWhere>;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type Notification = Node & {
  __typename?: 'Notification';
  /** Reads a single `NotificationChannel` that is related to this `Notification`. */
  channel?: Maybe<NotificationChannel>;
  channelId: Scalars['Int'];
  createdAt: Scalars['Datetime'];
  expiresAt?: Maybe<Scalars['Datetime']>;
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  params?: Maybe<Scalars['JSON']>;
  readAt?: Maybe<Scalars['Datetime']>;
  /** Reads a single `User` that is related to this `Notification`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Notification`. */
  recipientGroup?: Maybe<Group>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  recipientId?: Maybe<Scalars['Int']>;
  sentAt?: Maybe<Scalars['Datetime']>;
  uuid: Scalars['UUID'];
  withheldUntil?: Maybe<Scalars['Datetime']>;
};

export type NotificationChannel = Node & {
  __typename?: 'NotificationChannel';
  createdAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `Group`. */
  groupsByNotificationChannelIdAndRecipientGroupId: NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdManyToManyConnection;
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByChannelId: NotificationsConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByNotificationChannelIdAndRecipientId: NotificationChannelUsersByNotificationChannelIdAndRecipientIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type NotificationChannelNotificationsByChannelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};


export type NotificationChannelUsersByNotificationChannelIdAndRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `NotificationChannel` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type NotificationChannelCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `NotificationChannel` object types. All fields are combined with a logical ‘and.’ */
export type NotificationChannelFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NotificationChannelFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Negates the expression. */
  not?: Maybe<NotificationChannelFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NotificationChannelFilter>>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** A connection to a list of `Group` values, with data from `Notification`. */
export type NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdManyToManyConnection = {
  __typename?: 'NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Notification`, and the cursor to aid in pagination. */
  edges: Array<NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Maybe<Group>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection, with data from `Notification`. */
export type NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdManyToManyEdge = {
  __typename?: 'NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Group` at the end of the edge. */
  node?: Maybe<Group>;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByRecipientGroupId: NotificationsConnection;
};


/** A `Group` edge in the connection, with data from `Notification`. */
export type NotificationChannelGroupsByNotificationChannelIdAndRecipientGroupIdManyToManyEdgeNotificationsByRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** An input for mutations affecting `NotificationChannel` */
export type NotificationChannelInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `NotificationChannel`. Fields that are set will be updated. */
export type NotificationChannelPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `User` values, with data from `Notification`. */
export type NotificationChannelUsersByNotificationChannelIdAndRecipientIdManyToManyConnection = {
  __typename?: 'NotificationChannelUsersByNotificationChannelIdAndRecipientIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Notification`, and the cursor to aid in pagination. */
  edges: Array<NotificationChannelUsersByNotificationChannelIdAndRecipientIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Notification`. */
export type NotificationChannelUsersByNotificationChannelIdAndRecipientIdManyToManyEdge = {
  __typename?: 'NotificationChannelUsersByNotificationChannelIdAndRecipientIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByRecipientId: NotificationsConnection;
};


/** A `User` edge in the connection, with data from `Notification`. */
export type NotificationChannelUsersByNotificationChannelIdAndRecipientIdManyToManyEdgeNotificationsByRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** A connection to a list of `NotificationChannel` values. */
export type NotificationChannelsConnection = {
  __typename?: 'NotificationChannelsConnection';
  /** A list of edges which contains the `NotificationChannel` and cursor to aid in pagination. */
  edges: Array<NotificationChannelsEdge>;
  /** A list of `NotificationChannel` objects. */
  nodes: Array<Maybe<NotificationChannel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NotificationChannel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `NotificationChannel` edge in the connection. */
export type NotificationChannelsEdge = {
  __typename?: 'NotificationChannelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `NotificationChannel` at the end of the edge. */
  node?: Maybe<NotificationChannel>;
};

/** Methods to use when ordering `NotificationChannel`. */
export enum NotificationChannelsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/**
 * A condition to be used against `Notification` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NotificationCondition = {
  /** Checks for equality with the object’s `channelId` field. */
  channelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `expiresAt` field. */
  expiresAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `params` field. */
  params?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `readAt` field. */
  readAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `recipientGroupId` field. */
  recipientGroupId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recipientId` field. */
  recipientId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sentAt` field. */
  sentAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `withheldUntil` field. */
  withheldUntil?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `Notification` object types. All fields are combined with a logical ‘and.’ */
export type NotificationFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NotificationFilter>>;
  /** Filter by the object’s `channelId` field. */
  channelId?: Maybe<IntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `expiresAt` field. */
  expiresAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<NotificationFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NotificationFilter>>;
  /** Filter by the object’s `readAt` field. */
  readAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `recipientGroupId` field. */
  recipientGroupId?: Maybe<IntFilter>;
  /** Filter by the object’s `recipientId` field. */
  recipientId?: Maybe<IntFilter>;
  /** Filter by the object’s `sentAt` field. */
  sentAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `withheldUntil` field. */
  withheldUntil?: Maybe<DatetimeFilter>;
};

/** An input for mutations affecting `Notification` */
export type NotificationInput = {
  channelId: Scalars['Int'];
  createdAt?: Maybe<Scalars['Datetime']>;
  expiresAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  params?: Maybe<Scalars['JSON']>;
  readAt?: Maybe<Scalars['Datetime']>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  recipientId?: Maybe<Scalars['Int']>;
  sentAt?: Maybe<Scalars['Datetime']>;
  uuid?: Maybe<Scalars['UUID']>;
  withheldUntil?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `Notification`. Fields that are set will be updated. */
export type NotificationPatch = {
  channelId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  expiresAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  params?: Maybe<Scalars['JSON']>;
  readAt?: Maybe<Scalars['Datetime']>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  recipientId?: Maybe<Scalars['Int']>;
  sentAt?: Maybe<Scalars['Datetime']>;
  uuid?: Maybe<Scalars['UUID']>;
  withheldUntil?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `Notification` values. */
export type NotificationsConnection = {
  __typename?: 'NotificationsConnection';
  /** A list of edges which contains the `Notification` and cursor to aid in pagination. */
  edges: Array<NotificationsEdge>;
  /** A list of `Notification` objects. */
  nodes: Array<Maybe<Notification>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Notification` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Notification` edge in the connection. */
export type NotificationsEdge = {
  __typename?: 'NotificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Notification` at the end of the edge. */
  node?: Maybe<Notification>;
};

/** Methods to use when ordering `Notification`. */
export enum NotificationsOrderBy {
  ChannelIdAsc = 'CHANNEL_ID_ASC',
  ChannelIdDesc = 'CHANNEL_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExpiresAtAsc = 'EXPIRES_AT_ASC',
  ExpiresAtDesc = 'EXPIRES_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ParamsAsc = 'PARAMS_ASC',
  ParamsDesc = 'PARAMS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReadAtAsc = 'READ_AT_ASC',
  ReadAtDesc = 'READ_AT_DESC',
  RecipientGroupIdAsc = 'RECIPIENT_GROUP_ID_ASC',
  RecipientGroupIdDesc = 'RECIPIENT_GROUP_ID_DESC',
  RecipientIdAsc = 'RECIPIENT_ID_ASC',
  RecipientIdDesc = 'RECIPIENT_ID_DESC',
  SentAtAsc = 'SENT_AT_ASC',
  SentAtDesc = 'SENT_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WithheldUntilAsc = 'WITHHELD_UNTIL_ASC',
  WithheldUntilDesc = 'WITHHELD_UNTIL_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type PortugueseRandomQuestion = Node & {
  __typename?: 'PortugueseRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `PortugueseRandomQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type PortugueseRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PortugueseRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type PortugueseRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PortugueseRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PortugueseRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PortugueseRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PortugueseRandomQuestion` */
export type PortugueseRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PortugueseRandomQuestion`. Fields that are set will be updated. */
export type PortugueseRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PortugueseRandomQuestion` values. */
export type PortugueseRandomQuestionsConnection = {
  __typename?: 'PortugueseRandomQuestionsConnection';
  /** A list of edges which contains the `PortugueseRandomQuestion` and cursor to aid in pagination. */
  edges: Array<PortugueseRandomQuestionsEdge>;
  /** A list of `PortugueseRandomQuestion` objects. */
  nodes: Array<Maybe<PortugueseRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PortugueseRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PortugueseRandomQuestion` edge in the connection. */
export type PortugueseRandomQuestionsEdge = {
  __typename?: 'PortugueseRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PortugueseRandomQuestion` at the end of the edge. */
  node?: Maybe<PortugueseRandomQuestion>;
};

/** Methods to use when ordering `PortugueseRandomQuestion`. */
export enum PortugueseRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type PortugueseWord = Node & {
  __typename?: 'PortugueseWord';
  createdAt: Scalars['Datetime'];
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id: Scalars['Int'];
  length?: Maybe<Scalars['Int']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  word: Scalars['String'];
};

/**
 * A condition to be used against `PortugueseWord` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PortugueseWordCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `word` field. */
  word?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PortugueseWord` object types. All fields are combined with a logical ‘and.’ */
export type PortugueseWordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PortugueseWordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `frequency` field. */
  frequency?: Maybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `length` field. */
  length?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PortugueseWordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PortugueseWordFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `word` field. */
  word?: Maybe<StringFilter>;
};

/** An input for mutations affecting `PortugueseWord` */
export type PortugueseWordInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word: Scalars['String'];
};

/** Represents an update to a `PortugueseWord`. Fields that are set will be updated. */
export type PortugueseWordPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PortugueseWord` values. */
export type PortugueseWordsConnection = {
  __typename?: 'PortugueseWordsConnection';
  /** A list of edges which contains the `PortugueseWord` and cursor to aid in pagination. */
  edges: Array<PortugueseWordsEdge>;
  /** A list of `PortugueseWord` objects. */
  nodes: Array<Maybe<PortugueseWord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PortugueseWord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PortugueseWord` edge in the connection. */
export type PortugueseWordsEdge = {
  __typename?: 'PortugueseWordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PortugueseWord` at the end of the edge. */
  node?: Maybe<PortugueseWord>;
};

/** Methods to use when ordering `PortugueseWord`. */
export enum PortugueseWordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FrequencyAsc = 'FREQUENCY_ASC',
  FrequencyDesc = 'FREQUENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WordAsc = 'WORD_ASC',
  WordDesc = 'WORD_DESC'
}

export type PortugueseWouldYouRatherQuestion = Node & {
  __typename?: 'PortugueseWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `PortugueseWouldYouRatherQuestion` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type PortugueseWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PortugueseWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type PortugueseWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PortugueseWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PortugueseWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PortugueseWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PortugueseWouldYouRatherQuestion` */
export type PortugueseWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PortugueseWouldYouRatherQuestion`. Fields that are set will be updated. */
export type PortugueseWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PortugueseWouldYouRatherQuestion` values. */
export type PortugueseWouldYouRatherQuestionsConnection = {
  __typename?: 'PortugueseWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `PortugueseWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<PortugueseWouldYouRatherQuestionsEdge>;
  /** A list of `PortugueseWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<PortugueseWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PortugueseWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PortugueseWouldYouRatherQuestion` edge in the connection. */
export type PortugueseWouldYouRatherQuestionsEdge = {
  __typename?: 'PortugueseWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PortugueseWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<PortugueseWouldYouRatherQuestion>;
};

/** Methods to use when ordering `PortugueseWouldYouRatherQuestion`. */
export enum PortugueseWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Post = Node & {
  __typename?: 'Post';
  /** Reads a single `User` that is related to this `Post`. */
  author?: Maybe<User>;
  authorId?: Maybe<Scalars['Int']>;
  body: Scalars['String'];
  /** Reads and enables pagination through a set of `PostCorrection`. */
  corrections: PostCorrectionsConnection;
  createdAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `PostGame`. */
  games: PostGamesConnection;
  id: Scalars['Int'];
  /** Reads a single `Language` that is related to this `Post`. */
  language?: Maybe<Language>;
  languageId: Scalars['Int'];
  /** Reads and enables pagination through a set of `Language`. */
  languagesByPostParentPostIdAndLanguageId: PostLanguagesByPostParentPostIdAndLanguageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PostLike`. */
  likes: PostLikesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Post` that is related to this `Post`. */
  parentPost?: Maybe<Post>;
  parentPostId?: Maybe<Scalars['Int']>;
  /** Reads a single `Prompt` that is related to this `Post`. */
  prompt?: Maybe<Prompt>;
  promptId?: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `Prompt`. */
  promptsByPostParentPostIdAndPromptId: PostPromptsByPostParentPostIdAndPromptIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PostRecording`. */
  recordings: PostRecordingsConnection;
  /** Reads and enables pagination through a set of `Post`. */
  replies: PostsConnection;
  snowflakeId: Scalars['BigInt'];
  /** Reads and enables pagination through a set of `PostUserMention`. */
  userMentions: PostUserMentionsConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostCorrectionPostIdAndUserId: PostUsersByPostCorrectionPostIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostLikePostIdAndUserId: PostUsersByPostLikePostIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostParentPostIdAndAuthorId: PostUsersByPostParentPostIdAndAuthorIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostRecordingPostIdAndUserId: PostUsersByPostRecordingPostIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostUserMentionPostIdAndUserId: PostUsersByPostUserMentionPostIdAndUserIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type PostCorrectionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCorrectionCondition>;
  filter?: Maybe<PostCorrectionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};


export type PostGamesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameCondition>;
  filter?: Maybe<PostGameFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};


export type PostLanguagesByPostParentPostIdAndLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type PostLikesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostLikeCondition>;
  filter?: Maybe<PostLikeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};


export type PostPromptsByPostParentPostIdAndPromptIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};


export type PostRecordingsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostRecordingCondition>;
  filter?: Maybe<PostRecordingFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};


export type PostRepliesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type PostUserMentionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostUserMentionCondition>;
  filter?: Maybe<PostUserMentionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};


export type PostUsersByPostCorrectionPostIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type PostUsersByPostLikePostIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type PostUsersByPostParentPostIdAndAuthorIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type PostUsersByPostRecordingPostIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type PostUsersByPostUserMentionPostIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PostCondition = {
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `languageId` field. */
  languageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `parentPostId` field. */
  parentPostId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `promptId` field. */
  promptId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `snowflakeId` field. */
  snowflakeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

export type PostCorrection = Node & {
  __typename?: 'PostCorrection';
  body: Scalars['String'];
  createdAt: Scalars['Datetime'];
  endIndex: Scalars['Int'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Post` that is related to this `PostCorrection`. */
  post?: Maybe<Post>;
  postId: Scalars['Int'];
  startIndex: Scalars['Int'];
  /** Reads a single `User` that is related to this `PostCorrection`. */
  user?: Maybe<User>;
  /** Author of the correction */
  userId: Scalars['Int'];
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `PostCorrection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PostCorrectionCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `endIndex` field. */
  endIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `postId` field. */
  postId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `startIndex` field. */
  startIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PostCorrection` object types. All fields are combined with a logical ‘and.’ */
export type PostCorrectionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostCorrectionFilter>>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `endIndex` field. */
  endIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostCorrectionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostCorrectionFilter>>;
  /** Filter by the object’s `postId` field. */
  postId?: Maybe<IntFilter>;
  /** Filter by the object’s `startIndex` field. */
  startIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PostCorrection` */
export type PostCorrectionInput = {
  body: Scalars['String'];
  createdAt?: Maybe<Scalars['Datetime']>;
  endIndex: Scalars['Int'];
  id?: Maybe<Scalars['Int']>;
  postId: Scalars['Int'];
  startIndex: Scalars['Int'];
  /** Author of the correction */
  userId: Scalars['Int'];
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PostCorrection`. Fields that are set will be updated. */
export type PostCorrectionPatch = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  endIndex?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  postId?: Maybe<Scalars['Int']>;
  startIndex?: Maybe<Scalars['Int']>;
  /** Author of the correction */
  userId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PostCorrection` values. */
export type PostCorrectionsConnection = {
  __typename?: 'PostCorrectionsConnection';
  /** A list of edges which contains the `PostCorrection` and cursor to aid in pagination. */
  edges: Array<PostCorrectionsEdge>;
  /** A list of `PostCorrection` objects. */
  nodes: Array<Maybe<PostCorrection>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostCorrection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostCorrection` edge in the connection. */
export type PostCorrectionsEdge = {
  __typename?: 'PostCorrectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostCorrection` at the end of the edge. */
  node?: Maybe<PostCorrection>;
};

/** Methods to use when ordering `PostCorrection`. */
export enum PostCorrectionsOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EndIndexAsc = 'END_INDEX_ASC',
  EndIndexDesc = 'END_INDEX_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PostIdAsc = 'POST_ID_ASC',
  PostIdDesc = 'POST_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StartIndexAsc = 'START_INDEX_ASC',
  StartIndexDesc = 'START_INDEX_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against `Post` object types. All fields are combined with a logical ‘and.’ */
export type PostFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostFilter>>;
  /** Filter by the object’s `authorId` field. */
  authorId?: Maybe<IntFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `languageId` field. */
  languageId?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostFilter>>;
  /** Filter by the object’s `parentPostId` field. */
  parentPostId?: Maybe<IntFilter>;
  /** Filter by the object’s `promptId` field. */
  promptId?: Maybe<IntFilter>;
  /** Filter by the object’s `snowflakeId` field. */
  snowflakeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

export type PostGame = Node & {
  __typename?: 'PostGame';
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  answerReveals: PostGameAnswersConnection;
  /** Reads and enables pagination through a set of `User`. */
  answerers: UsersConnection;
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  answersByCurrentUser: PostGameAnswersConnection;
  correctAnswers: PostGamesCorrectAnswersConnection;
  createdAt: Scalars['Datetime'];
  currentUserCanSeeCorrectAnswers?: Maybe<Scalars['Boolean']>;
  gameType: PostGameType;
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Post` that is related to this `PostGame`. */
  post?: Maybe<Post>;
  /** Reads and enables pagination through a set of `PostGameRange`. */
  postGameRangesByPostGameAnswerGameIdAndRangeId: PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdManyToManyConnection;
  postId: Scalars['Int'];
  /** Reads and enables pagination through a set of `PostGameRange`. */
  ranges: PostGameRangesConnection;
  revealedByCurrentUser?: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostGameAnswerGameIdAndUserId: PostGameUsersByPostGameAnswerGameIdAndUserIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type PostGameAnswerRevealsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};


export type PostGameAnswerersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


export type PostGameAnswersByCurrentUserArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


export type PostGameCorrectAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PostGamesCorrectAnswersRecordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


export type PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameRangeCondition>;
  filter?: Maybe<PostGameRangeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};


export type PostGameRangesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameRangeCondition>;
  filter?: Maybe<PostGameRangeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};


export type PostGameUsersByPostGameAnswerGameIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

export type PostGameAnswer = Node & {
  __typename?: 'PostGameAnswer';
  caseOption?: Maybe<GrammaticalCase>;
  clozeAnswer?: Maybe<Scalars['String']>;
  correct?: Maybe<Scalars['Boolean']>;
  createdAt: Scalars['Datetime'];
  /** Reads a single `PostGame` that is related to this `PostGameAnswer`. */
  game?: Maybe<PostGame>;
  gameId?: Maybe<Scalars['Int']>;
  genderOption?: Maybe<GrammaticalGender>;
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `PostGameRange` that is related to this `PostGameAnswer`. */
  range?: Maybe<PostGameRange>;
  rangeId?: Maybe<Scalars['Int']>;
  /** Reads a single `User` that is related to this `PostGameAnswer`. */
  user?: Maybe<User>;
  userId: Scalars['Int'];
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `PostGameAnswer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PostGameAnswerCondition = {
  /** Checks for equality with the object’s `caseOption` field. */
  caseOption?: Maybe<GrammaticalCase>;
  /** Checks for equality with the object’s `clozeAnswer` field. */
  clozeAnswer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `correct` field. */
  correct?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `genderOption` field. */
  genderOption?: Maybe<GrammaticalGender>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rangeId` field. */
  rangeId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PostGameAnswer` object types. All fields are combined with a logical ‘and.’ */
export type PostGameAnswerFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostGameAnswerFilter>>;
  /** Filter by the object’s `caseOption` field. */
  caseOption?: Maybe<GrammaticalCaseFilter>;
  /** Filter by the object’s `clozeAnswer` field. */
  clozeAnswer?: Maybe<StringFilter>;
  /** Filter by the object’s `correct` field. */
  correct?: Maybe<BooleanFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<IntFilter>;
  /** Filter by the object’s `genderOption` field. */
  genderOption?: Maybe<GrammaticalGenderFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostGameAnswerFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostGameAnswerFilter>>;
  /** Filter by the object’s `rangeId` field. */
  rangeId?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PostGameAnswer` */
export type PostGameAnswerInput = {
  caseOption?: Maybe<GrammaticalCase>;
  clozeAnswer?: Maybe<Scalars['String']>;
  correct?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  gameId?: Maybe<Scalars['Int']>;
  genderOption?: Maybe<GrammaticalGender>;
  id?: Maybe<Scalars['Int']>;
  rangeId?: Maybe<Scalars['Int']>;
  userId: Scalars['Int'];
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PostGameAnswer`. Fields that are set will be updated. */
export type PostGameAnswerPatch = {
  caseOption?: Maybe<GrammaticalCase>;
  clozeAnswer?: Maybe<Scalars['String']>;
  correct?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  gameId?: Maybe<Scalars['Int']>;
  genderOption?: Maybe<GrammaticalGender>;
  id?: Maybe<Scalars['Int']>;
  rangeId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PostGameAnswer` values. */
export type PostGameAnswersConnection = {
  __typename?: 'PostGameAnswersConnection';
  /** A list of edges which contains the `PostGameAnswer` and cursor to aid in pagination. */
  edges: Array<PostGameAnswersEdge>;
  /** A list of `PostGameAnswer` objects. */
  nodes: Array<Maybe<PostGameAnswer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostGameAnswer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostGameAnswer` edge in the connection. */
export type PostGameAnswersEdge = {
  __typename?: 'PostGameAnswersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGameAnswer` at the end of the edge. */
  node?: Maybe<PostGameAnswer>;
};

/** Methods to use when ordering `PostGameAnswer`. */
export enum PostGameAnswersOrderBy {
  CaseOptionAsc = 'CASE_OPTION_ASC',
  CaseOptionDesc = 'CASE_OPTION_DESC',
  ClozeAnswerAsc = 'CLOZE_ANSWER_ASC',
  ClozeAnswerDesc = 'CLOZE_ANSWER_DESC',
  CorrectAsc = 'CORRECT_ASC',
  CorrectDesc = 'CORRECT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  GameIdAsc = 'GAME_ID_ASC',
  GameIdDesc = 'GAME_ID_DESC',
  GenderOptionAsc = 'GENDER_OPTION_ASC',
  GenderOptionDesc = 'GENDER_OPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RangeIdAsc = 'RANGE_ID_ASC',
  RangeIdDesc = 'RANGE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/**
 * A condition to be used against `PostGame` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PostGameCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `gameType` field. */
  gameType?: Maybe<PostGameType>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `postId` field. */
  postId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PostGame` object types. All fields are combined with a logical ‘and.’ */
export type PostGameFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostGameFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `currentUserCanSeeCorrectAnswers` field. */
  currentUserCanSeeCorrectAnswers?: Maybe<BooleanFilter>;
  /** Filter by the object’s `gameType` field. */
  gameType?: Maybe<PostGameTypeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostGameFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostGameFilter>>;
  /** Filter by the object’s `postId` field. */
  postId?: Maybe<IntFilter>;
  /** Filter by the object’s `revealedByCurrentUser` field. */
  revealedByCurrentUser?: Maybe<BooleanFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PostGame` */
export type PostGameInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  gameType: PostGameType;
  id?: Maybe<Scalars['Int']>;
  postId: Scalars['Int'];
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PostGame`. Fields that are set will be updated. */
export type PostGamePatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  gameType?: Maybe<PostGameType>;
  id?: Maybe<Scalars['Int']>;
  postId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PostGameRange` values, with data from `PostGameAnswer`. */
export type PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdManyToManyConnection = {
  __typename?: 'PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdManyToManyConnection';
  /** A list of edges which contains the `PostGameRange`, info from the `PostGameAnswer`, and the cursor to aid in pagination. */
  edges: Array<PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdManyToManyEdge>;
  /** A list of `PostGameRange` objects. */
  nodes: Array<Maybe<PostGameRange>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostGameRange` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostGameRange` edge in the connection, with data from `PostGameAnswer`. */
export type PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdManyToManyEdge = {
  __typename?: 'PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdManyToManyEdge';
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  answers: PostGameAnswersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGameRange` at the end of the edge. */
  node?: Maybe<PostGameRange>;
};


/** A `PostGameRange` edge in the connection, with data from `PostGameAnswer`. */
export type PostGamePostGameRangesByPostGameAnswerGameIdAndRangeIdManyToManyEdgeAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

export type PostGameRange = Node & {
  __typename?: 'PostGameRange';
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  answers: PostGameAnswersConnection;
  /** Case as chosen by the post creator */
  caseOption?: Maybe<GrammaticalCase>;
  createdAt: Scalars['Datetime'];
  endIndex: Scalars['Int'];
  /** Reads a single `PostGame` that is related to this `PostGameRange`. */
  game?: Maybe<PostGame>;
  gameId: Scalars['Int'];
  /** Gender as chosen by the post creator */
  genderOption?: Maybe<GrammaticalGender>;
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `PostGame`. */
  postGamesByPostGameAnswerRangeIdAndGameId: PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdManyToManyConnection;
  startIndex: Scalars['Int'];
  /** Reads and enables pagination through a set of `User`. */
  usersByPostGameAnswerRangeIdAndUserId: PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type PostGameRangeAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};


export type PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameCondition>;
  filter?: Maybe<PostGameFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};


export type PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `PostGameRange` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PostGameRangeCondition = {
  /** Checks for equality with the object’s `caseOption` field. */
  caseOption?: Maybe<GrammaticalCase>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `endIndex` field. */
  endIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `genderOption` field. */
  genderOption?: Maybe<GrammaticalGender>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `startIndex` field. */
  startIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PostGameRange` object types. All fields are combined with a logical ‘and.’ */
export type PostGameRangeFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostGameRangeFilter>>;
  /** Filter by the object’s `caseOption` field. */
  caseOption?: Maybe<GrammaticalCaseFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `endIndex` field. */
  endIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<IntFilter>;
  /** Filter by the object’s `genderOption` field. */
  genderOption?: Maybe<GrammaticalGenderFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostGameRangeFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostGameRangeFilter>>;
  /** Filter by the object’s `startIndex` field. */
  startIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PostGameRange` */
export type PostGameRangeInput = {
  /** Case as chosen by the post creator */
  caseOption?: Maybe<GrammaticalCase>;
  createdAt?: Maybe<Scalars['Datetime']>;
  endIndex: Scalars['Int'];
  gameId: Scalars['Int'];
  /** Gender as chosen by the post creator */
  genderOption?: Maybe<GrammaticalGender>;
  id?: Maybe<Scalars['Int']>;
  startIndex: Scalars['Int'];
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PostGameRange`. Fields that are set will be updated. */
export type PostGameRangePatch = {
  /** Case as chosen by the post creator */
  caseOption?: Maybe<GrammaticalCase>;
  createdAt?: Maybe<Scalars['Datetime']>;
  endIndex?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  /** Gender as chosen by the post creator */
  genderOption?: Maybe<GrammaticalGender>;
  id?: Maybe<Scalars['Int']>;
  startIndex?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PostGame` values, with data from `PostGameAnswer`. */
export type PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdManyToManyConnection = {
  __typename?: 'PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdManyToManyConnection';
  /** A list of edges which contains the `PostGame`, info from the `PostGameAnswer`, and the cursor to aid in pagination. */
  edges: Array<PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdManyToManyEdge>;
  /** A list of `PostGame` objects. */
  nodes: Array<Maybe<PostGame>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostGame` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostGame` edge in the connection, with data from `PostGameAnswer`. */
export type PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdManyToManyEdge = {
  __typename?: 'PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdManyToManyEdge';
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  answerReveals: PostGameAnswersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGame` at the end of the edge. */
  node?: Maybe<PostGame>;
};


/** A `PostGame` edge in the connection, with data from `PostGameAnswer`. */
export type PostGameRangePostGamesByPostGameAnswerRangeIdAndGameIdManyToManyEdgeAnswerRevealsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `PostGameAnswer`. */
export type PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdManyToManyConnection = {
  __typename?: 'PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `PostGameAnswer`, and the cursor to aid in pagination. */
  edges: Array<PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `PostGameAnswer`. */
export type PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdManyToManyEdge = {
  __typename?: 'PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  postGameAnswers: PostGameAnswersConnection;
};


/** A `User` edge in the connection, with data from `PostGameAnswer`. */
export type PostGameRangeUsersByPostGameAnswerRangeIdAndUserIdManyToManyEdgePostGameAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** A connection to a list of `PostGameRange` values. */
export type PostGameRangesConnection = {
  __typename?: 'PostGameRangesConnection';
  /** A list of edges which contains the `PostGameRange` and cursor to aid in pagination. */
  edges: Array<PostGameRangesEdge>;
  /** A list of `PostGameRange` objects. */
  nodes: Array<Maybe<PostGameRange>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostGameRange` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostGameRange` edge in the connection. */
export type PostGameRangesEdge = {
  __typename?: 'PostGameRangesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGameRange` at the end of the edge. */
  node?: Maybe<PostGameRange>;
};

/** Methods to use when ordering `PostGameRange`. */
export enum PostGameRangesOrderBy {
  CaseOptionAsc = 'CASE_OPTION_ASC',
  CaseOptionDesc = 'CASE_OPTION_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EndIndexAsc = 'END_INDEX_ASC',
  EndIndexDesc = 'END_INDEX_DESC',
  GameIdAsc = 'GAME_ID_ASC',
  GameIdDesc = 'GAME_ID_DESC',
  GenderOptionAsc = 'GENDER_OPTION_ASC',
  GenderOptionDesc = 'GENDER_OPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StartIndexAsc = 'START_INDEX_ASC',
  StartIndexDesc = 'START_INDEX_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export enum PostGameType {
  Cloze = 'CLOZE',
  GuessCase = 'GUESS_CASE',
  GuessGender = 'GUESS_GENDER'
}

/** A filter to be used against PostGameType fields. All fields are combined with a logical ‘and.’ */
export type PostGameTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<PostGameType>;
  /** Equal to the specified value. */
  equalTo?: Maybe<PostGameType>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<PostGameType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<PostGameType>;
  /** Included in the specified list. */
  in?: Maybe<Array<PostGameType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<PostGameType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<PostGameType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<PostGameType>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<PostGameType>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<PostGameType>>;
};

/** A connection to a list of `User` values, with data from `PostGameAnswer`. */
export type PostGameUsersByPostGameAnswerGameIdAndUserIdManyToManyConnection = {
  __typename?: 'PostGameUsersByPostGameAnswerGameIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `PostGameAnswer`, and the cursor to aid in pagination. */
  edges: Array<PostGameUsersByPostGameAnswerGameIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `PostGameAnswer`. */
export type PostGameUsersByPostGameAnswerGameIdAndUserIdManyToManyEdge = {
  __typename?: 'PostGameUsersByPostGameAnswerGameIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  postGameAnswers: PostGameAnswersConnection;
};


/** A `User` edge in the connection, with data from `PostGameAnswer`. */
export type PostGameUsersByPostGameAnswerGameIdAndUserIdManyToManyEdgePostGameAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** A connection to a list of `PostGame` values. */
export type PostGamesConnection = {
  __typename?: 'PostGamesConnection';
  /** A list of edges which contains the `PostGame` and cursor to aid in pagination. */
  edges: Array<PostGamesEdge>;
  /** A list of `PostGame` objects. */
  nodes: Array<Maybe<PostGame>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostGame` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostGamesCorrectAnswersRecord` edge in the connection. */
export type PostGamesCorrectAnswerEdge = {
  __typename?: 'PostGamesCorrectAnswerEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGamesCorrectAnswersRecord` at the end of the edge. */
  node?: Maybe<PostGamesCorrectAnswersRecord>;
};

/** A connection to a list of `PostGamesCorrectAnswersRecord` values. */
export type PostGamesCorrectAnswersConnection = {
  __typename?: 'PostGamesCorrectAnswersConnection';
  /** A list of edges which contains the `PostGamesCorrectAnswersRecord` and cursor to aid in pagination. */
  edges: Array<PostGamesCorrectAnswerEdge>;
  /** A list of `PostGamesCorrectAnswersRecord` objects. */
  nodes: Array<Maybe<PostGamesCorrectAnswersRecord>>;
  /** The count of *all* `PostGamesCorrectAnswersRecord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** The return type of our `correctAnswers` query. */
export type PostGamesCorrectAnswersRecord = {
  __typename?: 'PostGamesCorrectAnswersRecord';
  caseOption?: Maybe<GrammaticalCase>;
  clozeAnswer?: Maybe<Scalars['String']>;
  genderOption?: Maybe<GrammaticalGender>;
  rangeUuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PostGamesCorrectAnswersRecord` object types. All fields are combined with a logical ‘and.’ */
export type PostGamesCorrectAnswersRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostGamesCorrectAnswersRecordFilter>>;
  /** Filter by the object’s `caseOption` field. */
  caseOption?: Maybe<GrammaticalCaseFilter>;
  /** Filter by the object’s `clozeAnswer` field. */
  clozeAnswer?: Maybe<StringFilter>;
  /** Filter by the object’s `genderOption` field. */
  genderOption?: Maybe<GrammaticalGenderFilter>;
  /** Negates the expression. */
  not?: Maybe<PostGamesCorrectAnswersRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostGamesCorrectAnswersRecordFilter>>;
  /** Filter by the object’s `rangeUuid` field. */
  rangeUuid?: Maybe<UuidFilter>;
};

/** A `PostGame` edge in the connection. */
export type PostGamesEdge = {
  __typename?: 'PostGamesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGame` at the end of the edge. */
  node?: Maybe<PostGame>;
};

/** Methods to use when ordering `PostGame`. */
export enum PostGamesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  GameTypeAsc = 'GAME_TYPE_ASC',
  GameTypeDesc = 'GAME_TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PostIdAsc = 'POST_ID_ASC',
  PostIdDesc = 'POST_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** An input for mutations affecting `Post` */
export type PostInput = {
  authorId?: Maybe<Scalars['Int']>;
  body: Scalars['String'];
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  languageId: Scalars['Int'];
  parentPostId?: Maybe<Scalars['Int']>;
  promptId?: Maybe<Scalars['Int']>;
  snowflakeId?: Maybe<Scalars['BigInt']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Language` values, with data from `Post`. */
export type PostLanguagesByPostParentPostIdAndLanguageIdManyToManyConnection = {
  __typename?: 'PostLanguagesByPostParentPostIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<PostLanguagesByPostParentPostIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `Post`. */
export type PostLanguagesByPostParentPostIdAndLanguageIdManyToManyEdge = {
  __typename?: 'PostLanguagesByPostParentPostIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
};


/** A `Language` edge in the connection, with data from `Post`. */
export type PostLanguagesByPostParentPostIdAndLanguageIdManyToManyEdgePostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

export type PostLike = Node & {
  __typename?: 'PostLike';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Post` that is related to this `PostLike`. */
  post?: Maybe<Post>;
  postId: Scalars['Int'];
  /** Reads a single `User` that is related to this `PostLike`. */
  user?: Maybe<User>;
  userId: Scalars['Int'];
};

/**
 * A condition to be used against `PostLike` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PostLikeCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `postId` field. */
  postId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `PostLike` object types. All fields are combined with a logical ‘and.’ */
export type PostLikeFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostLikeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostLikeFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostLikeFilter>>;
  /** Filter by the object’s `postId` field. */
  postId?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
};

/** An input for mutations affecting `PostLike` */
export type PostLikeInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  postId: Scalars['Int'];
  userId: Scalars['Int'];
};

/** Represents an update to a `PostLike`. Fields that are set will be updated. */
export type PostLikePatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  postId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `PostLike` values. */
export type PostLikesConnection = {
  __typename?: 'PostLikesConnection';
  /** A list of edges which contains the `PostLike` and cursor to aid in pagination. */
  edges: Array<PostLikesEdge>;
  /** A list of `PostLike` objects. */
  nodes: Array<Maybe<PostLike>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostLike` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostLike` edge in the connection. */
export type PostLikesEdge = {
  __typename?: 'PostLikesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostLike` at the end of the edge. */
  node?: Maybe<PostLike>;
};

/** Methods to use when ordering `PostLike`. */
export enum PostLikesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PostIdAsc = 'POST_ID_ASC',
  PostIdDesc = 'POST_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Represents an update to a `Post`. Fields that are set will be updated. */
export type PostPatch = {
  authorId?: Maybe<Scalars['Int']>;
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  languageId?: Maybe<Scalars['Int']>;
  parentPostId?: Maybe<Scalars['Int']>;
  promptId?: Maybe<Scalars['Int']>;
  snowflakeId?: Maybe<Scalars['BigInt']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Prompt` values, with data from `Post`. */
export type PostPromptsByPostParentPostIdAndPromptIdManyToManyConnection = {
  __typename?: 'PostPromptsByPostParentPostIdAndPromptIdManyToManyConnection';
  /** A list of edges which contains the `Prompt`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<PostPromptsByPostParentPostIdAndPromptIdManyToManyEdge>;
  /** A list of `Prompt` objects. */
  nodes: Array<Maybe<Prompt>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Prompt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Prompt` edge in the connection, with data from `Post`. */
export type PostPromptsByPostParentPostIdAndPromptIdManyToManyEdge = {
  __typename?: 'PostPromptsByPostParentPostIdAndPromptIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Prompt` at the end of the edge. */
  node?: Maybe<Prompt>;
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
};


/** A `Prompt` edge in the connection, with data from `Post`. */
export type PostPromptsByPostParentPostIdAndPromptIdManyToManyEdgePostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

export type PostRecording = Node & {
  __typename?: 'PostRecording';
  createdAt: Scalars['Datetime'];
  /** Extension without leading dot */
  extension?: Maybe<Scalars['String']>;
  /** Basename without extension */
  filename: Scalars['String'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Post` that is related to this `PostRecording`. */
  post?: Maybe<Post>;
  postId: Scalars['Int'];
  /** Reads a single `User` that is related to this `PostRecording`. */
  user?: Maybe<User>;
  userId: Scalars['Int'];
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `PostRecording` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PostRecordingCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `extension` field. */
  extension?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `postId` field. */
  postId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PostRecording` object types. All fields are combined with a logical ‘and.’ */
export type PostRecordingFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostRecordingFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `extension` field. */
  extension?: Maybe<StringFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostRecordingFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostRecordingFilter>>;
  /** Filter by the object’s `postId` field. */
  postId?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PostRecording` */
export type PostRecordingInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Extension without leading dot */
  extension?: Maybe<Scalars['String']>;
  /** Basename without extension */
  filename: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  postId: Scalars['Int'];
  userId: Scalars['Int'];
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PostRecording`. Fields that are set will be updated. */
export type PostRecordingPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Extension without leading dot */
  extension?: Maybe<Scalars['String']>;
  /** Basename without extension */
  filename?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  postId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PostRecording` values. */
export type PostRecordingsConnection = {
  __typename?: 'PostRecordingsConnection';
  /** A list of edges which contains the `PostRecording` and cursor to aid in pagination. */
  edges: Array<PostRecordingsEdge>;
  /** A list of `PostRecording` objects. */
  nodes: Array<Maybe<PostRecording>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostRecording` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostRecording` edge in the connection. */
export type PostRecordingsEdge = {
  __typename?: 'PostRecordingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostRecording` at the end of the edge. */
  node?: Maybe<PostRecording>;
};

/** Methods to use when ordering `PostRecording`. */
export enum PostRecordingsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExtensionAsc = 'EXTENSION_ASC',
  ExtensionDesc = 'EXTENSION_DESC',
  FilenameAsc = 'FILENAME_ASC',
  FilenameDesc = 'FILENAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PostIdAsc = 'POST_ID_ASC',
  PostIdDesc = 'POST_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type PostUserMention = Node & {
  __typename?: 'PostUserMention';
  createdAt: Scalars['Datetime'];
  endIndex: Scalars['Int'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `Post` that is related to this `PostUserMention`. */
  post?: Maybe<Post>;
  postId: Scalars['Int'];
  startIndex: Scalars['Int'];
  /** Reads a single `User` that is related to this `PostUserMention`. */
  user?: Maybe<User>;
  /** Mentioned user */
  userId: Scalars['Int'];
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `PostUserMention` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PostUserMentionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `endIndex` field. */
  endIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `postId` field. */
  postId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `startIndex` field. */
  startIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PostUserMention` object types. All fields are combined with a logical ‘and.’ */
export type PostUserMentionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PostUserMentionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `endIndex` field. */
  endIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PostUserMentionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PostUserMentionFilter>>;
  /** Filter by the object’s `postId` field. */
  postId?: Maybe<IntFilter>;
  /** Filter by the object’s `startIndex` field. */
  startIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `PostUserMention` */
export type PostUserMentionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  endIndex: Scalars['Int'];
  id?: Maybe<Scalars['Int']>;
  postId: Scalars['Int'];
  startIndex: Scalars['Int'];
  /** Mentioned user */
  userId: Scalars['Int'];
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `PostUserMention`. Fields that are set will be updated. */
export type PostUserMentionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  endIndex?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  postId?: Maybe<Scalars['Int']>;
  startIndex?: Maybe<Scalars['Int']>;
  /** Mentioned user */
  userId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PostUserMention` values. */
export type PostUserMentionsConnection = {
  __typename?: 'PostUserMentionsConnection';
  /** A list of edges which contains the `PostUserMention` and cursor to aid in pagination. */
  edges: Array<PostUserMentionsEdge>;
  /** A list of `PostUserMention` objects. */
  nodes: Array<Maybe<PostUserMention>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostUserMention` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostUserMention` edge in the connection. */
export type PostUserMentionsEdge = {
  __typename?: 'PostUserMentionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostUserMention` at the end of the edge. */
  node?: Maybe<PostUserMention>;
};

/** Methods to use when ordering `PostUserMention`. */
export enum PostUserMentionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EndIndexAsc = 'END_INDEX_ASC',
  EndIndexDesc = 'END_INDEX_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PostIdAsc = 'POST_ID_ASC',
  PostIdDesc = 'POST_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StartIndexAsc = 'START_INDEX_ASC',
  StartIndexDesc = 'START_INDEX_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A connection to a list of `User` values, with data from `PostCorrection`. */
export type PostUsersByPostCorrectionPostIdAndUserIdManyToManyConnection = {
  __typename?: 'PostUsersByPostCorrectionPostIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `PostCorrection`, and the cursor to aid in pagination. */
  edges: Array<PostUsersByPostCorrectionPostIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `PostCorrection`. */
export type PostUsersByPostCorrectionPostIdAndUserIdManyToManyEdge = {
  __typename?: 'PostUsersByPostCorrectionPostIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `PostCorrection`. */
  postCorrections: PostCorrectionsConnection;
};


/** A `User` edge in the connection, with data from `PostCorrection`. */
export type PostUsersByPostCorrectionPostIdAndUserIdManyToManyEdgePostCorrectionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCorrectionCondition>;
  filter?: Maybe<PostCorrectionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `PostLike`. */
export type PostUsersByPostLikePostIdAndUserIdManyToManyConnection = {
  __typename?: 'PostUsersByPostLikePostIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `PostLike`, and the cursor to aid in pagination. */
  edges: Array<PostUsersByPostLikePostIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `PostLike`. */
export type PostUsersByPostLikePostIdAndUserIdManyToManyEdge = {
  __typename?: 'PostUsersByPostLikePostIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `PostLike`. */
  postLikes: PostLikesConnection;
};


/** A `User` edge in the connection, with data from `PostLike`. */
export type PostUsersByPostLikePostIdAndUserIdManyToManyEdgePostLikesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostLikeCondition>;
  filter?: Maybe<PostLikeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Post`. */
export type PostUsersByPostParentPostIdAndAuthorIdManyToManyConnection = {
  __typename?: 'PostUsersByPostParentPostIdAndAuthorIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<PostUsersByPostParentPostIdAndAuthorIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Post`. */
export type PostUsersByPostParentPostIdAndAuthorIdManyToManyEdge = {
  __typename?: 'PostUsersByPostParentPostIdAndAuthorIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Post`. */
  authoredPosts: PostsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Post`. */
export type PostUsersByPostParentPostIdAndAuthorIdManyToManyEdgeAuthoredPostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `PostRecording`. */
export type PostUsersByPostRecordingPostIdAndUserIdManyToManyConnection = {
  __typename?: 'PostUsersByPostRecordingPostIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `PostRecording`, and the cursor to aid in pagination. */
  edges: Array<PostUsersByPostRecordingPostIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `PostRecording`. */
export type PostUsersByPostRecordingPostIdAndUserIdManyToManyEdge = {
  __typename?: 'PostUsersByPostRecordingPostIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `PostRecording`. */
  postRecordings: PostRecordingsConnection;
};


/** A `User` edge in the connection, with data from `PostRecording`. */
export type PostUsersByPostRecordingPostIdAndUserIdManyToManyEdgePostRecordingsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostRecordingCondition>;
  filter?: Maybe<PostRecordingFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `PostUserMention`. */
export type PostUsersByPostUserMentionPostIdAndUserIdManyToManyConnection = {
  __typename?: 'PostUsersByPostUserMentionPostIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `PostUserMention`, and the cursor to aid in pagination. */
  edges: Array<PostUsersByPostUserMentionPostIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `PostUserMention`. */
export type PostUsersByPostUserMentionPostIdAndUserIdManyToManyEdge = {
  __typename?: 'PostUsersByPostUserMentionPostIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
  /** Reads and enables pagination through a set of `PostUserMention`. */
  postUserMentions: PostUserMentionsConnection;
};


/** A `User` edge in the connection, with data from `PostUserMention`. */
export type PostUsersByPostUserMentionPostIdAndUserIdManyToManyEdgePostUserMentionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostUserMentionCondition>;
  filter?: Maybe<PostUserMentionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};

/** A connection to a list of `Post` values. */
export type PostsConnection = {
  __typename?: 'PostsConnection';
  /** A list of edges which contains the `Post` and cursor to aid in pagination. */
  edges: Array<PostsEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection. */
export type PostsEdge = {
  __typename?: 'PostsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
};

/** Methods to use when ordering `Post`. */
export enum PostsOrderBy {
  AuthorIdAsc = 'AUTHOR_ID_ASC',
  AuthorIdDesc = 'AUTHOR_ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LanguageIdAsc = 'LANGUAGE_ID_ASC',
  LanguageIdDesc = 'LANGUAGE_ID_DESC',
  Natural = 'NATURAL',
  ParentPostIdAsc = 'PARENT_POST_ID_ASC',
  ParentPostIdDesc = 'PARENT_POST_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PromptIdAsc = 'PROMPT_ID_ASC',
  PromptIdDesc = 'PROMPT_ID_DESC',
  SnowflakeIdAsc = 'SNOWFLAKE_ID_ASC',
  SnowflakeIdDesc = 'SNOWFLAKE_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Prompt = Node & {
  __typename?: 'Prompt';
  content?: Maybe<Scalars['String']>;
  contentDe?: Maybe<Scalars['String']>;
  contentEn?: Maybe<Scalars['String']>;
  contentEs?: Maybe<Scalars['String']>;
  contentFr?: Maybe<Scalars['String']>;
  contentIt?: Maybe<Scalars['String']>;
  contentJa?: Maybe<Scalars['String']>;
  contentKo?: Maybe<Scalars['String']>;
  contentPt?: Maybe<Scalars['String']>;
  contentRu?: Maybe<Scalars['String']>;
  contentZh?: Maybe<Scalars['String']>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** Reads a single `Language` that is related to this `Prompt`. */
  language?: Maybe<Language>;
  languageId: Scalars['Int'];
  /** Reads and enables pagination through a set of `Language`. */
  languagesByPostPromptIdAndLanguageId: PromptLanguagesByPostPromptIdAndLanguageIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
  /** Reads and enables pagination through a set of `Post`. */
  postsByPostPromptIdAndParentPostId: PromptPostsByPostPromptIdAndParentPostIdManyToManyConnection;
  /** Reads a single `LanguageSkillLevel` that is related to this `Prompt`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  type: PromptType;
  /** Reads and enables pagination through a set of `User`. */
  usersByPostPromptIdAndAuthorId: PromptUsersByPostPromptIdAndAuthorIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type PromptLanguagesByPostPromptIdAndLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type PromptPostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type PromptPostsByPostPromptIdAndParentPostIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type PromptUsersByPostPromptIdAndAuthorIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Prompt` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PromptCondition = {
  /** Checks for equality with the object’s `contentDe` field. */
  contentDe?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentEn` field. */
  contentEn?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentEs` field. */
  contentEs?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentFr` field. */
  contentFr?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentIt` field. */
  contentIt?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentJa` field. */
  contentJa?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentKo` field. */
  contentKo?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentPt` field. */
  contentPt?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentRu` field. */
  contentRu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contentZh` field. */
  contentZh?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `languageId` field. */
  languageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<PromptType>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `Prompt` object types. All fields are combined with a logical ‘and.’ */
export type PromptFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PromptFilter>>;
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `contentDe` field. */
  contentDe?: Maybe<StringFilter>;
  /** Filter by the object’s `contentEn` field. */
  contentEn?: Maybe<StringFilter>;
  /** Filter by the object’s `contentEs` field. */
  contentEs?: Maybe<StringFilter>;
  /** Filter by the object’s `contentFr` field. */
  contentFr?: Maybe<StringFilter>;
  /** Filter by the object’s `contentIt` field. */
  contentIt?: Maybe<StringFilter>;
  /** Filter by the object’s `contentJa` field. */
  contentJa?: Maybe<StringFilter>;
  /** Filter by the object’s `contentKo` field. */
  contentKo?: Maybe<StringFilter>;
  /** Filter by the object’s `contentPt` field. */
  contentPt?: Maybe<StringFilter>;
  /** Filter by the object’s `contentRu` field. */
  contentRu?: Maybe<StringFilter>;
  /** Filter by the object’s `contentZh` field. */
  contentZh?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `languageId` field. */
  languageId?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<PromptFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PromptFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<PromptTypeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `Prompt` */
export type PromptInput = {
  contentDe?: Maybe<Scalars['String']>;
  contentEn?: Maybe<Scalars['String']>;
  contentEs?: Maybe<Scalars['String']>;
  contentFr?: Maybe<Scalars['String']>;
  contentIt?: Maybe<Scalars['String']>;
  contentJa?: Maybe<Scalars['String']>;
  contentKo?: Maybe<Scalars['String']>;
  contentPt?: Maybe<Scalars['String']>;
  contentRu?: Maybe<Scalars['String']>;
  contentZh?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  languageId: Scalars['Int'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  type: PromptType;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Language` values, with data from `Post`. */
export type PromptLanguagesByPostPromptIdAndLanguageIdManyToManyConnection = {
  __typename?: 'PromptLanguagesByPostPromptIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<PromptLanguagesByPostPromptIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `Post`. */
export type PromptLanguagesByPostPromptIdAndLanguageIdManyToManyEdge = {
  __typename?: 'PromptLanguagesByPostPromptIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
};


/** A `Language` edge in the connection, with data from `Post`. */
export type PromptLanguagesByPostPromptIdAndLanguageIdManyToManyEdgePostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** Represents an update to a `Prompt`. Fields that are set will be updated. */
export type PromptPatch = {
  contentDe?: Maybe<Scalars['String']>;
  contentEn?: Maybe<Scalars['String']>;
  contentEs?: Maybe<Scalars['String']>;
  contentFr?: Maybe<Scalars['String']>;
  contentIt?: Maybe<Scalars['String']>;
  contentJa?: Maybe<Scalars['String']>;
  contentKo?: Maybe<Scalars['String']>;
  contentPt?: Maybe<Scalars['String']>;
  contentRu?: Maybe<Scalars['String']>;
  contentZh?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  languageId?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  type?: Maybe<PromptType>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Post` values, with data from `Post`. */
export type PromptPostsByPostPromptIdAndParentPostIdManyToManyConnection = {
  __typename?: 'PromptPostsByPostPromptIdAndParentPostIdManyToManyConnection';
  /** A list of edges which contains the `Post`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<PromptPostsByPostPromptIdAndParentPostIdManyToManyEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection, with data from `Post`. */
export type PromptPostsByPostPromptIdAndParentPostIdManyToManyEdge = {
  __typename?: 'PromptPostsByPostPromptIdAndParentPostIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
  /** Reads and enables pagination through a set of `Post`. */
  replies: PostsConnection;
};


/** A `Post` edge in the connection, with data from `Post`. */
export type PromptPostsByPostPromptIdAndParentPostIdManyToManyEdgeRepliesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

export enum PromptType {
  Question = 'QUESTION',
  Word = 'WORD'
}

/** A filter to be used against PromptType fields. All fields are combined with a logical ‘and.’ */
export type PromptTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<PromptType>;
  /** Equal to the specified value. */
  equalTo?: Maybe<PromptType>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<PromptType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<PromptType>;
  /** Included in the specified list. */
  in?: Maybe<Array<PromptType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<PromptType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<PromptType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<PromptType>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<PromptType>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<PromptType>>;
};

/** A connection to a list of `User` values, with data from `Post`. */
export type PromptUsersByPostPromptIdAndAuthorIdManyToManyConnection = {
  __typename?: 'PromptUsersByPostPromptIdAndAuthorIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<PromptUsersByPostPromptIdAndAuthorIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Post`. */
export type PromptUsersByPostPromptIdAndAuthorIdManyToManyEdge = {
  __typename?: 'PromptUsersByPostPromptIdAndAuthorIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Post`. */
  authoredPosts: PostsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Post`. */
export type PromptUsersByPostPromptIdAndAuthorIdManyToManyEdgeAuthoredPostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** A connection to a list of `Prompt` values. */
export type PromptsConnection = {
  __typename?: 'PromptsConnection';
  /** A list of edges which contains the `Prompt` and cursor to aid in pagination. */
  edges: Array<PromptsEdge>;
  /** A list of `Prompt` objects. */
  nodes: Array<Maybe<Prompt>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Prompt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Prompt` edge in the connection. */
export type PromptsEdge = {
  __typename?: 'PromptsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Prompt` at the end of the edge. */
  node?: Maybe<Prompt>;
};

/** Methods to use when ordering `Prompt`. */
export enum PromptsOrderBy {
  ContentDeAsc = 'CONTENT_DE_ASC',
  ContentDeDesc = 'CONTENT_DE_DESC',
  ContentEnAsc = 'CONTENT_EN_ASC',
  ContentEnDesc = 'CONTENT_EN_DESC',
  ContentEsAsc = 'CONTENT_ES_ASC',
  ContentEsDesc = 'CONTENT_ES_DESC',
  ContentFrAsc = 'CONTENT_FR_ASC',
  ContentFrDesc = 'CONTENT_FR_DESC',
  ContentItAsc = 'CONTENT_IT_ASC',
  ContentItDesc = 'CONTENT_IT_DESC',
  ContentJaAsc = 'CONTENT_JA_ASC',
  ContentJaDesc = 'CONTENT_JA_DESC',
  ContentKoAsc = 'CONTENT_KO_ASC',
  ContentKoDesc = 'CONTENT_KO_DESC',
  ContentPtAsc = 'CONTENT_PT_ASC',
  ContentPtDesc = 'CONTENT_PT_DESC',
  ContentRuAsc = 'CONTENT_RU_ASC',
  ContentRuDesc = 'CONTENT_RU_DESC',
  ContentZhAsc = 'CONTENT_ZH_ASC',
  ContentZhDesc = 'CONTENT_ZH_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LanguageIdAsc = 'LANGUAGE_ID_ASC',
  LanguageIdDesc = 'LANGUAGE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  chineseGuessCharacterQuestion?: Maybe<ChineseGuessCharacterQuestion>;
  /** Reads a single `ChineseGuessCharacterQuestion` using its globally unique `ID`. */
  chineseGuessCharacterQuestionByNodeId?: Maybe<ChineseGuessCharacterQuestion>;
  chineseGuessCharacterQuestionByUuid?: Maybe<ChineseGuessCharacterQuestion>;
  /** Reads and enables pagination through a set of `ChineseGuessCharacterQuestion`. */
  chineseGuessCharacterQuestions?: Maybe<ChineseGuessCharacterQuestionsConnection>;
  chineseRandomQuestion?: Maybe<ChineseRandomQuestion>;
  /** Reads a single `ChineseRandomQuestion` using its globally unique `ID`. */
  chineseRandomQuestionByNodeId?: Maybe<ChineseRandomQuestion>;
  chineseRandomQuestionByUuid?: Maybe<ChineseRandomQuestion>;
  /** Reads and enables pagination through a set of `ChineseRandomQuestion`. */
  chineseRandomQuestions?: Maybe<ChineseRandomQuestionsConnection>;
  chineseWouldYouRatherQuestion?: Maybe<ChineseWouldYouRatherQuestion>;
  /** Reads a single `ChineseWouldYouRatherQuestion` using its globally unique `ID`. */
  chineseWouldYouRatherQuestionByNodeId?: Maybe<ChineseWouldYouRatherQuestion>;
  chineseWouldYouRatherQuestionByUuid?: Maybe<ChineseWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `ChineseWouldYouRatherQuestion`. */
  chineseWouldYouRatherQuestions?: Maybe<ChineseWouldYouRatherQuestionsConnection>;
  currentUser?: Maybe<User>;
  currentUserId?: Maybe<Scalars['Int']>;
  englishRandomQuestion?: Maybe<EnglishRandomQuestion>;
  /** Reads a single `EnglishRandomQuestion` using its globally unique `ID`. */
  englishRandomQuestionByNodeId?: Maybe<EnglishRandomQuestion>;
  englishRandomQuestionByUuid?: Maybe<EnglishRandomQuestion>;
  /** Reads and enables pagination through a set of `EnglishRandomQuestion`. */
  englishRandomQuestions?: Maybe<EnglishRandomQuestionsConnection>;
  englishWord?: Maybe<EnglishWord>;
  /** Reads a single `EnglishWord` using its globally unique `ID`. */
  englishWordByNodeId?: Maybe<EnglishWord>;
  englishWordByUuid?: Maybe<EnglishWord>;
  /** Reads and enables pagination through a set of `EnglishWord`. */
  englishWords?: Maybe<EnglishWordsConnection>;
  englishWouldYouRatherQuestion?: Maybe<EnglishWouldYouRatherQuestion>;
  /** Reads a single `EnglishWouldYouRatherQuestion` using its globally unique `ID`. */
  englishWouldYouRatherQuestionByNodeId?: Maybe<EnglishWouldYouRatherQuestion>;
  englishWouldYouRatherQuestionByUuid?: Maybe<EnglishWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `EnglishWouldYouRatherQuestion`. */
  englishWouldYouRatherQuestions?: Maybe<EnglishWouldYouRatherQuestionsConnection>;
  /** Reads and enables pagination through a set of `Post`. */
  feedPosts?: Maybe<PostsConnection>;
  frenchRandomQuestion?: Maybe<FrenchRandomQuestion>;
  /** Reads a single `FrenchRandomQuestion` using its globally unique `ID`. */
  frenchRandomQuestionByNodeId?: Maybe<FrenchRandomQuestion>;
  frenchRandomQuestionByUuid?: Maybe<FrenchRandomQuestion>;
  /** Reads and enables pagination through a set of `FrenchRandomQuestion`. */
  frenchRandomQuestions?: Maybe<FrenchRandomQuestionsConnection>;
  frenchWord?: Maybe<FrenchWord>;
  /** Reads a single `FrenchWord` using its globally unique `ID`. */
  frenchWordByNodeId?: Maybe<FrenchWord>;
  frenchWordByUuid?: Maybe<FrenchWord>;
  /** Reads and enables pagination through a set of `FrenchWord`. */
  frenchWords?: Maybe<FrenchWordsConnection>;
  frenchWouldYouRatherQuestion?: Maybe<FrenchWouldYouRatherQuestion>;
  /** Reads a single `FrenchWouldYouRatherQuestion` using its globally unique `ID`. */
  frenchWouldYouRatherQuestionByNodeId?: Maybe<FrenchWouldYouRatherQuestion>;
  frenchWouldYouRatherQuestionByUuid?: Maybe<FrenchWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `FrenchWouldYouRatherQuestion`. */
  frenchWouldYouRatherQuestions?: Maybe<FrenchWouldYouRatherQuestionsConnection>;
  germanRandomQuestion?: Maybe<GermanRandomQuestion>;
  /** Reads a single `GermanRandomQuestion` using its globally unique `ID`. */
  germanRandomQuestionByNodeId?: Maybe<GermanRandomQuestion>;
  germanRandomQuestionByUuid?: Maybe<GermanRandomQuestion>;
  /** Reads and enables pagination through a set of `GermanRandomQuestion`. */
  germanRandomQuestions?: Maybe<GermanRandomQuestionsConnection>;
  germanWord?: Maybe<GermanWord>;
  /** Reads a single `GermanWord` using its globally unique `ID`. */
  germanWordByNodeId?: Maybe<GermanWord>;
  germanWordByUuid?: Maybe<GermanWord>;
  /** Reads and enables pagination through a set of `GermanWord`. */
  germanWords?: Maybe<GermanWordsConnection>;
  germanWouldYouRatherQuestion?: Maybe<GermanWouldYouRatherQuestion>;
  /** Reads a single `GermanWouldYouRatherQuestion` using its globally unique `ID`. */
  germanWouldYouRatherQuestionByNodeId?: Maybe<GermanWouldYouRatherQuestion>;
  germanWouldYouRatherQuestionByUuid?: Maybe<GermanWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `GermanWouldYouRatherQuestion`. */
  germanWouldYouRatherQuestions?: Maybe<GermanWouldYouRatherQuestionsConnection>;
  group?: Maybe<Group>;
  /** Reads a single `Group` using its globally unique `ID`. */
  groupByNodeId?: Maybe<Group>;
  groupByUuid?: Maybe<Group>;
  groupIsGlobal?: Maybe<Scalars['Boolean']>;
  groupUser?: Maybe<GroupUser>;
  /** Reads a single `GroupUser` using its globally unique `ID`. */
  groupUserByNodeId?: Maybe<GroupUser>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers?: Maybe<GroupUsersConnection>;
  /** Reads and enables pagination through a set of `Group`. */
  groups?: Maybe<GroupsConnection>;
  inviteToken?: Maybe<InviteToken>;
  /** Reads a single `InviteToken` using its globally unique `ID`. */
  inviteTokenByNodeId?: Maybe<InviteToken>;
  /** Reads and enables pagination through a set of `InviteToken`. */
  inviteTokens?: Maybe<InviteTokensConnection>;
  italianRandomQuestion?: Maybe<ItalianRandomQuestion>;
  /** Reads a single `ItalianRandomQuestion` using its globally unique `ID`. */
  italianRandomQuestionByNodeId?: Maybe<ItalianRandomQuestion>;
  italianRandomQuestionByUuid?: Maybe<ItalianRandomQuestion>;
  /** Reads and enables pagination through a set of `ItalianRandomQuestion`. */
  italianRandomQuestions?: Maybe<ItalianRandomQuestionsConnection>;
  italianWord?: Maybe<ItalianWord>;
  /** Reads a single `ItalianWord` using its globally unique `ID`. */
  italianWordByNodeId?: Maybe<ItalianWord>;
  italianWordByUuid?: Maybe<ItalianWord>;
  /** Reads and enables pagination through a set of `ItalianWord`. */
  italianWords?: Maybe<ItalianWordsConnection>;
  italianWouldYouRatherQuestion?: Maybe<ItalianWouldYouRatherQuestion>;
  /** Reads a single `ItalianWouldYouRatherQuestion` using its globally unique `ID`. */
  italianWouldYouRatherQuestionByNodeId?: Maybe<ItalianWouldYouRatherQuestion>;
  italianWouldYouRatherQuestionByUuid?: Maybe<ItalianWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `ItalianWouldYouRatherQuestion`. */
  italianWouldYouRatherQuestions?: Maybe<ItalianWouldYouRatherQuestionsConnection>;
  japaneseRandomQuestion?: Maybe<JapaneseRandomQuestion>;
  /** Reads a single `JapaneseRandomQuestion` using its globally unique `ID`. */
  japaneseRandomQuestionByNodeId?: Maybe<JapaneseRandomQuestion>;
  japaneseRandomQuestionByUuid?: Maybe<JapaneseRandomQuestion>;
  /** Reads and enables pagination through a set of `JapaneseRandomQuestion`. */
  japaneseRandomQuestions?: Maybe<JapaneseRandomQuestionsConnection>;
  japaneseWouldYouRatherQuestion?: Maybe<JapaneseWouldYouRatherQuestion>;
  /** Reads a single `JapaneseWouldYouRatherQuestion` using its globally unique `ID`. */
  japaneseWouldYouRatherQuestionByNodeId?: Maybe<JapaneseWouldYouRatherQuestion>;
  japaneseWouldYouRatherQuestionByUuid?: Maybe<JapaneseWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `JapaneseWouldYouRatherQuestion`. */
  japaneseWouldYouRatherQuestions?: Maybe<JapaneseWouldYouRatherQuestionsConnection>;
  koreanRandomQuestion?: Maybe<KoreanRandomQuestion>;
  /** Reads a single `KoreanRandomQuestion` using its globally unique `ID`. */
  koreanRandomQuestionByNodeId?: Maybe<KoreanRandomQuestion>;
  koreanRandomQuestionByUuid?: Maybe<KoreanRandomQuestion>;
  /** Reads and enables pagination through a set of `KoreanRandomQuestion`. */
  koreanRandomQuestions?: Maybe<KoreanRandomQuestionsConnection>;
  koreanWouldYouRatherQuestion?: Maybe<KoreanWouldYouRatherQuestion>;
  /** Reads a single `KoreanWouldYouRatherQuestion` using its globally unique `ID`. */
  koreanWouldYouRatherQuestionByNodeId?: Maybe<KoreanWouldYouRatherQuestion>;
  koreanWouldYouRatherQuestionByUuid?: Maybe<KoreanWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `KoreanWouldYouRatherQuestion`. */
  koreanWouldYouRatherQuestions?: Maybe<KoreanWouldYouRatherQuestionsConnection>;
  language?: Maybe<Language>;
  languageByAlpha2?: Maybe<Language>;
  languageByEnglishName?: Maybe<Language>;
  /** Reads a single `Language` using its globally unique `ID`. */
  languageByNodeId?: Maybe<Language>;
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Reads a single `LanguageSkillLevel` using its globally unique `ID`. */
  languageSkillLevelByNodeId?: Maybe<LanguageSkillLevel>;
  /** Reads and enables pagination through a set of `LanguageSkillLevel`. */
  languageSkillLevels?: Maybe<LanguageSkillLevelsConnection>;
  /** Reads and enables pagination through a set of `Language`. */
  languages?: Maybe<LanguagesConnection>;
  message?: Maybe<Message>;
  /** Reads a single `Message` using its globally unique `ID`. */
  messageByNodeId?: Maybe<Message>;
  messageByUuid?: Maybe<Message>;
  messagePreview?: Maybe<MessagePreview>;
  /** Reads a single `MessagePreview` using its globally unique `ID`. */
  messagePreviewByNodeId?: Maybe<MessagePreview>;
  messagePreviewByUuid?: Maybe<MessagePreview>;
  /** Reads and enables pagination through a set of `MessagePreview`. */
  messagePreviews?: Maybe<MessagePreviewsConnection>;
  /** Reads and enables pagination through a set of `Message`. */
  messages?: Maybe<MessagesConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  notification?: Maybe<Notification>;
  /** Reads a single `Notification` using its globally unique `ID`. */
  notificationByNodeId?: Maybe<Notification>;
  notificationByUuid?: Maybe<Notification>;
  notificationChannel?: Maybe<NotificationChannel>;
  notificationChannelByName?: Maybe<NotificationChannel>;
  /** Reads a single `NotificationChannel` using its globally unique `ID`. */
  notificationChannelByNodeId?: Maybe<NotificationChannel>;
  notificationChannelByUuid?: Maybe<NotificationChannel>;
  /** Reads and enables pagination through a set of `NotificationChannel`. */
  notificationChannels?: Maybe<NotificationChannelsConnection>;
  /** Reads and enables pagination through a set of `Notification`. */
  notifications?: Maybe<NotificationsConnection>;
  portugueseRandomQuestion?: Maybe<PortugueseRandomQuestion>;
  /** Reads a single `PortugueseRandomQuestion` using its globally unique `ID`. */
  portugueseRandomQuestionByNodeId?: Maybe<PortugueseRandomQuestion>;
  portugueseRandomQuestionByUuid?: Maybe<PortugueseRandomQuestion>;
  /** Reads and enables pagination through a set of `PortugueseRandomQuestion`. */
  portugueseRandomQuestions?: Maybe<PortugueseRandomQuestionsConnection>;
  portugueseWord?: Maybe<PortugueseWord>;
  /** Reads a single `PortugueseWord` using its globally unique `ID`. */
  portugueseWordByNodeId?: Maybe<PortugueseWord>;
  portugueseWordByUuid?: Maybe<PortugueseWord>;
  /** Reads and enables pagination through a set of `PortugueseWord`. */
  portugueseWords?: Maybe<PortugueseWordsConnection>;
  portugueseWouldYouRatherQuestion?: Maybe<PortugueseWouldYouRatherQuestion>;
  /** Reads a single `PortugueseWouldYouRatherQuestion` using its globally unique `ID`. */
  portugueseWouldYouRatherQuestionByNodeId?: Maybe<PortugueseWouldYouRatherQuestion>;
  portugueseWouldYouRatherQuestionByUuid?: Maybe<PortugueseWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `PortugueseWouldYouRatherQuestion`. */
  portugueseWouldYouRatherQuestions?: Maybe<PortugueseWouldYouRatherQuestionsConnection>;
  post?: Maybe<Post>;
  /** Reads a single `Post` using its globally unique `ID`. */
  postByNodeId?: Maybe<Post>;
  postBySnowflakeId?: Maybe<Post>;
  postByUuid?: Maybe<Post>;
  postCorrection?: Maybe<PostCorrection>;
  /** Reads a single `PostCorrection` using its globally unique `ID`. */
  postCorrectionByNodeId?: Maybe<PostCorrection>;
  postCorrectionByUuid?: Maybe<PostCorrection>;
  /** Reads and enables pagination through a set of `PostCorrection`. */
  postCorrections?: Maybe<PostCorrectionsConnection>;
  postGame?: Maybe<PostGame>;
  postGameAnswer?: Maybe<PostGameAnswer>;
  /** Reads a single `PostGameAnswer` using its globally unique `ID`. */
  postGameAnswerByNodeId?: Maybe<PostGameAnswer>;
  postGameAnswerByUuid?: Maybe<PostGameAnswer>;
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  postGameAnswers?: Maybe<PostGameAnswersConnection>;
  /** Reads a single `PostGame` using its globally unique `ID`. */
  postGameByNodeId?: Maybe<PostGame>;
  postGameByUuid?: Maybe<PostGame>;
  postGameRange?: Maybe<PostGameRange>;
  /** Reads a single `PostGameRange` using its globally unique `ID`. */
  postGameRangeByNodeId?: Maybe<PostGameRange>;
  postGameRangeByUuid?: Maybe<PostGameRange>;
  /** Reads and enables pagination through a set of `PostGameRange`. */
  postGameRanges?: Maybe<PostGameRangesConnection>;
  /** Reads and enables pagination through a set of `PostGame`. */
  postGames?: Maybe<PostGamesConnection>;
  postLike?: Maybe<PostLike>;
  /** Reads a single `PostLike` using its globally unique `ID`. */
  postLikeByNodeId?: Maybe<PostLike>;
  /** Reads and enables pagination through a set of `PostLike`. */
  postLikes?: Maybe<PostLikesConnection>;
  postRecording?: Maybe<PostRecording>;
  /** Reads a single `PostRecording` using its globally unique `ID`. */
  postRecordingByNodeId?: Maybe<PostRecording>;
  postRecordingByUuid?: Maybe<PostRecording>;
  /** Reads and enables pagination through a set of `PostRecording`. */
  postRecordings?: Maybe<PostRecordingsConnection>;
  postUserMention?: Maybe<PostUserMention>;
  /** Reads a single `PostUserMention` using its globally unique `ID`. */
  postUserMentionByNodeId?: Maybe<PostUserMention>;
  postUserMentionByUuid?: Maybe<PostUserMention>;
  /** Reads and enables pagination through a set of `PostUserMention`. */
  postUserMentions?: Maybe<PostUserMentionsConnection>;
  /** Reads and enables pagination through a set of `Post`. */
  posts?: Maybe<PostsConnection>;
  prompt?: Maybe<Prompt>;
  /** Reads a single `Prompt` using its globally unique `ID`. */
  promptByNodeId?: Maybe<Prompt>;
  promptByUuid?: Maybe<Prompt>;
  /** Reads and enables pagination through a set of `Prompt`. */
  prompts?: Maybe<PromptsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  russianRandomQuestion?: Maybe<RussianRandomQuestion>;
  /** Reads a single `RussianRandomQuestion` using its globally unique `ID`. */
  russianRandomQuestionByNodeId?: Maybe<RussianRandomQuestion>;
  russianRandomQuestionByUuid?: Maybe<RussianRandomQuestion>;
  /** Reads and enables pagination through a set of `RussianRandomQuestion`. */
  russianRandomQuestions?: Maybe<RussianRandomQuestionsConnection>;
  russianWord?: Maybe<RussianWord>;
  /** Reads a single `RussianWord` using its globally unique `ID`. */
  russianWordByNodeId?: Maybe<RussianWord>;
  russianWordByUuid?: Maybe<RussianWord>;
  /** Reads and enables pagination through a set of `RussianWord`. */
  russianWords?: Maybe<RussianWordsConnection>;
  russianWouldYouRatherQuestion?: Maybe<RussianWouldYouRatherQuestion>;
  /** Reads a single `RussianWouldYouRatherQuestion` using its globally unique `ID`. */
  russianWouldYouRatherQuestionByNodeId?: Maybe<RussianWouldYouRatherQuestion>;
  russianWouldYouRatherQuestionByUuid?: Maybe<RussianWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `RussianWouldYouRatherQuestion`. */
  russianWouldYouRatherQuestions?: Maybe<RussianWouldYouRatherQuestionsConnection>;
  spanishRandomQuestion?: Maybe<SpanishRandomQuestion>;
  /** Reads a single `SpanishRandomQuestion` using its globally unique `ID`. */
  spanishRandomQuestionByNodeId?: Maybe<SpanishRandomQuestion>;
  spanishRandomQuestionByUuid?: Maybe<SpanishRandomQuestion>;
  /** Reads and enables pagination through a set of `SpanishRandomQuestion`. */
  spanishRandomQuestions?: Maybe<SpanishRandomQuestionsConnection>;
  spanishWord?: Maybe<SpanishWord>;
  /** Reads a single `SpanishWord` using its globally unique `ID`. */
  spanishWordByNodeId?: Maybe<SpanishWord>;
  spanishWordByUuid?: Maybe<SpanishWord>;
  /** Reads and enables pagination through a set of `SpanishWord`. */
  spanishWords?: Maybe<SpanishWordsConnection>;
  spanishWouldYouRatherQuestion?: Maybe<SpanishWouldYouRatherQuestion>;
  /** Reads a single `SpanishWouldYouRatherQuestion` using its globally unique `ID`. */
  spanishWouldYouRatherQuestionByNodeId?: Maybe<SpanishWouldYouRatherQuestion>;
  spanishWouldYouRatherQuestionByUuid?: Maybe<SpanishWouldYouRatherQuestion>;
  /** Reads and enables pagination through a set of `SpanishWouldYouRatherQuestion`. */
  spanishWouldYouRatherQuestions?: Maybe<SpanishWouldYouRatherQuestionsConnection>;
  user?: Maybe<User>;
  userByEmail?: Maybe<User>;
  userByEmailUnsubscribeToken?: Maybe<User>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  userByResetPasswordToken?: Maybe<User>;
  userByUsername?: Maybe<User>;
  userByUuid?: Maybe<User>;
  userDevice?: Maybe<UserDevice>;
  userDeviceByFcmToken?: Maybe<UserDevice>;
  /** Reads a single `UserDevice` using its globally unique `ID`. */
  userDeviceByNodeId?: Maybe<UserDevice>;
  userDeviceByUuid?: Maybe<UserDevice>;
  /** Reads and enables pagination through a set of `UserDevice`. */
  userDevices?: Maybe<UserDevicesConnection>;
  userFollower?: Maybe<UserFollower>;
  /** Reads a single `UserFollower` using its globally unique `ID`. */
  userFollowerByNodeId?: Maybe<UserFollower>;
  /** Reads and enables pagination through a set of `UserFollower`. */
  userFollowers?: Maybe<UserFollowersConnection>;
  userIsInGroup?: Maybe<Scalars['Boolean']>;
  userLanguage?: Maybe<UserLanguage>;
  /** Reads a single `UserLanguage` using its globally unique `ID`. */
  userLanguageByNodeId?: Maybe<UserLanguage>;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages?: Maybe<UserLanguagesConnection>;
  userPreference?: Maybe<UserPreference>;
  /** Reads a single `UserPreference` using its globally unique `ID`. */
  userPreferenceByNodeId?: Maybe<UserPreference>;
  userPreferenceByUserId?: Maybe<UserPreference>;
  /** Reads and enables pagination through a set of `UserPreference`. */
  userPreferences?: Maybe<UserPreferencesConnection>;
  userSession?: Maybe<UserSession>;
  /** Reads a single `UserSession` using its globally unique `ID`. */
  userSessionByNodeId?: Maybe<UserSession>;
  /** Reads and enables pagination through a set of `UserSession`. */
  userSessions?: Maybe<UserSessionsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `User`. */
  usersWithoutLearnerGroup?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `User`. */
  usersWithoutNativeGroup?: Maybe<UsersConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseGuessCharacterQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseGuessCharacterQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseGuessCharacterQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseGuessCharacterQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ChineseGuessCharacterQuestionCondition>;
  filter?: Maybe<ChineseGuessCharacterQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ChineseGuessCharacterQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ChineseRandomQuestionCondition>;
  filter?: Maybe<ChineseRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ChineseRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChineseWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ChineseWouldYouRatherQuestionCondition>;
  filter?: Maybe<ChineseWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ChineseWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EnglishRandomQuestionCondition>;
  filter?: Maybe<EnglishRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EnglishRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWordArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWordByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWordsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EnglishWordCondition>;
  filter?: Maybe<EnglishWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EnglishWordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnglishWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<EnglishWouldYouRatherQuestionCondition>;
  filter?: Maybe<EnglishWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EnglishWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFeedPostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  afterUuid?: Maybe<Scalars['UUID']>;
  before?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  locale?: Maybe<Scalars['String']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<FrenchRandomQuestionCondition>;
  filter?: Maybe<FrenchRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FrenchRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWordArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWordByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWordsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<FrenchWordCondition>;
  filter?: Maybe<FrenchWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FrenchWordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrenchWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<FrenchWouldYouRatherQuestionCondition>;
  filter?: Maybe<FrenchWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FrenchWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GermanRandomQuestionCondition>;
  filter?: Maybe<GermanRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GermanRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWordArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWordByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWordsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GermanWordCondition>;
  filter?: Maybe<GermanWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GermanWordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGermanWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GermanWouldYouRatherQuestionCondition>;
  filter?: Maybe<GermanWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GermanWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupIsGlobalArgs = {
  gid: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupUserArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupUserCondition>;
  filter?: Maybe<GroupUserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInviteTokenArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInviteTokenByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInviteTokensArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<InviteTokenCondition>;
  filter?: Maybe<InviteTokenFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<InviteTokensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ItalianRandomQuestionCondition>;
  filter?: Maybe<ItalianRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ItalianRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWordArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWordByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWordsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ItalianWordCondition>;
  filter?: Maybe<ItalianWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ItalianWordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItalianWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<ItalianWouldYouRatherQuestionCondition>;
  filter?: Maybe<ItalianWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ItalianWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<JapaneseRandomQuestionCondition>;
  filter?: Maybe<JapaneseRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<JapaneseRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJapaneseWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<JapaneseWouldYouRatherQuestionCondition>;
  filter?: Maybe<JapaneseWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<JapaneseWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<KoreanRandomQuestionCondition>;
  filter?: Maybe<KoreanRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<KoreanRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKoreanWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<KoreanWouldYouRatherQuestionCondition>;
  filter?: Maybe<KoreanWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<KoreanWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageByAlpha2Args = {
  alpha2: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageByEnglishNameArgs = {
  englishName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageSkillLevelArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageSkillLevelByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageSkillLevelsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageSkillLevelCondition>;
  filter?: Maybe<LanguageSkillLevelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessagePreviewArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessagePreviewByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessagePreviewByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessagePreviewsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessagePreviewCondition>;
  filter?: Maybe<MessagePreviewFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagePreviewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationChannelArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationChannelByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationChannelByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationChannelByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationChannelsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationChannelCondition>;
  filter?: Maybe<NotificationChannelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationChannelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PortugueseRandomQuestionCondition>;
  filter?: Maybe<PortugueseRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PortugueseRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWordArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWordByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWordsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PortugueseWordCondition>;
  filter?: Maybe<PortugueseWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PortugueseWordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPortugueseWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PortugueseWouldYouRatherQuestionCondition>;
  filter?: Maybe<PortugueseWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PortugueseWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostBySnowflakeIdArgs = {
  snowflakeId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostCorrectionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostCorrectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostCorrectionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostCorrectionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCorrectionCondition>;
  filter?: Maybe<PostCorrectionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameAnswerArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameAnswerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameAnswerByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameRangeArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameRangeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameRangeByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGameRangesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameRangeCondition>;
  filter?: Maybe<PostGameRangeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostGamesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameCondition>;
  filter?: Maybe<PostGameFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostLikeArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostLikeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostLikesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostLikeCondition>;
  filter?: Maybe<PostLikeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostRecordingArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostRecordingByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostRecordingByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostRecordingsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostRecordingCondition>;
  filter?: Maybe<PostRecordingFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostUserMentionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostUserMentionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostUserMentionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPostUserMentionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostUserMentionCondition>;
  filter?: Maybe<PostUserMentionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPromptArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPromptByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPromptByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPromptsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<RussianRandomQuestionCondition>;
  filter?: Maybe<RussianRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<RussianRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWordArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWordByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWordsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<RussianWordCondition>;
  filter?: Maybe<RussianWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<RussianWordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRussianWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<RussianWouldYouRatherQuestionCondition>;
  filter?: Maybe<RussianWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<RussianWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishRandomQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishRandomQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishRandomQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishRandomQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<SpanishRandomQuestionCondition>;
  filter?: Maybe<SpanishRandomQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SpanishRandomQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWordArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWordByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWordsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<SpanishWordCondition>;
  filter?: Maybe<SpanishWordFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SpanishWordsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWouldYouRatherQuestionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWouldYouRatherQuestionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWouldYouRatherQuestionByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySpanishWouldYouRatherQuestionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<SpanishWouldYouRatherQuestionCondition>;
  filter?: Maybe<SpanishWouldYouRatherQuestionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SpanishWouldYouRatherQuestionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByEmailArgs = {
  email: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByEmailUnsubscribeTokenArgs = {
  emailUnsubscribeToken: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByResetPasswordTokenArgs = {
  resetPasswordToken: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByUsernameArgs = {
  username: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserDeviceArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserDeviceByFcmTokenArgs = {
  fcmToken: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserDeviceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserDeviceByUuidArgs = {
  uuid: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserDevicesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserDeviceCondition>;
  filter?: Maybe<UserDeviceFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserDevicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserFollowerArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserFollowerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserFollowersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserFollowerCondition>;
  filter?: Maybe<UserFollowerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserIsInGroupArgs = {
  gid: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserLanguageArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserLanguageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserPreferenceArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserPreferenceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserPreferenceByUserIdArgs = {
  userId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserPreferencesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserPreferenceCondition>;
  filter?: Maybe<UserPreferenceFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserPreferencesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserSessionArgs = {
  sid: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserSessionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserSessionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserSessionCondition>;
  filter?: Maybe<UserSessionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserSessionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersWithoutLearnerGroupArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  lid?: Maybe<Scalars['Int']>;
  lsklid?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersWithoutNativeGroupArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  lid?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

/** All input for the `registerUserActivity` mutation. */
export type RegisterUserActivityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  userId: Scalars['Int'];
};

/** The output of our `registerUserActivity` mutation. */
export type RegisterUserActivityPayload = {
  __typename?: 'RegisterUserActivityPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  datetime?: Maybe<Scalars['Datetime']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type RussianRandomQuestion = Node & {
  __typename?: 'RussianRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `RussianRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type RussianRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `RussianRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type RussianRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RussianRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<RussianRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RussianRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `RussianRandomQuestion` */
export type RussianRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `RussianRandomQuestion`. Fields that are set will be updated. */
export type RussianRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `RussianRandomQuestion` values. */
export type RussianRandomQuestionsConnection = {
  __typename?: 'RussianRandomQuestionsConnection';
  /** A list of edges which contains the `RussianRandomQuestion` and cursor to aid in pagination. */
  edges: Array<RussianRandomQuestionsEdge>;
  /** A list of `RussianRandomQuestion` objects. */
  nodes: Array<Maybe<RussianRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RussianRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RussianRandomQuestion` edge in the connection. */
export type RussianRandomQuestionsEdge = {
  __typename?: 'RussianRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RussianRandomQuestion` at the end of the edge. */
  node?: Maybe<RussianRandomQuestion>;
};

/** Methods to use when ordering `RussianRandomQuestion`. */
export enum RussianRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type RussianWord = Node & {
  __typename?: 'RussianWord';
  createdAt: Scalars['Datetime'];
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id: Scalars['Int'];
  length?: Maybe<Scalars['Int']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  word: Scalars['String'];
};

/**
 * A condition to be used against `RussianWord` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RussianWordCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `word` field. */
  word?: Maybe<Scalars['String']>;
};

/** A filter to be used against `RussianWord` object types. All fields are combined with a logical ‘and.’ */
export type RussianWordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RussianWordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `frequency` field. */
  frequency?: Maybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `length` field. */
  length?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<RussianWordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RussianWordFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `word` field. */
  word?: Maybe<StringFilter>;
};

/** An input for mutations affecting `RussianWord` */
export type RussianWordInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word: Scalars['String'];
};

/** Represents an update to a `RussianWord`. Fields that are set will be updated. */
export type RussianWordPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word?: Maybe<Scalars['String']>;
};

/** A connection to a list of `RussianWord` values. */
export type RussianWordsConnection = {
  __typename?: 'RussianWordsConnection';
  /** A list of edges which contains the `RussianWord` and cursor to aid in pagination. */
  edges: Array<RussianWordsEdge>;
  /** A list of `RussianWord` objects. */
  nodes: Array<Maybe<RussianWord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RussianWord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RussianWord` edge in the connection. */
export type RussianWordsEdge = {
  __typename?: 'RussianWordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RussianWord` at the end of the edge. */
  node?: Maybe<RussianWord>;
};

/** Methods to use when ordering `RussianWord`. */
export enum RussianWordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FrequencyAsc = 'FREQUENCY_ASC',
  FrequencyDesc = 'FREQUENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WordAsc = 'WORD_ASC',
  WordDesc = 'WORD_DESC'
}

export type RussianWouldYouRatherQuestion = Node & {
  __typename?: 'RussianWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `RussianWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type RussianWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `RussianWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type RussianWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RussianWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<RussianWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RussianWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `RussianWouldYouRatherQuestion` */
export type RussianWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `RussianWouldYouRatherQuestion`. Fields that are set will be updated. */
export type RussianWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `RussianWouldYouRatherQuestion` values. */
export type RussianWouldYouRatherQuestionsConnection = {
  __typename?: 'RussianWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `RussianWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<RussianWouldYouRatherQuestionsEdge>;
  /** A list of `RussianWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<RussianWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RussianWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RussianWouldYouRatherQuestion` edge in the connection. */
export type RussianWouldYouRatherQuestionsEdge = {
  __typename?: 'RussianWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RussianWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<RussianWouldYouRatherQuestion>;
};

/** Methods to use when ordering `RussianWouldYouRatherQuestion`. */
export enum RussianWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type SpanishRandomQuestion = Node & {
  __typename?: 'SpanishRandomQuestion';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `SpanishRandomQuestion` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type SpanishRandomQuestionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `SpanishRandomQuestion` object types. All fields are combined with a logical ‘and.’ */
export type SpanishRandomQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SpanishRandomQuestionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<SpanishRandomQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SpanishRandomQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `SpanishRandomQuestion` */
export type SpanishRandomQuestionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `SpanishRandomQuestion`. Fields that are set will be updated. */
export type SpanishRandomQuestionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `SpanishRandomQuestion` values. */
export type SpanishRandomQuestionsConnection = {
  __typename?: 'SpanishRandomQuestionsConnection';
  /** A list of edges which contains the `SpanishRandomQuestion` and cursor to aid in pagination. */
  edges: Array<SpanishRandomQuestionsEdge>;
  /** A list of `SpanishRandomQuestion` objects. */
  nodes: Array<Maybe<SpanishRandomQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpanishRandomQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `SpanishRandomQuestion` edge in the connection. */
export type SpanishRandomQuestionsEdge = {
  __typename?: 'SpanishRandomQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SpanishRandomQuestion` at the end of the edge. */
  node?: Maybe<SpanishRandomQuestion>;
};

/** Methods to use when ordering `SpanishRandomQuestion`. */
export enum SpanishRandomQuestionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type SpanishWord = Node & {
  __typename?: 'SpanishWord';
  createdAt: Scalars['Datetime'];
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id: Scalars['Int'];
  length?: Maybe<Scalars['Int']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  word: Scalars['String'];
};

/**
 * A condition to be used against `SpanishWord` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SpanishWordCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `frequency` field. */
  frequency?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `length` field. */
  length?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `word` field. */
  word?: Maybe<Scalars['String']>;
};

/** A filter to be used against `SpanishWord` object types. All fields are combined with a logical ‘and.’ */
export type SpanishWordFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SpanishWordFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `frequency` field. */
  frequency?: Maybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `length` field. */
  length?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<SpanishWordFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SpanishWordFilter>>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
  /** Filter by the object’s `word` field. */
  word?: Maybe<StringFilter>;
};

/** An input for mutations affecting `SpanishWord` */
export type SpanishWordInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency: Scalars['Float'];
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word: Scalars['String'];
};

/** Represents an update to a `SpanishWord`. Fields that are set will be updated. */
export type SpanishWordPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Ranges from 0 to 1 (higher is more frequent) */
  frequency?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Int']>;
  length?: Maybe<Scalars['Int']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
  word?: Maybe<Scalars['String']>;
};

/** A connection to a list of `SpanishWord` values. */
export type SpanishWordsConnection = {
  __typename?: 'SpanishWordsConnection';
  /** A list of edges which contains the `SpanishWord` and cursor to aid in pagination. */
  edges: Array<SpanishWordsEdge>;
  /** A list of `SpanishWord` objects. */
  nodes: Array<Maybe<SpanishWord>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpanishWord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `SpanishWord` edge in the connection. */
export type SpanishWordsEdge = {
  __typename?: 'SpanishWordsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SpanishWord` at the end of the edge. */
  node?: Maybe<SpanishWord>;
};

/** Methods to use when ordering `SpanishWord`. */
export enum SpanishWordsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FrequencyAsc = 'FREQUENCY_ASC',
  FrequencyDesc = 'FREQUENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LengthAsc = 'LENGTH_ASC',
  LengthDesc = 'LENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  WordAsc = 'WORD_ASC',
  WordDesc = 'WORD_DESC'
}

export type SpanishWouldYouRatherQuestion = Node & {
  __typename?: 'SpanishWouldYouRatherQuestion';
  answers: Array<Maybe<Scalars['String']>>;
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  question: Scalars['String'];
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `SpanishWouldYouRatherQuestion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type SpanishWouldYouRatherQuestionCondition = {
  /** Checks for equality with the object’s `answers` field. */
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `question` field. */
  question?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `SpanishWouldYouRatherQuestion` object types. All fields are combined with a logical ‘and.’ */
export type SpanishWouldYouRatherQuestionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SpanishWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `answers` field. */
  answers?: Maybe<StringListFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<SpanishWouldYouRatherQuestionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SpanishWouldYouRatherQuestionFilter>>;
  /** Filter by the object’s `question` field. */
  question?: Maybe<StringFilter>;
  /** Filter by the object’s `recommendedSkillLevelId` field. */
  recommendedSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `SpanishWouldYouRatherQuestion` */
export type SpanishWouldYouRatherQuestionInput = {
  answers: Array<Maybe<Scalars['String']>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question: Scalars['String'];
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `SpanishWouldYouRatherQuestion`. Fields that are set will be updated. */
export type SpanishWouldYouRatherQuestionPatch = {
  answers?: Maybe<Array<Maybe<Scalars['String']>>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  recommendedSkillLevelId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `SpanishWouldYouRatherQuestion` values. */
export type SpanishWouldYouRatherQuestionsConnection = {
  __typename?: 'SpanishWouldYouRatherQuestionsConnection';
  /** A list of edges which contains the `SpanishWouldYouRatherQuestion` and cursor to aid in pagination. */
  edges: Array<SpanishWouldYouRatherQuestionsEdge>;
  /** A list of `SpanishWouldYouRatherQuestion` objects. */
  nodes: Array<Maybe<SpanishWouldYouRatherQuestion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpanishWouldYouRatherQuestion` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `SpanishWouldYouRatherQuestion` edge in the connection. */
export type SpanishWouldYouRatherQuestionsEdge = {
  __typename?: 'SpanishWouldYouRatherQuestionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SpanishWouldYouRatherQuestion` at the end of the edge. */
  node?: Maybe<SpanishWouldYouRatherQuestion>;
};

/** Methods to use when ordering `SpanishWouldYouRatherQuestion`. */
export enum SpanishWouldYouRatherQuestionsOrderBy {
  AnswersAsc = 'ANSWERS_ASC',
  AnswersDesc = 'ANSWERS_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuestionAsc = 'QUESTION_ASC',
  QuestionDesc = 'QUESTION_DESC',
  RecommendedSkillLevelIdAsc = 'RECOMMENDED_SKILL_LEVEL_ID_ASC',
  RecommendedSkillLevelIdDesc = 'RECOMMENDED_SKILL_LEVEL_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: Maybe<Scalars['String']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: Maybe<Scalars['String']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: Maybe<Scalars['String']>;
  /** Contained by the specified list of values. */
  containedBy?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contains the specified list of values. */
  contains?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['UUID']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['UUID']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['UUID']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['UUID']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['UUID']>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['UUID']>>;
};

/** All input for the `updateChineseGuessCharacterQuestionByNodeId` mutation. */
export type UpdateChineseGuessCharacterQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChineseGuessCharacterQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ChineseGuessCharacterQuestion` being updated. */
  patch: ChineseGuessCharacterQuestionPatch;
};

/** All input for the `updateChineseGuessCharacterQuestionByUuid` mutation. */
export type UpdateChineseGuessCharacterQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ChineseGuessCharacterQuestion` being updated. */
  patch: ChineseGuessCharacterQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateChineseGuessCharacterQuestion` mutation. */
export type UpdateChineseGuessCharacterQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `ChineseGuessCharacterQuestion` being updated. */
  patch: ChineseGuessCharacterQuestionPatch;
};

/** The output of our update `ChineseGuessCharacterQuestion` mutation. */
export type UpdateChineseGuessCharacterQuestionPayload = {
  __typename?: 'UpdateChineseGuessCharacterQuestionPayload';
  /** The `ChineseGuessCharacterQuestion` that was updated by this mutation. */
  chineseGuessCharacterQuestion?: Maybe<ChineseGuessCharacterQuestion>;
  /** An edge for our `ChineseGuessCharacterQuestion`. May be used by Relay 1. */
  chineseGuessCharacterQuestionEdge?: Maybe<ChineseGuessCharacterQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseGuessCharacterQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `ChineseGuessCharacterQuestion` mutation. */
export type UpdateChineseGuessCharacterQuestionPayloadChineseGuessCharacterQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseGuessCharacterQuestionsOrderBy>>;
};

/** All input for the `updateChineseRandomQuestionByNodeId` mutation. */
export type UpdateChineseRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChineseRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ChineseRandomQuestion` being updated. */
  patch: ChineseRandomQuestionPatch;
};

/** All input for the `updateChineseRandomQuestionByUuid` mutation. */
export type UpdateChineseRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ChineseRandomQuestion` being updated. */
  patch: ChineseRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateChineseRandomQuestion` mutation. */
export type UpdateChineseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `ChineseRandomQuestion` being updated. */
  patch: ChineseRandomQuestionPatch;
};

/** The output of our update `ChineseRandomQuestion` mutation. */
export type UpdateChineseRandomQuestionPayload = {
  __typename?: 'UpdateChineseRandomQuestionPayload';
  /** The `ChineseRandomQuestion` that was updated by this mutation. */
  chineseRandomQuestion?: Maybe<ChineseRandomQuestion>;
  /** An edge for our `ChineseRandomQuestion`. May be used by Relay 1. */
  chineseRandomQuestionEdge?: Maybe<ChineseRandomQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `ChineseRandomQuestion` mutation. */
export type UpdateChineseRandomQuestionPayloadChineseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseRandomQuestionsOrderBy>>;
};

/** All input for the `updateChineseWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateChineseWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChineseWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ChineseWouldYouRatherQuestion` being updated. */
  patch: ChineseWouldYouRatherQuestionPatch;
};

/** All input for the `updateChineseWouldYouRatherQuestionByUuid` mutation. */
export type UpdateChineseWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ChineseWouldYouRatherQuestion` being updated. */
  patch: ChineseWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateChineseWouldYouRatherQuestion` mutation. */
export type UpdateChineseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `ChineseWouldYouRatherQuestion` being updated. */
  patch: ChineseWouldYouRatherQuestionPatch;
};

/** The output of our update `ChineseWouldYouRatherQuestion` mutation. */
export type UpdateChineseWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateChineseWouldYouRatherQuestionPayload';
  /** The `ChineseWouldYouRatherQuestion` that was updated by this mutation. */
  chineseWouldYouRatherQuestion?: Maybe<ChineseWouldYouRatherQuestion>;
  /** An edge for our `ChineseWouldYouRatherQuestion`. May be used by Relay 1. */
  chineseWouldYouRatherQuestionEdge?: Maybe<ChineseWouldYouRatherQuestionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `ChineseWouldYouRatherQuestion` mutation. */
export type UpdateChineseWouldYouRatherQuestionPayloadChineseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateEnglishRandomQuestionByNodeId` mutation. */
export type UpdateEnglishRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EnglishRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `EnglishRandomQuestion` being updated. */
  patch: EnglishRandomQuestionPatch;
};

/** All input for the `updateEnglishRandomQuestionByUuid` mutation. */
export type UpdateEnglishRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `EnglishRandomQuestion` being updated. */
  patch: EnglishRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateEnglishRandomQuestion` mutation. */
export type UpdateEnglishRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `EnglishRandomQuestion` being updated. */
  patch: EnglishRandomQuestionPatch;
};

/** The output of our update `EnglishRandomQuestion` mutation. */
export type UpdateEnglishRandomQuestionPayload = {
  __typename?: 'UpdateEnglishRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishRandomQuestion` that was updated by this mutation. */
  englishRandomQuestion?: Maybe<EnglishRandomQuestion>;
  /** An edge for our `EnglishRandomQuestion`. May be used by Relay 1. */
  englishRandomQuestionEdge?: Maybe<EnglishRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `EnglishRandomQuestion` mutation. */
export type UpdateEnglishRandomQuestionPayloadEnglishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishRandomQuestionsOrderBy>>;
};

/** All input for the `updateEnglishWordByNodeId` mutation. */
export type UpdateEnglishWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EnglishWord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `EnglishWord` being updated. */
  patch: EnglishWordPatch;
};

/** All input for the `updateEnglishWordByUuid` mutation. */
export type UpdateEnglishWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `EnglishWord` being updated. */
  patch: EnglishWordPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateEnglishWord` mutation. */
export type UpdateEnglishWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `EnglishWord` being updated. */
  patch: EnglishWordPatch;
};

/** The output of our update `EnglishWord` mutation. */
export type UpdateEnglishWordPayload = {
  __typename?: 'UpdateEnglishWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWord` that was updated by this mutation. */
  englishWord?: Maybe<EnglishWord>;
  /** An edge for our `EnglishWord`. May be used by Relay 1. */
  englishWordEdge?: Maybe<EnglishWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `EnglishWord` mutation. */
export type UpdateEnglishWordPayloadEnglishWordEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWordsOrderBy>>;
};

/** All input for the `updateEnglishWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateEnglishWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EnglishWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `EnglishWouldYouRatherQuestion` being updated. */
  patch: EnglishWouldYouRatherQuestionPatch;
};

/** All input for the `updateEnglishWouldYouRatherQuestionByUuid` mutation. */
export type UpdateEnglishWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `EnglishWouldYouRatherQuestion` being updated. */
  patch: EnglishWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateEnglishWouldYouRatherQuestion` mutation. */
export type UpdateEnglishWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `EnglishWouldYouRatherQuestion` being updated. */
  patch: EnglishWouldYouRatherQuestionPatch;
};

/** The output of our update `EnglishWouldYouRatherQuestion` mutation. */
export type UpdateEnglishWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateEnglishWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWouldYouRatherQuestion` that was updated by this mutation. */
  englishWouldYouRatherQuestion?: Maybe<EnglishWouldYouRatherQuestion>;
  /** An edge for our `EnglishWouldYouRatherQuestion`. May be used by Relay 1. */
  englishWouldYouRatherQuestionEdge?: Maybe<EnglishWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `EnglishWouldYouRatherQuestion` mutation. */
export type UpdateEnglishWouldYouRatherQuestionPayloadEnglishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateFrenchRandomQuestionByNodeId` mutation. */
export type UpdateFrenchRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FrenchRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `FrenchRandomQuestion` being updated. */
  patch: FrenchRandomQuestionPatch;
};

/** All input for the `updateFrenchRandomQuestionByUuid` mutation. */
export type UpdateFrenchRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `FrenchRandomQuestion` being updated. */
  patch: FrenchRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateFrenchRandomQuestion` mutation. */
export type UpdateFrenchRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `FrenchRandomQuestion` being updated. */
  patch: FrenchRandomQuestionPatch;
};

/** The output of our update `FrenchRandomQuestion` mutation. */
export type UpdateFrenchRandomQuestionPayload = {
  __typename?: 'UpdateFrenchRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchRandomQuestion` that was updated by this mutation. */
  frenchRandomQuestion?: Maybe<FrenchRandomQuestion>;
  /** An edge for our `FrenchRandomQuestion`. May be used by Relay 1. */
  frenchRandomQuestionEdge?: Maybe<FrenchRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `FrenchRandomQuestion` mutation. */
export type UpdateFrenchRandomQuestionPayloadFrenchRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchRandomQuestionsOrderBy>>;
};

/** All input for the `updateFrenchWordByNodeId` mutation. */
export type UpdateFrenchWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FrenchWord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `FrenchWord` being updated. */
  patch: FrenchWordPatch;
};

/** All input for the `updateFrenchWordByUuid` mutation. */
export type UpdateFrenchWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `FrenchWord` being updated. */
  patch: FrenchWordPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateFrenchWord` mutation. */
export type UpdateFrenchWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `FrenchWord` being updated. */
  patch: FrenchWordPatch;
};

/** The output of our update `FrenchWord` mutation. */
export type UpdateFrenchWordPayload = {
  __typename?: 'UpdateFrenchWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWord` that was updated by this mutation. */
  frenchWord?: Maybe<FrenchWord>;
  /** An edge for our `FrenchWord`. May be used by Relay 1. */
  frenchWordEdge?: Maybe<FrenchWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `FrenchWord` mutation. */
export type UpdateFrenchWordPayloadFrenchWordEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWordsOrderBy>>;
};

/** All input for the `updateFrenchWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateFrenchWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FrenchWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `FrenchWouldYouRatherQuestion` being updated. */
  patch: FrenchWouldYouRatherQuestionPatch;
};

/** All input for the `updateFrenchWouldYouRatherQuestionByUuid` mutation. */
export type UpdateFrenchWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `FrenchWouldYouRatherQuestion` being updated. */
  patch: FrenchWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateFrenchWouldYouRatherQuestion` mutation. */
export type UpdateFrenchWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `FrenchWouldYouRatherQuestion` being updated. */
  patch: FrenchWouldYouRatherQuestionPatch;
};

/** The output of our update `FrenchWouldYouRatherQuestion` mutation. */
export type UpdateFrenchWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateFrenchWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWouldYouRatherQuestion` that was updated by this mutation. */
  frenchWouldYouRatherQuestion?: Maybe<FrenchWouldYouRatherQuestion>;
  /** An edge for our `FrenchWouldYouRatherQuestion`. May be used by Relay 1. */
  frenchWouldYouRatherQuestionEdge?: Maybe<FrenchWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `FrenchWouldYouRatherQuestion` mutation. */
export type UpdateFrenchWouldYouRatherQuestionPayloadFrenchWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateGermanRandomQuestionByNodeId` mutation. */
export type UpdateGermanRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GermanRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GermanRandomQuestion` being updated. */
  patch: GermanRandomQuestionPatch;
};

/** All input for the `updateGermanRandomQuestionByUuid` mutation. */
export type UpdateGermanRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GermanRandomQuestion` being updated. */
  patch: GermanRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateGermanRandomQuestion` mutation. */
export type UpdateGermanRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `GermanRandomQuestion` being updated. */
  patch: GermanRandomQuestionPatch;
};

/** The output of our update `GermanRandomQuestion` mutation. */
export type UpdateGermanRandomQuestionPayload = {
  __typename?: 'UpdateGermanRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanRandomQuestion` that was updated by this mutation. */
  germanRandomQuestion?: Maybe<GermanRandomQuestion>;
  /** An edge for our `GermanRandomQuestion`. May be used by Relay 1. */
  germanRandomQuestionEdge?: Maybe<GermanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `GermanRandomQuestion` mutation. */
export type UpdateGermanRandomQuestionPayloadGermanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanRandomQuestionsOrderBy>>;
};

/** All input for the `updateGermanWordByNodeId` mutation. */
export type UpdateGermanWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GermanWord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GermanWord` being updated. */
  patch: GermanWordPatch;
};

/** All input for the `updateGermanWordByUuid` mutation. */
export type UpdateGermanWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GermanWord` being updated. */
  patch: GermanWordPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateGermanWord` mutation. */
export type UpdateGermanWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `GermanWord` being updated. */
  patch: GermanWordPatch;
};

/** The output of our update `GermanWord` mutation. */
export type UpdateGermanWordPayload = {
  __typename?: 'UpdateGermanWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWord` that was updated by this mutation. */
  germanWord?: Maybe<GermanWord>;
  /** An edge for our `GermanWord`. May be used by Relay 1. */
  germanWordEdge?: Maybe<GermanWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `GermanWord` mutation. */
export type UpdateGermanWordPayloadGermanWordEdgeArgs = {
  orderBy?: Maybe<Array<GermanWordsOrderBy>>;
};

/** All input for the `updateGermanWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateGermanWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GermanWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GermanWouldYouRatherQuestion` being updated. */
  patch: GermanWouldYouRatherQuestionPatch;
};

/** All input for the `updateGermanWouldYouRatherQuestionByUuid` mutation. */
export type UpdateGermanWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GermanWouldYouRatherQuestion` being updated. */
  patch: GermanWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateGermanWouldYouRatherQuestion` mutation. */
export type UpdateGermanWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `GermanWouldYouRatherQuestion` being updated. */
  patch: GermanWouldYouRatherQuestionPatch;
};

/** The output of our update `GermanWouldYouRatherQuestion` mutation. */
export type UpdateGermanWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateGermanWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWouldYouRatherQuestion` that was updated by this mutation. */
  germanWouldYouRatherQuestion?: Maybe<GermanWouldYouRatherQuestion>;
  /** An edge for our `GermanWouldYouRatherQuestion`. May be used by Relay 1. */
  germanWouldYouRatherQuestionEdge?: Maybe<GermanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `GermanWouldYouRatherQuestion` mutation. */
export type UpdateGermanWouldYouRatherQuestionPayloadGermanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateGroupByNodeId` mutation. */
export type UpdateGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** All input for the `updateGroupByUuid` mutation. */
export type UpdateGroupByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` that was updated by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Reads a single `Language` that is related to this `Group`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Group`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Group` mutation. */
export type UpdateGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the `updateGroupUserByNodeId` mutation. */
export type UpdateGroupUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GroupUser` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GroupUser` being updated. */
  patch: GroupUserPatch;
};

/** All input for the `updateGroupUser` mutation. */
export type UpdateGroupUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `GroupUser` being updated. */
  patch: GroupUserPatch;
};

/** The output of our update `GroupUser` mutation. */
export type UpdateGroupUserPayload = {
  __typename?: 'UpdateGroupUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  /** The `GroupUser` that was updated by this mutation. */
  groupUser?: Maybe<GroupUser>;
  /** An edge for our `GroupUser`. May be used by Relay 1. */
  groupUserEdge?: Maybe<GroupUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
};


/** The output of our update `GroupUser` mutation. */
export type UpdateGroupUserPayloadGroupUserEdgeArgs = {
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};

/** All input for the `updateInviteTokenByNodeId` mutation. */
export type UpdateInviteTokenByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InviteToken` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `InviteToken` being updated. */
  patch: InviteTokenPatch;
};

/** All input for the `updateInviteToken` mutation. */
export type UpdateInviteTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `InviteToken` being updated. */
  patch: InviteTokenPatch;
};

/** The output of our update `InviteToken` mutation. */
export type UpdateInviteTokenPayload = {
  __typename?: 'UpdateInviteTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InviteToken` that was updated by this mutation. */
  inviteToken?: Maybe<InviteToken>;
  /** An edge for our `InviteToken`. May be used by Relay 1. */
  inviteTokenEdge?: Maybe<InviteTokensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `InviteToken`. */
  user?: Maybe<User>;
};


/** The output of our update `InviteToken` mutation. */
export type UpdateInviteTokenPayloadInviteTokenEdgeArgs = {
  orderBy?: Maybe<Array<InviteTokensOrderBy>>;
};

/** All input for the `updateItalianRandomQuestionByNodeId` mutation. */
export type UpdateItalianRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ItalianRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ItalianRandomQuestion` being updated. */
  patch: ItalianRandomQuestionPatch;
};

/** All input for the `updateItalianRandomQuestionByUuid` mutation. */
export type UpdateItalianRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ItalianRandomQuestion` being updated. */
  patch: ItalianRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateItalianRandomQuestion` mutation. */
export type UpdateItalianRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `ItalianRandomQuestion` being updated. */
  patch: ItalianRandomQuestionPatch;
};

/** The output of our update `ItalianRandomQuestion` mutation. */
export type UpdateItalianRandomQuestionPayload = {
  __typename?: 'UpdateItalianRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianRandomQuestion` that was updated by this mutation. */
  italianRandomQuestion?: Maybe<ItalianRandomQuestion>;
  /** An edge for our `ItalianRandomQuestion`. May be used by Relay 1. */
  italianRandomQuestionEdge?: Maybe<ItalianRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `ItalianRandomQuestion` mutation. */
export type UpdateItalianRandomQuestionPayloadItalianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianRandomQuestionsOrderBy>>;
};

/** All input for the `updateItalianWordByNodeId` mutation. */
export type UpdateItalianWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ItalianWord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ItalianWord` being updated. */
  patch: ItalianWordPatch;
};

/** All input for the `updateItalianWordByUuid` mutation. */
export type UpdateItalianWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ItalianWord` being updated. */
  patch: ItalianWordPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateItalianWord` mutation. */
export type UpdateItalianWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `ItalianWord` being updated. */
  patch: ItalianWordPatch;
};

/** The output of our update `ItalianWord` mutation. */
export type UpdateItalianWordPayload = {
  __typename?: 'UpdateItalianWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWord` that was updated by this mutation. */
  italianWord?: Maybe<ItalianWord>;
  /** An edge for our `ItalianWord`. May be used by Relay 1. */
  italianWordEdge?: Maybe<ItalianWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `ItalianWord` mutation. */
export type UpdateItalianWordPayloadItalianWordEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWordsOrderBy>>;
};

/** All input for the `updateItalianWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateItalianWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ItalianWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ItalianWouldYouRatherQuestion` being updated. */
  patch: ItalianWouldYouRatherQuestionPatch;
};

/** All input for the `updateItalianWouldYouRatherQuestionByUuid` mutation. */
export type UpdateItalianWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ItalianWouldYouRatherQuestion` being updated. */
  patch: ItalianWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateItalianWouldYouRatherQuestion` mutation. */
export type UpdateItalianWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `ItalianWouldYouRatherQuestion` being updated. */
  patch: ItalianWouldYouRatherQuestionPatch;
};

/** The output of our update `ItalianWouldYouRatherQuestion` mutation. */
export type UpdateItalianWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateItalianWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWouldYouRatherQuestion` that was updated by this mutation. */
  italianWouldYouRatherQuestion?: Maybe<ItalianWouldYouRatherQuestion>;
  /** An edge for our `ItalianWouldYouRatherQuestion`. May be used by Relay 1. */
  italianWouldYouRatherQuestionEdge?: Maybe<ItalianWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `ItalianWouldYouRatherQuestion` mutation. */
export type UpdateItalianWouldYouRatherQuestionPayloadItalianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateJapaneseRandomQuestionByNodeId` mutation. */
export type UpdateJapaneseRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `JapaneseRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `JapaneseRandomQuestion` being updated. */
  patch: JapaneseRandomQuestionPatch;
};

/** All input for the `updateJapaneseRandomQuestionByUuid` mutation. */
export type UpdateJapaneseRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `JapaneseRandomQuestion` being updated. */
  patch: JapaneseRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateJapaneseRandomQuestion` mutation. */
export type UpdateJapaneseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `JapaneseRandomQuestion` being updated. */
  patch: JapaneseRandomQuestionPatch;
};

/** The output of our update `JapaneseRandomQuestion` mutation. */
export type UpdateJapaneseRandomQuestionPayload = {
  __typename?: 'UpdateJapaneseRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseRandomQuestion` that was updated by this mutation. */
  japaneseRandomQuestion?: Maybe<JapaneseRandomQuestion>;
  /** An edge for our `JapaneseRandomQuestion`. May be used by Relay 1. */
  japaneseRandomQuestionEdge?: Maybe<JapaneseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `JapaneseRandomQuestion` mutation. */
export type UpdateJapaneseRandomQuestionPayloadJapaneseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseRandomQuestionsOrderBy>>;
};

/** All input for the `updateJapaneseWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateJapaneseWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `JapaneseWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `JapaneseWouldYouRatherQuestion` being updated. */
  patch: JapaneseWouldYouRatherQuestionPatch;
};

/** All input for the `updateJapaneseWouldYouRatherQuestionByUuid` mutation. */
export type UpdateJapaneseWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `JapaneseWouldYouRatherQuestion` being updated. */
  patch: JapaneseWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateJapaneseWouldYouRatherQuestion` mutation. */
export type UpdateJapaneseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `JapaneseWouldYouRatherQuestion` being updated. */
  patch: JapaneseWouldYouRatherQuestionPatch;
};

/** The output of our update `JapaneseWouldYouRatherQuestion` mutation. */
export type UpdateJapaneseWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateJapaneseWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseWouldYouRatherQuestion` that was updated by this mutation. */
  japaneseWouldYouRatherQuestion?: Maybe<JapaneseWouldYouRatherQuestion>;
  /** An edge for our `JapaneseWouldYouRatherQuestion`. May be used by Relay 1. */
  japaneseWouldYouRatherQuestionEdge?: Maybe<JapaneseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `JapaneseWouldYouRatherQuestion` mutation. */
export type UpdateJapaneseWouldYouRatherQuestionPayloadJapaneseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateKoreanRandomQuestionByNodeId` mutation. */
export type UpdateKoreanRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `KoreanRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `KoreanRandomQuestion` being updated. */
  patch: KoreanRandomQuestionPatch;
};

/** All input for the `updateKoreanRandomQuestionByUuid` mutation. */
export type UpdateKoreanRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `KoreanRandomQuestion` being updated. */
  patch: KoreanRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateKoreanRandomQuestion` mutation. */
export type UpdateKoreanRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `KoreanRandomQuestion` being updated. */
  patch: KoreanRandomQuestionPatch;
};

/** The output of our update `KoreanRandomQuestion` mutation. */
export type UpdateKoreanRandomQuestionPayload = {
  __typename?: 'UpdateKoreanRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanRandomQuestion` that was updated by this mutation. */
  koreanRandomQuestion?: Maybe<KoreanRandomQuestion>;
  /** An edge for our `KoreanRandomQuestion`. May be used by Relay 1. */
  koreanRandomQuestionEdge?: Maybe<KoreanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `KoreanRandomQuestion` mutation. */
export type UpdateKoreanRandomQuestionPayloadKoreanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanRandomQuestionsOrderBy>>;
};

/** All input for the `updateKoreanWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateKoreanWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `KoreanWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `KoreanWouldYouRatherQuestion` being updated. */
  patch: KoreanWouldYouRatherQuestionPatch;
};

/** All input for the `updateKoreanWouldYouRatherQuestionByUuid` mutation. */
export type UpdateKoreanWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `KoreanWouldYouRatherQuestion` being updated. */
  patch: KoreanWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateKoreanWouldYouRatherQuestion` mutation. */
export type UpdateKoreanWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `KoreanWouldYouRatherQuestion` being updated. */
  patch: KoreanWouldYouRatherQuestionPatch;
};

/** The output of our update `KoreanWouldYouRatherQuestion` mutation. */
export type UpdateKoreanWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateKoreanWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanWouldYouRatherQuestion` that was updated by this mutation. */
  koreanWouldYouRatherQuestion?: Maybe<KoreanWouldYouRatherQuestion>;
  /** An edge for our `KoreanWouldYouRatherQuestion`. May be used by Relay 1. */
  koreanWouldYouRatherQuestionEdge?: Maybe<KoreanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `KoreanWouldYouRatherQuestion` mutation. */
export type UpdateKoreanWouldYouRatherQuestionPayloadKoreanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateLanguageByAlpha2` mutation. */
export type UpdateLanguageByAlpha2Input = {
  /** ISO 3166-1 alpha-2 standardized code */
  alpha2: Scalars['String'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Language` being updated. */
  patch: LanguagePatch;
};

/** All input for the `updateLanguageByEnglishName` mutation. */
export type UpdateLanguageByEnglishNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  englishName: Scalars['String'];
  /** An object where the defined keys will be set on the `Language` being updated. */
  patch: LanguagePatch;
};

/** All input for the `updateLanguageByNodeId` mutation. */
export type UpdateLanguageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Language` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Language` being updated. */
  patch: LanguagePatch;
};

/** All input for the `updateLanguage` mutation. */
export type UpdateLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Language` being updated. */
  patch: LanguagePatch;
};

/** The output of our update `Language` mutation. */
export type UpdateLanguagePayload = {
  __typename?: 'UpdateLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Language` that was updated by this mutation. */
  language?: Maybe<Language>;
  /** An edge for our `Language`. May be used by Relay 1. */
  languageEdge?: Maybe<LanguagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Language` mutation. */
export type UpdateLanguagePayloadLanguageEdgeArgs = {
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};

/** All input for the `updateLanguageSkillLevelByNodeId` mutation. */
export type UpdateLanguageSkillLevelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LanguageSkillLevel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LanguageSkillLevel` being updated. */
  patch: LanguageSkillLevelPatch;
};

/** All input for the `updateLanguageSkillLevel` mutation. */
export type UpdateLanguageSkillLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `LanguageSkillLevel` being updated. */
  patch: LanguageSkillLevelPatch;
};

/** The output of our update `LanguageSkillLevel` mutation. */
export type UpdateLanguageSkillLevelPayload = {
  __typename?: 'UpdateLanguageSkillLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LanguageSkillLevel` that was updated by this mutation. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** An edge for our `LanguageSkillLevel`. May be used by Relay 1. */
  languageSkillLevelEdge?: Maybe<LanguageSkillLevelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `LanguageSkillLevel` mutation. */
export type UpdateLanguageSkillLevelPayloadLanguageSkillLevelEdgeArgs = {
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};

/** All input for the `updateMessageByNodeId` mutation. */
export type UpdateMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Message` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Message` being updated. */
  patch: MessagePatch;
};

/** All input for the `updateMessageByUuid` mutation. */
export type UpdateMessageByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Message` being updated. */
  patch: MessagePatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateMessage` mutation. */
export type UpdateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Message` being updated. */
  patch: MessagePatch;
};

/** The output of our update `Message` mutation. */
export type UpdateMessagePayload = {
  __typename?: 'UpdateMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was updated by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Reads a single `Message` that is related to this `Message`. */
  parentMessage?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Message`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Message`. */
  recipientGroup?: Maybe<Group>;
  /** Reads a single `User` that is related to this `Message`. */
  sender?: Maybe<User>;
};


/** The output of our update `Message` mutation. */
export type UpdateMessagePayloadMessageEdgeArgs = {
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** All input for the `updateMessagePreviewByNodeId` mutation. */
export type UpdateMessagePreviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MessagePreview` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `MessagePreview` being updated. */
  patch: MessagePreviewPatch;
};

/** All input for the `updateMessagePreviewByUuid` mutation. */
export type UpdateMessagePreviewByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `MessagePreview` being updated. */
  patch: MessagePreviewPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateMessagePreview` mutation. */
export type UpdateMessagePreviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `MessagePreview` being updated. */
  patch: MessagePreviewPatch;
};

/** The output of our update `MessagePreview` mutation. */
export type UpdateMessagePreviewPayload = {
  __typename?: 'UpdateMessagePreviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Message` that is related to this `MessagePreview`. */
  message?: Maybe<Message>;
  /** The `MessagePreview` that was updated by this mutation. */
  messagePreview?: Maybe<MessagePreview>;
  /** An edge for our `MessagePreview`. May be used by Relay 1. */
  messagePreviewEdge?: Maybe<MessagePreviewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `MessagePreview` mutation. */
export type UpdateMessagePreviewPayloadMessagePreviewEdgeArgs = {
  orderBy?: Maybe<Array<MessagePreviewsOrderBy>>;
};

/** All input for the `updateNotificationByNodeId` mutation. */
export type UpdateNotificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Notification` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
};

/** All input for the `updateNotificationByUuid` mutation. */
export type UpdateNotificationByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateNotificationChannelByName` mutation. */
export type UpdateNotificationChannelByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  /** An object where the defined keys will be set on the `NotificationChannel` being updated. */
  patch: NotificationChannelPatch;
};

/** All input for the `updateNotificationChannelByNodeId` mutation. */
export type UpdateNotificationChannelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `NotificationChannel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `NotificationChannel` being updated. */
  patch: NotificationChannelPatch;
};

/** All input for the `updateNotificationChannelByUuid` mutation. */
export type UpdateNotificationChannelByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `NotificationChannel` being updated. */
  patch: NotificationChannelPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateNotificationChannel` mutation. */
export type UpdateNotificationChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `NotificationChannel` being updated. */
  patch: NotificationChannelPatch;
};

/** The output of our update `NotificationChannel` mutation. */
export type UpdateNotificationChannelPayload = {
  __typename?: 'UpdateNotificationChannelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `NotificationChannel` that was updated by this mutation. */
  notificationChannel?: Maybe<NotificationChannel>;
  /** An edge for our `NotificationChannel`. May be used by Relay 1. */
  notificationChannelEdge?: Maybe<NotificationChannelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `NotificationChannel` mutation. */
export type UpdateNotificationChannelPayloadNotificationChannelEdgeArgs = {
  orderBy?: Maybe<Array<NotificationChannelsOrderBy>>;
};

/** All input for the `updateNotification` mutation. */
export type UpdateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
};

/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayload = {
  __typename?: 'UpdateNotificationPayload';
  /** Reads a single `NotificationChannel` that is related to this `Notification`. */
  channel?: Maybe<NotificationChannel>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was updated by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Notification`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Notification`. */
  recipientGroup?: Maybe<Group>;
};


/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** All input for the `updatePortugueseRandomQuestionByNodeId` mutation. */
export type UpdatePortugueseRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PortugueseRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PortugueseRandomQuestion` being updated. */
  patch: PortugueseRandomQuestionPatch;
};

/** All input for the `updatePortugueseRandomQuestionByUuid` mutation. */
export type UpdatePortugueseRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PortugueseRandomQuestion` being updated. */
  patch: PortugueseRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePortugueseRandomQuestion` mutation. */
export type UpdatePortugueseRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PortugueseRandomQuestion` being updated. */
  patch: PortugueseRandomQuestionPatch;
};

/** The output of our update `PortugueseRandomQuestion` mutation. */
export type UpdatePortugueseRandomQuestionPayload = {
  __typename?: 'UpdatePortugueseRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseRandomQuestion` that was updated by this mutation. */
  portugueseRandomQuestion?: Maybe<PortugueseRandomQuestion>;
  /** An edge for our `PortugueseRandomQuestion`. May be used by Relay 1. */
  portugueseRandomQuestionEdge?: Maybe<PortugueseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `PortugueseRandomQuestion` mutation. */
export type UpdatePortugueseRandomQuestionPayloadPortugueseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseRandomQuestionsOrderBy>>;
};

/** All input for the `updatePortugueseWordByNodeId` mutation. */
export type UpdatePortugueseWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PortugueseWord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PortugueseWord` being updated. */
  patch: PortugueseWordPatch;
};

/** All input for the `updatePortugueseWordByUuid` mutation. */
export type UpdatePortugueseWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PortugueseWord` being updated. */
  patch: PortugueseWordPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePortugueseWord` mutation. */
export type UpdatePortugueseWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PortugueseWord` being updated. */
  patch: PortugueseWordPatch;
};

/** The output of our update `PortugueseWord` mutation. */
export type UpdatePortugueseWordPayload = {
  __typename?: 'UpdatePortugueseWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWord` that was updated by this mutation. */
  portugueseWord?: Maybe<PortugueseWord>;
  /** An edge for our `PortugueseWord`. May be used by Relay 1. */
  portugueseWordEdge?: Maybe<PortugueseWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `PortugueseWord` mutation. */
export type UpdatePortugueseWordPayloadPortugueseWordEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWordsOrderBy>>;
};

/** All input for the `updatePortugueseWouldYouRatherQuestionByNodeId` mutation. */
export type UpdatePortugueseWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PortugueseWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PortugueseWouldYouRatherQuestion` being updated. */
  patch: PortugueseWouldYouRatherQuestionPatch;
};

/** All input for the `updatePortugueseWouldYouRatherQuestionByUuid` mutation. */
export type UpdatePortugueseWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PortugueseWouldYouRatherQuestion` being updated. */
  patch: PortugueseWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePortugueseWouldYouRatherQuestion` mutation. */
export type UpdatePortugueseWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PortugueseWouldYouRatherQuestion` being updated. */
  patch: PortugueseWouldYouRatherQuestionPatch;
};

/** The output of our update `PortugueseWouldYouRatherQuestion` mutation. */
export type UpdatePortugueseWouldYouRatherQuestionPayload = {
  __typename?: 'UpdatePortugueseWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWouldYouRatherQuestion` that was updated by this mutation. */
  portugueseWouldYouRatherQuestion?: Maybe<PortugueseWouldYouRatherQuestion>;
  /** An edge for our `PortugueseWouldYouRatherQuestion`. May be used by Relay 1. */
  portugueseWouldYouRatherQuestionEdge?: Maybe<PortugueseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `PortugueseWouldYouRatherQuestion` mutation. */
export type UpdatePortugueseWouldYouRatherQuestionPayloadPortugueseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updatePostByNodeId` mutation. */
export type UpdatePostByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Post` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Post` being updated. */
  patch: PostPatch;
};

/** All input for the `updatePostBySnowflakeId` mutation. */
export type UpdatePostBySnowflakeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Post` being updated. */
  patch: PostPatch;
  snowflakeId: Scalars['BigInt'];
};

/** All input for the `updatePostByUuid` mutation. */
export type UpdatePostByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Post` being updated. */
  patch: PostPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePostCorrectionByNodeId` mutation. */
export type UpdatePostCorrectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostCorrection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PostCorrection` being updated. */
  patch: PostCorrectionPatch;
};

/** All input for the `updatePostCorrectionByUuid` mutation. */
export type UpdatePostCorrectionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PostCorrection` being updated. */
  patch: PostCorrectionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePostCorrection` mutation. */
export type UpdatePostCorrectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PostCorrection` being updated. */
  patch: PostCorrectionPatch;
};

/** The output of our update `PostCorrection` mutation. */
export type UpdatePostCorrectionPayload = {
  __typename?: 'UpdatePostCorrectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostCorrection`. */
  post?: Maybe<Post>;
  /** The `PostCorrection` that was updated by this mutation. */
  postCorrection?: Maybe<PostCorrection>;
  /** An edge for our `PostCorrection`. May be used by Relay 1. */
  postCorrectionEdge?: Maybe<PostCorrectionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostCorrection`. */
  user?: Maybe<User>;
};


/** The output of our update `PostCorrection` mutation. */
export type UpdatePostCorrectionPayloadPostCorrectionEdgeArgs = {
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};

/** All input for the `updatePostGameAnswerByNodeId` mutation. */
export type UpdatePostGameAnswerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostGameAnswer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PostGameAnswer` being updated. */
  patch: PostGameAnswerPatch;
};

/** All input for the `updatePostGameAnswerByUuid` mutation. */
export type UpdatePostGameAnswerByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PostGameAnswer` being updated. */
  patch: PostGameAnswerPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePostGameAnswer` mutation. */
export type UpdatePostGameAnswerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PostGameAnswer` being updated. */
  patch: PostGameAnswerPatch;
};

/** The output of our update `PostGameAnswer` mutation. */
export type UpdatePostGameAnswerPayload = {
  __typename?: 'UpdatePostGameAnswerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `PostGame` that is related to this `PostGameAnswer`. */
  game?: Maybe<PostGame>;
  /** The `PostGameAnswer` that was updated by this mutation. */
  postGameAnswer?: Maybe<PostGameAnswer>;
  /** An edge for our `PostGameAnswer`. May be used by Relay 1. */
  postGameAnswerEdge?: Maybe<PostGameAnswersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PostGameRange` that is related to this `PostGameAnswer`. */
  range?: Maybe<PostGameRange>;
  /** Reads a single `User` that is related to this `PostGameAnswer`. */
  user?: Maybe<User>;
};


/** The output of our update `PostGameAnswer` mutation. */
export type UpdatePostGameAnswerPayloadPostGameAnswerEdgeArgs = {
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** All input for the `updatePostGameByNodeId` mutation. */
export type UpdatePostGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostGame` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PostGame` being updated. */
  patch: PostGamePatch;
};

/** All input for the `updatePostGameByUuid` mutation. */
export type UpdatePostGameByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PostGame` being updated. */
  patch: PostGamePatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePostGame` mutation. */
export type UpdatePostGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PostGame` being updated. */
  patch: PostGamePatch;
};

/** The output of our update `PostGame` mutation. */
export type UpdatePostGamePayload = {
  __typename?: 'UpdatePostGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostGame`. */
  post?: Maybe<Post>;
  /** The `PostGame` that was updated by this mutation. */
  postGame?: Maybe<PostGame>;
  /** An edge for our `PostGame`. May be used by Relay 1. */
  postGameEdge?: Maybe<PostGamesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PostGame` mutation. */
export type UpdatePostGamePayloadPostGameEdgeArgs = {
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};

/** All input for the `updatePostGameRangeByNodeId` mutation. */
export type UpdatePostGameRangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostGameRange` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PostGameRange` being updated. */
  patch: PostGameRangePatch;
};

/** All input for the `updatePostGameRangeByUuid` mutation. */
export type UpdatePostGameRangeByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PostGameRange` being updated. */
  patch: PostGameRangePatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePostGameRange` mutation. */
export type UpdatePostGameRangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PostGameRange` being updated. */
  patch: PostGameRangePatch;
};

/** The output of our update `PostGameRange` mutation. */
export type UpdatePostGameRangePayload = {
  __typename?: 'UpdatePostGameRangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `PostGame` that is related to this `PostGameRange`. */
  game?: Maybe<PostGame>;
  /** The `PostGameRange` that was updated by this mutation. */
  postGameRange?: Maybe<PostGameRange>;
  /** An edge for our `PostGameRange`. May be used by Relay 1. */
  postGameRangeEdge?: Maybe<PostGameRangesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PostGameRange` mutation. */
export type UpdatePostGameRangePayloadPostGameRangeEdgeArgs = {
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};

/** All input for the `updatePost` mutation. */
export type UpdatePostInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Post` being updated. */
  patch: PostPatch;
};

/** All input for the `updatePostLikeByNodeId` mutation. */
export type UpdatePostLikeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostLike` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PostLike` being updated. */
  patch: PostLikePatch;
};

/** All input for the `updatePostLike` mutation. */
export type UpdatePostLikeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PostLike` being updated. */
  patch: PostLikePatch;
};

/** The output of our update `PostLike` mutation. */
export type UpdatePostLikePayload = {
  __typename?: 'UpdatePostLikePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostLike`. */
  post?: Maybe<Post>;
  /** The `PostLike` that was updated by this mutation. */
  postLike?: Maybe<PostLike>;
  /** An edge for our `PostLike`. May be used by Relay 1. */
  postLikeEdge?: Maybe<PostLikesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostLike`. */
  user?: Maybe<User>;
};


/** The output of our update `PostLike` mutation. */
export type UpdatePostLikePayloadPostLikeEdgeArgs = {
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};

/** The output of our update `Post` mutation. */
export type UpdatePostPayload = {
  __typename?: 'UpdatePostPayload';
  /** Reads a single `User` that is related to this `Post`. */
  author?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `Post`. */
  language?: Maybe<Language>;
  /** Reads a single `Post` that is related to this `Post`. */
  parentPost?: Maybe<Post>;
  /** The `Post` that was updated by this mutation. */
  post?: Maybe<Post>;
  /** An edge for our `Post`. May be used by Relay 1. */
  postEdge?: Maybe<PostsEdge>;
  /** Reads a single `Prompt` that is related to this `Post`. */
  prompt?: Maybe<Prompt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Post` mutation. */
export type UpdatePostPayloadPostEdgeArgs = {
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** All input for the `updatePostRecordingByNodeId` mutation. */
export type UpdatePostRecordingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostRecording` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PostRecording` being updated. */
  patch: PostRecordingPatch;
};

/** All input for the `updatePostRecordingByUuid` mutation. */
export type UpdatePostRecordingByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PostRecording` being updated. */
  patch: PostRecordingPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePostRecording` mutation. */
export type UpdatePostRecordingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PostRecording` being updated. */
  patch: PostRecordingPatch;
};

/** The output of our update `PostRecording` mutation. */
export type UpdatePostRecordingPayload = {
  __typename?: 'UpdatePostRecordingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostRecording`. */
  post?: Maybe<Post>;
  /** The `PostRecording` that was updated by this mutation. */
  postRecording?: Maybe<PostRecording>;
  /** An edge for our `PostRecording`. May be used by Relay 1. */
  postRecordingEdge?: Maybe<PostRecordingsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostRecording`. */
  user?: Maybe<User>;
};


/** The output of our update `PostRecording` mutation. */
export type UpdatePostRecordingPayloadPostRecordingEdgeArgs = {
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};

/** All input for the `updatePostUserMentionByNodeId` mutation. */
export type UpdatePostUserMentionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PostUserMention` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PostUserMention` being updated. */
  patch: PostUserMentionPatch;
};

/** All input for the `updatePostUserMentionByUuid` mutation. */
export type UpdatePostUserMentionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PostUserMention` being updated. */
  patch: PostUserMentionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePostUserMention` mutation. */
export type UpdatePostUserMentionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `PostUserMention` being updated. */
  patch: PostUserMentionPatch;
};

/** The output of our update `PostUserMention` mutation. */
export type UpdatePostUserMentionPayload = {
  __typename?: 'UpdatePostUserMentionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostUserMention`. */
  post?: Maybe<Post>;
  /** The `PostUserMention` that was updated by this mutation. */
  postUserMention?: Maybe<PostUserMention>;
  /** An edge for our `PostUserMention`. May be used by Relay 1. */
  postUserMentionEdge?: Maybe<PostUserMentionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostUserMention`. */
  user?: Maybe<User>;
};


/** The output of our update `PostUserMention` mutation. */
export type UpdatePostUserMentionPayloadPostUserMentionEdgeArgs = {
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};

/** All input for the `updatePromptByNodeId` mutation. */
export type UpdatePromptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Prompt` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Prompt` being updated. */
  patch: PromptPatch;
};

/** All input for the `updatePromptByUuid` mutation. */
export type UpdatePromptByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Prompt` being updated. */
  patch: PromptPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updatePrompt` mutation. */
export type UpdatePromptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `Prompt` being updated. */
  patch: PromptPatch;
};

/** The output of our update `Prompt` mutation. */
export type UpdatePromptPayload = {
  __typename?: 'UpdatePromptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `Prompt`. */
  language?: Maybe<Language>;
  /** The `Prompt` that was updated by this mutation. */
  prompt?: Maybe<Prompt>;
  /** An edge for our `Prompt`. May be used by Relay 1. */
  promptEdge?: Maybe<PromptsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Prompt`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our update `Prompt` mutation. */
export type UpdatePromptPayloadPromptEdgeArgs = {
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};

/** All input for the `updateRussianRandomQuestionByNodeId` mutation. */
export type UpdateRussianRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RussianRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RussianRandomQuestion` being updated. */
  patch: RussianRandomQuestionPatch;
};

/** All input for the `updateRussianRandomQuestionByUuid` mutation. */
export type UpdateRussianRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RussianRandomQuestion` being updated. */
  patch: RussianRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateRussianRandomQuestion` mutation. */
export type UpdateRussianRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `RussianRandomQuestion` being updated. */
  patch: RussianRandomQuestionPatch;
};

/** The output of our update `RussianRandomQuestion` mutation. */
export type UpdateRussianRandomQuestionPayload = {
  __typename?: 'UpdateRussianRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianRandomQuestion` that was updated by this mutation. */
  russianRandomQuestion?: Maybe<RussianRandomQuestion>;
  /** An edge for our `RussianRandomQuestion`. May be used by Relay 1. */
  russianRandomQuestionEdge?: Maybe<RussianRandomQuestionsEdge>;
};


/** The output of our update `RussianRandomQuestion` mutation. */
export type UpdateRussianRandomQuestionPayloadRussianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianRandomQuestionsOrderBy>>;
};

/** All input for the `updateRussianWordByNodeId` mutation. */
export type UpdateRussianWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RussianWord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RussianWord` being updated. */
  patch: RussianWordPatch;
};

/** All input for the `updateRussianWordByUuid` mutation. */
export type UpdateRussianWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RussianWord` being updated. */
  patch: RussianWordPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateRussianWord` mutation. */
export type UpdateRussianWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `RussianWord` being updated. */
  patch: RussianWordPatch;
};

/** The output of our update `RussianWord` mutation. */
export type UpdateRussianWordPayload = {
  __typename?: 'UpdateRussianWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWord` that was updated by this mutation. */
  russianWord?: Maybe<RussianWord>;
  /** An edge for our `RussianWord`. May be used by Relay 1. */
  russianWordEdge?: Maybe<RussianWordsEdge>;
};


/** The output of our update `RussianWord` mutation. */
export type UpdateRussianWordPayloadRussianWordEdgeArgs = {
  orderBy?: Maybe<Array<RussianWordsOrderBy>>;
};

/** All input for the `updateRussianWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateRussianWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RussianWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RussianWouldYouRatherQuestion` being updated. */
  patch: RussianWouldYouRatherQuestionPatch;
};

/** All input for the `updateRussianWouldYouRatherQuestionByUuid` mutation. */
export type UpdateRussianWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RussianWouldYouRatherQuestion` being updated. */
  patch: RussianWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateRussianWouldYouRatherQuestion` mutation. */
export type UpdateRussianWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `RussianWouldYouRatherQuestion` being updated. */
  patch: RussianWouldYouRatherQuestionPatch;
};

/** The output of our update `RussianWouldYouRatherQuestion` mutation. */
export type UpdateRussianWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateRussianWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWouldYouRatherQuestion` that was updated by this mutation. */
  russianWouldYouRatherQuestion?: Maybe<RussianWouldYouRatherQuestion>;
  /** An edge for our `RussianWouldYouRatherQuestion`. May be used by Relay 1. */
  russianWouldYouRatherQuestionEdge?: Maybe<RussianWouldYouRatherQuestionsEdge>;
};


/** The output of our update `RussianWouldYouRatherQuestion` mutation. */
export type UpdateRussianWouldYouRatherQuestionPayloadRussianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateSpanishRandomQuestionByNodeId` mutation. */
export type UpdateSpanishRandomQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpanishRandomQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SpanishRandomQuestion` being updated. */
  patch: SpanishRandomQuestionPatch;
};

/** All input for the `updateSpanishRandomQuestionByUuid` mutation. */
export type UpdateSpanishRandomQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SpanishRandomQuestion` being updated. */
  patch: SpanishRandomQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateSpanishRandomQuestion` mutation. */
export type UpdateSpanishRandomQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `SpanishRandomQuestion` being updated. */
  patch: SpanishRandomQuestionPatch;
};

/** The output of our update `SpanishRandomQuestion` mutation. */
export type UpdateSpanishRandomQuestionPayload = {
  __typename?: 'UpdateSpanishRandomQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishRandomQuestion` that was updated by this mutation. */
  spanishRandomQuestion?: Maybe<SpanishRandomQuestion>;
  /** An edge for our `SpanishRandomQuestion`. May be used by Relay 1. */
  spanishRandomQuestionEdge?: Maybe<SpanishRandomQuestionsEdge>;
};


/** The output of our update `SpanishRandomQuestion` mutation. */
export type UpdateSpanishRandomQuestionPayloadSpanishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishRandomQuestionsOrderBy>>;
};

/** All input for the `updateSpanishWordByNodeId` mutation. */
export type UpdateSpanishWordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpanishWord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SpanishWord` being updated. */
  patch: SpanishWordPatch;
};

/** All input for the `updateSpanishWordByUuid` mutation. */
export type UpdateSpanishWordByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SpanishWord` being updated. */
  patch: SpanishWordPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateSpanishWord` mutation. */
export type UpdateSpanishWordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `SpanishWord` being updated. */
  patch: SpanishWordPatch;
};

/** The output of our update `SpanishWord` mutation. */
export type UpdateSpanishWordPayload = {
  __typename?: 'UpdateSpanishWordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWord` that was updated by this mutation. */
  spanishWord?: Maybe<SpanishWord>;
  /** An edge for our `SpanishWord`. May be used by Relay 1. */
  spanishWordEdge?: Maybe<SpanishWordsEdge>;
};


/** The output of our update `SpanishWord` mutation. */
export type UpdateSpanishWordPayloadSpanishWordEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWordsOrderBy>>;
};

/** All input for the `updateSpanishWouldYouRatherQuestionByNodeId` mutation. */
export type UpdateSpanishWouldYouRatherQuestionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpanishWouldYouRatherQuestion` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SpanishWouldYouRatherQuestion` being updated. */
  patch: SpanishWouldYouRatherQuestionPatch;
};

/** All input for the `updateSpanishWouldYouRatherQuestionByUuid` mutation. */
export type UpdateSpanishWouldYouRatherQuestionByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SpanishWouldYouRatherQuestion` being updated. */
  patch: SpanishWouldYouRatherQuestionPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateSpanishWouldYouRatherQuestion` mutation. */
export type UpdateSpanishWouldYouRatherQuestionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `SpanishWouldYouRatherQuestion` being updated. */
  patch: SpanishWouldYouRatherQuestionPatch;
};

/** The output of our update `SpanishWouldYouRatherQuestion` mutation. */
export type UpdateSpanishWouldYouRatherQuestionPayload = {
  __typename?: 'UpdateSpanishWouldYouRatherQuestionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWouldYouRatherQuestion` that was updated by this mutation. */
  spanishWouldYouRatherQuestion?: Maybe<SpanishWouldYouRatherQuestion>;
  /** An edge for our `SpanishWouldYouRatherQuestion`. May be used by Relay 1. */
  spanishWouldYouRatherQuestionEdge?: Maybe<SpanishWouldYouRatherQuestionsEdge>;
};


/** The output of our update `SpanishWouldYouRatherQuestion` mutation. */
export type UpdateSpanishWouldYouRatherQuestionPayloadSpanishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWouldYouRatherQuestionsOrderBy>>;
};

/** All input for the `updateUserByEmail` mutation. */
export type UpdateUserByEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByEmailUnsubscribeToken` mutation. */
export type UpdateUserByEmailUnsubscribeTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  emailUnsubscribeToken: Scalars['String'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByResetPasswordToken` mutation. */
export type UpdateUserByResetPasswordTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  resetPasswordToken: Scalars['String'];
};

/** All input for the `updateUserByUsername` mutation. */
export type UpdateUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  username: Scalars['String'];
};

/** All input for the `updateUserByUuid` mutation. */
export type UpdateUserByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateUserDeviceByFcmToken` mutation. */
export type UpdateUserDeviceByFcmTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  fcmToken: Scalars['String'];
  /** An object where the defined keys will be set on the `UserDevice` being updated. */
  patch: UserDevicePatch;
};

/** All input for the `updateUserDeviceByNodeId` mutation. */
export type UpdateUserDeviceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserDevice` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserDevice` being updated. */
  patch: UserDevicePatch;
};

/** All input for the `updateUserDeviceByUuid` mutation. */
export type UpdateUserDeviceByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserDevice` being updated. */
  patch: UserDevicePatch;
  uuid: Scalars['UUID'];
};

/** All input for the `updateUserDevice` mutation. */
export type UpdateUserDeviceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `UserDevice` being updated. */
  patch: UserDevicePatch;
};

/** The output of our update `UserDevice` mutation. */
export type UpdateUserDevicePayload = {
  __typename?: 'UpdateUserDevicePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserDevice`. */
  user?: Maybe<User>;
  /** The `UserDevice` that was updated by this mutation. */
  userDevice?: Maybe<UserDevice>;
  /** An edge for our `UserDevice`. May be used by Relay 1. */
  userDeviceEdge?: Maybe<UserDevicesEdge>;
};


/** The output of our update `UserDevice` mutation. */
export type UpdateUserDevicePayloadUserDeviceEdgeArgs = {
  orderBy?: Maybe<Array<UserDevicesOrderBy>>;
};

/** All input for the `updateUserFollowerByNodeId` mutation. */
export type UpdateUserFollowerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserFollower` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserFollower` being updated. */
  patch: UserFollowerPatch;
};

/** All input for the `updateUserFollower` mutation. */
export type UpdateUserFollowerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `UserFollower` being updated. */
  patch: UserFollowerPatch;
};

/** The output of our update `UserFollower` mutation. */
export type UpdateUserFollowerPayload = {
  __typename?: 'UpdateUserFollowerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  follower?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  user?: Maybe<User>;
  /** The `UserFollower` that was updated by this mutation. */
  userFollower?: Maybe<UserFollower>;
  /** An edge for our `UserFollower`. May be used by Relay 1. */
  userFollowerEdge?: Maybe<UserFollowersEdge>;
};


/** The output of our update `UserFollower` mutation. */
export type UpdateUserFollowerPayloadUserFollowerEdgeArgs = {
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserLanguageByNodeId` mutation. */
export type UpdateUserLanguageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserLanguage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserLanguage` being updated. */
  patch: UserLanguagePatch;
};

/** All input for the `updateUserLanguage` mutation. */
export type UpdateUserLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `UserLanguage` being updated. */
  patch: UserLanguagePatch;
};

/** The output of our update `UserLanguage` mutation. */
export type UpdateUserLanguagePayload = {
  __typename?: 'UpdateUserLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `UserLanguage`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `UserLanguage`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserLanguage`. */
  user?: Maybe<User>;
  /** The `UserLanguage` that was updated by this mutation. */
  userLanguage?: Maybe<UserLanguage>;
  /** An edge for our `UserLanguage`. May be used by Relay 1. */
  userLanguageEdge?: Maybe<UserLanguagesEdge>;
};


/** The output of our update `UserLanguage` mutation. */
export type UpdateUserLanguagePayloadUserLanguageEdgeArgs = {
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `User`. */
  languageByLocale?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `InviteToken` that is related to this `User`. */
  signedUpWithToken?: Maybe<InviteToken>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserPreferenceByNodeId` mutation. */
export type UpdateUserPreferenceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserPreference` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserPreference` being updated. */
  patch: UserPreferencePatch;
};

/** All input for the `updateUserPreferenceByUserId` mutation. */
export type UpdateUserPreferenceByUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserPreference` being updated. */
  patch: UserPreferencePatch;
  userId: Scalars['Int'];
};

/** All input for the `updateUserPreference` mutation. */
export type UpdateUserPreferenceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** An object where the defined keys will be set on the `UserPreference` being updated. */
  patch: UserPreferencePatch;
};

/** The output of our update `UserPreference` mutation. */
export type UpdateUserPreferencePayload = {
  __typename?: 'UpdateUserPreferencePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `UserPreference`. */
  feedLanguage?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserPreference`. */
  user?: Maybe<User>;
  /** The `UserPreference` that was updated by this mutation. */
  userPreference?: Maybe<UserPreference>;
  /** An edge for our `UserPreference`. May be used by Relay 1. */
  userPreferenceEdge?: Maybe<UserPreferencesEdge>;
};


/** The output of our update `UserPreference` mutation. */
export type UpdateUserPreferencePayloadUserPreferenceEdgeArgs = {
  orderBy?: Maybe<Array<UserPreferencesOrderBy>>;
};

/** All input for the `updateUserSessionByNodeId` mutation. */
export type UpdateUserSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserSession` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserSession` being updated. */
  patch: UserSessionPatch;
};

/** All input for the `updateUserSession` mutation. */
export type UpdateUserSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserSession` being updated. */
  patch: UserSessionPatch;
  sid: Scalars['String'];
};

/** The output of our update `UserSession` mutation. */
export type UpdateUserSessionPayload = {
  __typename?: 'UpdateUserSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserSession` that was updated by this mutation. */
  userSession?: Maybe<UserSession>;
  /** An edge for our `UserSession`. May be used by Relay 1. */
  userSessionEdge?: Maybe<UserSessionsEdge>;
};


/** The output of our update `UserSession` mutation. */
export type UpdateUserSessionPayloadUserSessionEdgeArgs = {
  orderBy?: Maybe<Array<UserSessionsOrderBy>>;
};

/** All input for the upsert `ChineseGuessCharacterQuestion` mutation. */
export type UpsertChineseGuessCharacterQuestionInput = {
  /** The `ChineseGuessCharacterQuestion` to be upserted by this mutation. */
  chineseGuessCharacterQuestion: ChineseGuessCharacterQuestionInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our upsert `ChineseGuessCharacterQuestion` mutation. */
export type UpsertChineseGuessCharacterQuestionPayload = {
  __typename?: 'UpsertChineseGuessCharacterQuestionPayload';
  /** The `ChineseGuessCharacterQuestion` that was upserted by this mutation. */
  chineseGuessCharacterQuestion?: Maybe<ChineseGuessCharacterQuestion>;
  /** An edge for our `ChineseGuessCharacterQuestion`. May be used by Relay 1. */
  chineseGuessCharacterQuestionEdge?: Maybe<ChineseGuessCharacterQuestionsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseGuessCharacterQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `ChineseGuessCharacterQuestion` mutation. */
export type UpsertChineseGuessCharacterQuestionPayloadChineseGuessCharacterQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseGuessCharacterQuestionsOrderBy>>;
};

/** Where conditions for the upsert `ChineseGuessCharacterQuestion` mutation. */
export type UpsertChineseGuessCharacterQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `ChineseRandomQuestion` mutation. */
export type UpsertChineseRandomQuestionInput = {
  /** The `ChineseRandomQuestion` to be upserted by this mutation. */
  chineseRandomQuestion: ChineseRandomQuestionInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our upsert `ChineseRandomQuestion` mutation. */
export type UpsertChineseRandomQuestionPayload = {
  __typename?: 'UpsertChineseRandomQuestionPayload';
  /** The `ChineseRandomQuestion` that was upserted by this mutation. */
  chineseRandomQuestion?: Maybe<ChineseRandomQuestion>;
  /** An edge for our `ChineseRandomQuestion`. May be used by Relay 1. */
  chineseRandomQuestionEdge?: Maybe<ChineseRandomQuestionsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `ChineseRandomQuestion` mutation. */
export type UpsertChineseRandomQuestionPayloadChineseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `ChineseRandomQuestion` mutation. */
export type UpsertChineseRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `ChineseWouldYouRatherQuestion` mutation. */
export type UpsertChineseWouldYouRatherQuestionInput = {
  /** The `ChineseWouldYouRatherQuestion` to be upserted by this mutation. */
  chineseWouldYouRatherQuestion: ChineseWouldYouRatherQuestionInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our upsert `ChineseWouldYouRatherQuestion` mutation. */
export type UpsertChineseWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertChineseWouldYouRatherQuestionPayload';
  /** The `ChineseWouldYouRatherQuestion` that was upserted by this mutation. */
  chineseWouldYouRatherQuestion?: Maybe<ChineseWouldYouRatherQuestion>;
  /** An edge for our `ChineseWouldYouRatherQuestion`. May be used by Relay 1. */
  chineseWouldYouRatherQuestionEdge?: Maybe<ChineseWouldYouRatherQuestionsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ChineseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `ChineseWouldYouRatherQuestion` mutation. */
export type UpsertChineseWouldYouRatherQuestionPayloadChineseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ChineseWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `ChineseWouldYouRatherQuestion` mutation. */
export type UpsertChineseWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `EnglishRandomQuestion` mutation. */
export type UpsertEnglishRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishRandomQuestion` to be upserted by this mutation. */
  englishRandomQuestion: EnglishRandomQuestionInput;
};

/** The output of our upsert `EnglishRandomQuestion` mutation. */
export type UpsertEnglishRandomQuestionPayload = {
  __typename?: 'UpsertEnglishRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishRandomQuestion` that was upserted by this mutation. */
  englishRandomQuestion?: Maybe<EnglishRandomQuestion>;
  /** An edge for our `EnglishRandomQuestion`. May be used by Relay 1. */
  englishRandomQuestionEdge?: Maybe<EnglishRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `EnglishRandomQuestion` mutation. */
export type UpsertEnglishRandomQuestionPayloadEnglishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `EnglishRandomQuestion` mutation. */
export type UpsertEnglishRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `EnglishWord` mutation. */
export type UpsertEnglishWordInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWord` to be upserted by this mutation. */
  englishWord: EnglishWordInput;
};

/** The output of our upsert `EnglishWord` mutation. */
export type UpsertEnglishWordPayload = {
  __typename?: 'UpsertEnglishWordPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWord` that was upserted by this mutation. */
  englishWord?: Maybe<EnglishWord>;
  /** An edge for our `EnglishWord`. May be used by Relay 1. */
  englishWordEdge?: Maybe<EnglishWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `EnglishWord` mutation. */
export type UpsertEnglishWordPayloadEnglishWordEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWordsOrderBy>>;
};

/** Where conditions for the upsert `EnglishWord` mutation. */
export type UpsertEnglishWordWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `EnglishWouldYouRatherQuestion` mutation. */
export type UpsertEnglishWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWouldYouRatherQuestion` to be upserted by this mutation. */
  englishWouldYouRatherQuestion: EnglishWouldYouRatherQuestionInput;
};

/** The output of our upsert `EnglishWouldYouRatherQuestion` mutation. */
export type UpsertEnglishWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertEnglishWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EnglishWouldYouRatherQuestion` that was upserted by this mutation. */
  englishWouldYouRatherQuestion?: Maybe<EnglishWouldYouRatherQuestion>;
  /** An edge for our `EnglishWouldYouRatherQuestion`. May be used by Relay 1. */
  englishWouldYouRatherQuestionEdge?: Maybe<EnglishWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `EnglishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `EnglishWouldYouRatherQuestion` mutation. */
export type UpsertEnglishWouldYouRatherQuestionPayloadEnglishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<EnglishWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `EnglishWouldYouRatherQuestion` mutation. */
export type UpsertEnglishWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `FrenchRandomQuestion` mutation. */
export type UpsertFrenchRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchRandomQuestion` to be upserted by this mutation. */
  frenchRandomQuestion: FrenchRandomQuestionInput;
};

/** The output of our upsert `FrenchRandomQuestion` mutation. */
export type UpsertFrenchRandomQuestionPayload = {
  __typename?: 'UpsertFrenchRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchRandomQuestion` that was upserted by this mutation. */
  frenchRandomQuestion?: Maybe<FrenchRandomQuestion>;
  /** An edge for our `FrenchRandomQuestion`. May be used by Relay 1. */
  frenchRandomQuestionEdge?: Maybe<FrenchRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `FrenchRandomQuestion` mutation. */
export type UpsertFrenchRandomQuestionPayloadFrenchRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `FrenchRandomQuestion` mutation. */
export type UpsertFrenchRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `FrenchWord` mutation. */
export type UpsertFrenchWordInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWord` to be upserted by this mutation. */
  frenchWord: FrenchWordInput;
};

/** The output of our upsert `FrenchWord` mutation. */
export type UpsertFrenchWordPayload = {
  __typename?: 'UpsertFrenchWordPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWord` that was upserted by this mutation. */
  frenchWord?: Maybe<FrenchWord>;
  /** An edge for our `FrenchWord`. May be used by Relay 1. */
  frenchWordEdge?: Maybe<FrenchWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `FrenchWord` mutation. */
export type UpsertFrenchWordPayloadFrenchWordEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWordsOrderBy>>;
};

/** Where conditions for the upsert `FrenchWord` mutation. */
export type UpsertFrenchWordWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `FrenchWouldYouRatherQuestion` mutation. */
export type UpsertFrenchWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWouldYouRatherQuestion` to be upserted by this mutation. */
  frenchWouldYouRatherQuestion: FrenchWouldYouRatherQuestionInput;
};

/** The output of our upsert `FrenchWouldYouRatherQuestion` mutation. */
export type UpsertFrenchWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertFrenchWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FrenchWouldYouRatherQuestion` that was upserted by this mutation. */
  frenchWouldYouRatherQuestion?: Maybe<FrenchWouldYouRatherQuestion>;
  /** An edge for our `FrenchWouldYouRatherQuestion`. May be used by Relay 1. */
  frenchWouldYouRatherQuestionEdge?: Maybe<FrenchWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `FrenchWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `FrenchWouldYouRatherQuestion` mutation. */
export type UpsertFrenchWouldYouRatherQuestionPayloadFrenchWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<FrenchWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `FrenchWouldYouRatherQuestion` mutation. */
export type UpsertFrenchWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `GermanRandomQuestion` mutation. */
export type UpsertGermanRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanRandomQuestion` to be upserted by this mutation. */
  germanRandomQuestion: GermanRandomQuestionInput;
};

/** The output of our upsert `GermanRandomQuestion` mutation. */
export type UpsertGermanRandomQuestionPayload = {
  __typename?: 'UpsertGermanRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanRandomQuestion` that was upserted by this mutation. */
  germanRandomQuestion?: Maybe<GermanRandomQuestion>;
  /** An edge for our `GermanRandomQuestion`. May be used by Relay 1. */
  germanRandomQuestionEdge?: Maybe<GermanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `GermanRandomQuestion` mutation. */
export type UpsertGermanRandomQuestionPayloadGermanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `GermanRandomQuestion` mutation. */
export type UpsertGermanRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `GermanWord` mutation. */
export type UpsertGermanWordInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWord` to be upserted by this mutation. */
  germanWord: GermanWordInput;
};

/** The output of our upsert `GermanWord` mutation. */
export type UpsertGermanWordPayload = {
  __typename?: 'UpsertGermanWordPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWord` that was upserted by this mutation. */
  germanWord?: Maybe<GermanWord>;
  /** An edge for our `GermanWord`. May be used by Relay 1. */
  germanWordEdge?: Maybe<GermanWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `GermanWord` mutation. */
export type UpsertGermanWordPayloadGermanWordEdgeArgs = {
  orderBy?: Maybe<Array<GermanWordsOrderBy>>;
};

/** Where conditions for the upsert `GermanWord` mutation. */
export type UpsertGermanWordWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `GermanWouldYouRatherQuestion` mutation. */
export type UpsertGermanWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWouldYouRatherQuestion` to be upserted by this mutation. */
  germanWouldYouRatherQuestion: GermanWouldYouRatherQuestionInput;
};

/** The output of our upsert `GermanWouldYouRatherQuestion` mutation. */
export type UpsertGermanWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertGermanWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GermanWouldYouRatherQuestion` that was upserted by this mutation. */
  germanWouldYouRatherQuestion?: Maybe<GermanWouldYouRatherQuestion>;
  /** An edge for our `GermanWouldYouRatherQuestion`. May be used by Relay 1. */
  germanWouldYouRatherQuestionEdge?: Maybe<GermanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `GermanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `GermanWouldYouRatherQuestion` mutation. */
export type UpsertGermanWouldYouRatherQuestionPayloadGermanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<GermanWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `GermanWouldYouRatherQuestion` mutation. */
export type UpsertGermanWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `Group` mutation. */
export type UpsertGroupInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be upserted by this mutation. */
  group: GroupInput;
};

/** The output of our upsert `Group` mutation. */
export type UpsertGroupPayload = {
  __typename?: 'UpsertGroupPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` that was upserted by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Reads a single `Language` that is related to this `Group`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Group`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Group` mutation. */
export type UpsertGroupPayloadGroupEdgeArgs = {
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};

/** All input for the upsert `GroupUser` mutation. */
export type UpsertGroupUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GroupUser` to be upserted by this mutation. */
  groupUser: GroupUserInput;
};

/** The output of our upsert `GroupUser` mutation. */
export type UpsertGroupUserPayload = {
  __typename?: 'UpsertGroupUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  /** The `GroupUser` that was upserted by this mutation. */
  groupUser?: Maybe<GroupUser>;
  /** An edge for our `GroupUser`. May be used by Relay 1. */
  groupUserEdge?: Maybe<GroupUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
};


/** The output of our upsert `GroupUser` mutation. */
export type UpsertGroupUserPayloadGroupUserEdgeArgs = {
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};

/** Where conditions for the upsert `GroupUser` mutation. */
export type UpsertGroupUserWhere = {
  id?: Maybe<Scalars['Int']>;
};

/** Where conditions for the upsert `Group` mutation. */
export type UpsertGroupWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `InviteToken` mutation. */
export type UpsertInviteTokenInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InviteToken` to be upserted by this mutation. */
  inviteToken: InviteTokenInput;
};

/** The output of our upsert `InviteToken` mutation. */
export type UpsertInviteTokenPayload = {
  __typename?: 'UpsertInviteTokenPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InviteToken` that was upserted by this mutation. */
  inviteToken?: Maybe<InviteToken>;
  /** An edge for our `InviteToken`. May be used by Relay 1. */
  inviteTokenEdge?: Maybe<InviteTokensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `InviteToken`. */
  user?: Maybe<User>;
};


/** The output of our upsert `InviteToken` mutation. */
export type UpsertInviteTokenPayloadInviteTokenEdgeArgs = {
  orderBy?: Maybe<Array<InviteTokensOrderBy>>;
};

/** Where conditions for the upsert `InviteToken` mutation. */
export type UpsertInviteTokenWhere = {
  id?: Maybe<Scalars['Int']>;
};

/** All input for the upsert `ItalianRandomQuestion` mutation. */
export type UpsertItalianRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianRandomQuestion` to be upserted by this mutation. */
  italianRandomQuestion: ItalianRandomQuestionInput;
};

/** The output of our upsert `ItalianRandomQuestion` mutation. */
export type UpsertItalianRandomQuestionPayload = {
  __typename?: 'UpsertItalianRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianRandomQuestion` that was upserted by this mutation. */
  italianRandomQuestion?: Maybe<ItalianRandomQuestion>;
  /** An edge for our `ItalianRandomQuestion`. May be used by Relay 1. */
  italianRandomQuestionEdge?: Maybe<ItalianRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `ItalianRandomQuestion` mutation. */
export type UpsertItalianRandomQuestionPayloadItalianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `ItalianRandomQuestion` mutation. */
export type UpsertItalianRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `ItalianWord` mutation. */
export type UpsertItalianWordInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWord` to be upserted by this mutation. */
  italianWord: ItalianWordInput;
};

/** The output of our upsert `ItalianWord` mutation. */
export type UpsertItalianWordPayload = {
  __typename?: 'UpsertItalianWordPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWord` that was upserted by this mutation. */
  italianWord?: Maybe<ItalianWord>;
  /** An edge for our `ItalianWord`. May be used by Relay 1. */
  italianWordEdge?: Maybe<ItalianWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `ItalianWord` mutation. */
export type UpsertItalianWordPayloadItalianWordEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWordsOrderBy>>;
};

/** Where conditions for the upsert `ItalianWord` mutation. */
export type UpsertItalianWordWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `ItalianWouldYouRatherQuestion` mutation. */
export type UpsertItalianWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWouldYouRatherQuestion` to be upserted by this mutation. */
  italianWouldYouRatherQuestion: ItalianWouldYouRatherQuestionInput;
};

/** The output of our upsert `ItalianWouldYouRatherQuestion` mutation. */
export type UpsertItalianWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertItalianWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ItalianWouldYouRatherQuestion` that was upserted by this mutation. */
  italianWouldYouRatherQuestion?: Maybe<ItalianWouldYouRatherQuestion>;
  /** An edge for our `ItalianWouldYouRatherQuestion`. May be used by Relay 1. */
  italianWouldYouRatherQuestionEdge?: Maybe<ItalianWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `ItalianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `ItalianWouldYouRatherQuestion` mutation. */
export type UpsertItalianWouldYouRatherQuestionPayloadItalianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<ItalianWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `ItalianWouldYouRatherQuestion` mutation. */
export type UpsertItalianWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `JapaneseRandomQuestion` mutation. */
export type UpsertJapaneseRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseRandomQuestion` to be upserted by this mutation. */
  japaneseRandomQuestion: JapaneseRandomQuestionInput;
};

/** The output of our upsert `JapaneseRandomQuestion` mutation. */
export type UpsertJapaneseRandomQuestionPayload = {
  __typename?: 'UpsertJapaneseRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseRandomQuestion` that was upserted by this mutation. */
  japaneseRandomQuestion?: Maybe<JapaneseRandomQuestion>;
  /** An edge for our `JapaneseRandomQuestion`. May be used by Relay 1. */
  japaneseRandomQuestionEdge?: Maybe<JapaneseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `JapaneseRandomQuestion` mutation. */
export type UpsertJapaneseRandomQuestionPayloadJapaneseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `JapaneseRandomQuestion` mutation. */
export type UpsertJapaneseRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `JapaneseWouldYouRatherQuestion` mutation. */
export type UpsertJapaneseWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseWouldYouRatherQuestion` to be upserted by this mutation. */
  japaneseWouldYouRatherQuestion: JapaneseWouldYouRatherQuestionInput;
};

/** The output of our upsert `JapaneseWouldYouRatherQuestion` mutation. */
export type UpsertJapaneseWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertJapaneseWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `JapaneseWouldYouRatherQuestion` that was upserted by this mutation. */
  japaneseWouldYouRatherQuestion?: Maybe<JapaneseWouldYouRatherQuestion>;
  /** An edge for our `JapaneseWouldYouRatherQuestion`. May be used by Relay 1. */
  japaneseWouldYouRatherQuestionEdge?: Maybe<JapaneseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `JapaneseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `JapaneseWouldYouRatherQuestion` mutation. */
export type UpsertJapaneseWouldYouRatherQuestionPayloadJapaneseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<JapaneseWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `JapaneseWouldYouRatherQuestion` mutation. */
export type UpsertJapaneseWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `KoreanRandomQuestion` mutation. */
export type UpsertKoreanRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanRandomQuestion` to be upserted by this mutation. */
  koreanRandomQuestion: KoreanRandomQuestionInput;
};

/** The output of our upsert `KoreanRandomQuestion` mutation. */
export type UpsertKoreanRandomQuestionPayload = {
  __typename?: 'UpsertKoreanRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanRandomQuestion` that was upserted by this mutation. */
  koreanRandomQuestion?: Maybe<KoreanRandomQuestion>;
  /** An edge for our `KoreanRandomQuestion`. May be used by Relay 1. */
  koreanRandomQuestionEdge?: Maybe<KoreanRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `KoreanRandomQuestion` mutation. */
export type UpsertKoreanRandomQuestionPayloadKoreanRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `KoreanRandomQuestion` mutation. */
export type UpsertKoreanRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `KoreanWouldYouRatherQuestion` mutation. */
export type UpsertKoreanWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanWouldYouRatherQuestion` to be upserted by this mutation. */
  koreanWouldYouRatherQuestion: KoreanWouldYouRatherQuestionInput;
};

/** The output of our upsert `KoreanWouldYouRatherQuestion` mutation. */
export type UpsertKoreanWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertKoreanWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `KoreanWouldYouRatherQuestion` that was upserted by this mutation. */
  koreanWouldYouRatherQuestion?: Maybe<KoreanWouldYouRatherQuestion>;
  /** An edge for our `KoreanWouldYouRatherQuestion`. May be used by Relay 1. */
  koreanWouldYouRatherQuestionEdge?: Maybe<KoreanWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `KoreanWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `KoreanWouldYouRatherQuestion` mutation. */
export type UpsertKoreanWouldYouRatherQuestionPayloadKoreanWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<KoreanWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `KoreanWouldYouRatherQuestion` mutation. */
export type UpsertKoreanWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `Language` mutation. */
export type UpsertLanguageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Language` to be upserted by this mutation. */
  language: LanguageInput;
};

/** The output of our upsert `Language` mutation. */
export type UpsertLanguagePayload = {
  __typename?: 'UpsertLanguagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Language` that was upserted by this mutation. */
  language?: Maybe<Language>;
  /** An edge for our `Language`. May be used by Relay 1. */
  languageEdge?: Maybe<LanguagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Language` mutation. */
export type UpsertLanguagePayloadLanguageEdgeArgs = {
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};

/** All input for the upsert `LanguageSkillLevel` mutation. */
export type UpsertLanguageSkillLevelInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LanguageSkillLevel` to be upserted by this mutation. */
  languageSkillLevel: LanguageSkillLevelInput;
};

/** The output of our upsert `LanguageSkillLevel` mutation. */
export type UpsertLanguageSkillLevelPayload = {
  __typename?: 'UpsertLanguageSkillLevelPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LanguageSkillLevel` that was upserted by this mutation. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** An edge for our `LanguageSkillLevel`. May be used by Relay 1. */
  languageSkillLevelEdge?: Maybe<LanguageSkillLevelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `LanguageSkillLevel` mutation. */
export type UpsertLanguageSkillLevelPayloadLanguageSkillLevelEdgeArgs = {
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};

/** Where conditions for the upsert `LanguageSkillLevel` mutation. */
export type UpsertLanguageSkillLevelWhere = {
  id?: Maybe<Scalars['Int']>;
};

/** Where conditions for the upsert `Language` mutation. */
export type UpsertLanguageWhere = {
  alpha2?: Maybe<Scalars['String']>;
  englishName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

/** All input for the upsert `Message` mutation. */
export type UpsertMessageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` to be upserted by this mutation. */
  message: MessageInput;
};

/** The output of our upsert `Message` mutation. */
export type UpsertMessagePayload = {
  __typename?: 'UpsertMessagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was upserted by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Reads a single `Message` that is related to this `Message`. */
  parentMessage?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Message`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Message`. */
  recipientGroup?: Maybe<Group>;
  /** Reads a single `User` that is related to this `Message`. */
  sender?: Maybe<User>;
};


/** The output of our upsert `Message` mutation. */
export type UpsertMessagePayloadMessageEdgeArgs = {
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** All input for the upsert `MessagePreview` mutation. */
export type UpsertMessagePreviewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MessagePreview` to be upserted by this mutation. */
  messagePreview: MessagePreviewInput;
};

/** The output of our upsert `MessagePreview` mutation. */
export type UpsertMessagePreviewPayload = {
  __typename?: 'UpsertMessagePreviewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Message` that is related to this `MessagePreview`. */
  message?: Maybe<Message>;
  /** The `MessagePreview` that was upserted by this mutation. */
  messagePreview?: Maybe<MessagePreview>;
  /** An edge for our `MessagePreview`. May be used by Relay 1. */
  messagePreviewEdge?: Maybe<MessagePreviewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `MessagePreview` mutation. */
export type UpsertMessagePreviewPayloadMessagePreviewEdgeArgs = {
  orderBy?: Maybe<Array<MessagePreviewsOrderBy>>;
};

/** Where conditions for the upsert `MessagePreview` mutation. */
export type UpsertMessagePreviewWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Where conditions for the upsert `Message` mutation. */
export type UpsertMessageWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `NotificationChannel` mutation. */
export type UpsertNotificationChannelInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `NotificationChannel` to be upserted by this mutation. */
  notificationChannel: NotificationChannelInput;
};

/** The output of our upsert `NotificationChannel` mutation. */
export type UpsertNotificationChannelPayload = {
  __typename?: 'UpsertNotificationChannelPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `NotificationChannel` that was upserted by this mutation. */
  notificationChannel?: Maybe<NotificationChannel>;
  /** An edge for our `NotificationChannel`. May be used by Relay 1. */
  notificationChannelEdge?: Maybe<NotificationChannelsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `NotificationChannel` mutation. */
export type UpsertNotificationChannelPayloadNotificationChannelEdgeArgs = {
  orderBy?: Maybe<Array<NotificationChannelsOrderBy>>;
};

/** Where conditions for the upsert `NotificationChannel` mutation. */
export type UpsertNotificationChannelWhere = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `Notification` mutation. */
export type UpsertNotificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` to be upserted by this mutation. */
  notification: NotificationInput;
};

/** The output of our upsert `Notification` mutation. */
export type UpsertNotificationPayload = {
  __typename?: 'UpsertNotificationPayload';
  /** Reads a single `NotificationChannel` that is related to this `Notification`. */
  channel?: Maybe<NotificationChannel>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was upserted by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Notification`. */
  recipient?: Maybe<User>;
  /** Reads a single `Group` that is related to this `Notification`. */
  recipientGroup?: Maybe<Group>;
};


/** The output of our upsert `Notification` mutation. */
export type UpsertNotificationPayloadNotificationEdgeArgs = {
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** Where conditions for the upsert `Notification` mutation. */
export type UpsertNotificationWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `PortugueseRandomQuestion` mutation. */
export type UpsertPortugueseRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseRandomQuestion` to be upserted by this mutation. */
  portugueseRandomQuestion: PortugueseRandomQuestionInput;
};

/** The output of our upsert `PortugueseRandomQuestion` mutation. */
export type UpsertPortugueseRandomQuestionPayload = {
  __typename?: 'UpsertPortugueseRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseRandomQuestion` that was upserted by this mutation. */
  portugueseRandomQuestion?: Maybe<PortugueseRandomQuestion>;
  /** An edge for our `PortugueseRandomQuestion`. May be used by Relay 1. */
  portugueseRandomQuestionEdge?: Maybe<PortugueseRandomQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `PortugueseRandomQuestion` mutation. */
export type UpsertPortugueseRandomQuestionPayloadPortugueseRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `PortugueseRandomQuestion` mutation. */
export type UpsertPortugueseRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `PortugueseWord` mutation. */
export type UpsertPortugueseWordInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWord` to be upserted by this mutation. */
  portugueseWord: PortugueseWordInput;
};

/** The output of our upsert `PortugueseWord` mutation. */
export type UpsertPortugueseWordPayload = {
  __typename?: 'UpsertPortugueseWordPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWord` that was upserted by this mutation. */
  portugueseWord?: Maybe<PortugueseWord>;
  /** An edge for our `PortugueseWord`. May be used by Relay 1. */
  portugueseWordEdge?: Maybe<PortugueseWordsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `PortugueseWord` mutation. */
export type UpsertPortugueseWordPayloadPortugueseWordEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWordsOrderBy>>;
};

/** Where conditions for the upsert `PortugueseWord` mutation. */
export type UpsertPortugueseWordWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `PortugueseWouldYouRatherQuestion` mutation. */
export type UpsertPortugueseWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWouldYouRatherQuestion` to be upserted by this mutation. */
  portugueseWouldYouRatherQuestion: PortugueseWouldYouRatherQuestionInput;
};

/** The output of our upsert `PortugueseWouldYouRatherQuestion` mutation. */
export type UpsertPortugueseWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertPortugueseWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PortugueseWouldYouRatherQuestion` that was upserted by this mutation. */
  portugueseWouldYouRatherQuestion?: Maybe<PortugueseWouldYouRatherQuestion>;
  /** An edge for our `PortugueseWouldYouRatherQuestion`. May be used by Relay 1. */
  portugueseWouldYouRatherQuestionEdge?: Maybe<PortugueseWouldYouRatherQuestionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `PortugueseWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `PortugueseWouldYouRatherQuestion` mutation. */
export type UpsertPortugueseWouldYouRatherQuestionPayloadPortugueseWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<PortugueseWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `PortugueseWouldYouRatherQuestion` mutation. */
export type UpsertPortugueseWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `PostCorrection` mutation. */
export type UpsertPostCorrectionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostCorrection` to be upserted by this mutation. */
  postCorrection: PostCorrectionInput;
};

/** The output of our upsert `PostCorrection` mutation. */
export type UpsertPostCorrectionPayload = {
  __typename?: 'UpsertPostCorrectionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostCorrection`. */
  post?: Maybe<Post>;
  /** The `PostCorrection` that was upserted by this mutation. */
  postCorrection?: Maybe<PostCorrection>;
  /** An edge for our `PostCorrection`. May be used by Relay 1. */
  postCorrectionEdge?: Maybe<PostCorrectionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostCorrection`. */
  user?: Maybe<User>;
};


/** The output of our upsert `PostCorrection` mutation. */
export type UpsertPostCorrectionPayloadPostCorrectionEdgeArgs = {
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};

/** Where conditions for the upsert `PostCorrection` mutation. */
export type UpsertPostCorrectionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `PostGameAnswer` mutation. */
export type UpsertPostGameAnswerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostGameAnswer` to be upserted by this mutation. */
  postGameAnswer: PostGameAnswerInput;
};

/** The output of our upsert `PostGameAnswer` mutation. */
export type UpsertPostGameAnswerPayload = {
  __typename?: 'UpsertPostGameAnswerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `PostGame` that is related to this `PostGameAnswer`. */
  game?: Maybe<PostGame>;
  /** The `PostGameAnswer` that was upserted by this mutation. */
  postGameAnswer?: Maybe<PostGameAnswer>;
  /** An edge for our `PostGameAnswer`. May be used by Relay 1. */
  postGameAnswerEdge?: Maybe<PostGameAnswersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PostGameRange` that is related to this `PostGameAnswer`. */
  range?: Maybe<PostGameRange>;
  /** Reads a single `User` that is related to this `PostGameAnswer`. */
  user?: Maybe<User>;
};


/** The output of our upsert `PostGameAnswer` mutation. */
export type UpsertPostGameAnswerPayloadPostGameAnswerEdgeArgs = {
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** Where conditions for the upsert `PostGameAnswer` mutation. */
export type UpsertPostGameAnswerWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `PostGame` mutation. */
export type UpsertPostGameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostGame` to be upserted by this mutation. */
  postGame: PostGameInput;
};

/** The output of our upsert `PostGame` mutation. */
export type UpsertPostGamePayload = {
  __typename?: 'UpsertPostGamePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostGame`. */
  post?: Maybe<Post>;
  /** The `PostGame` that was upserted by this mutation. */
  postGame?: Maybe<PostGame>;
  /** An edge for our `PostGame`. May be used by Relay 1. */
  postGameEdge?: Maybe<PostGamesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `PostGame` mutation. */
export type UpsertPostGamePayloadPostGameEdgeArgs = {
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};

/** All input for the upsert `PostGameRange` mutation. */
export type UpsertPostGameRangeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostGameRange` to be upserted by this mutation. */
  postGameRange: PostGameRangeInput;
};

/** The output of our upsert `PostGameRange` mutation. */
export type UpsertPostGameRangePayload = {
  __typename?: 'UpsertPostGameRangePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `PostGame` that is related to this `PostGameRange`. */
  game?: Maybe<PostGame>;
  /** The `PostGameRange` that was upserted by this mutation. */
  postGameRange?: Maybe<PostGameRange>;
  /** An edge for our `PostGameRange`. May be used by Relay 1. */
  postGameRangeEdge?: Maybe<PostGameRangesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `PostGameRange` mutation. */
export type UpsertPostGameRangePayloadPostGameRangeEdgeArgs = {
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};

/** Where conditions for the upsert `PostGameRange` mutation. */
export type UpsertPostGameRangeWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Where conditions for the upsert `PostGame` mutation. */
export type UpsertPostGameWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `Post` mutation. */
export type UpsertPostInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Post` to be upserted by this mutation. */
  post: PostInput;
};

/** All input for the upsert `PostLike` mutation. */
export type UpsertPostLikeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostLike` to be upserted by this mutation. */
  postLike: PostLikeInput;
};

/** The output of our upsert `PostLike` mutation. */
export type UpsertPostLikePayload = {
  __typename?: 'UpsertPostLikePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostLike`. */
  post?: Maybe<Post>;
  /** The `PostLike` that was upserted by this mutation. */
  postLike?: Maybe<PostLike>;
  /** An edge for our `PostLike`. May be used by Relay 1. */
  postLikeEdge?: Maybe<PostLikesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostLike`. */
  user?: Maybe<User>;
};


/** The output of our upsert `PostLike` mutation. */
export type UpsertPostLikePayloadPostLikeEdgeArgs = {
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};

/** Where conditions for the upsert `PostLike` mutation. */
export type UpsertPostLikeWhere = {
  id?: Maybe<Scalars['Int']>;
};

/** The output of our upsert `Post` mutation. */
export type UpsertPostPayload = {
  __typename?: 'UpsertPostPayload';
  /** Reads a single `User` that is related to this `Post`. */
  author?: Maybe<User>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `Post`. */
  language?: Maybe<Language>;
  /** Reads a single `Post` that is related to this `Post`. */
  parentPost?: Maybe<Post>;
  /** The `Post` that was upserted by this mutation. */
  post?: Maybe<Post>;
  /** An edge for our `Post`. May be used by Relay 1. */
  postEdge?: Maybe<PostsEdge>;
  /** Reads a single `Prompt` that is related to this `Post`. */
  prompt?: Maybe<Prompt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Post` mutation. */
export type UpsertPostPayloadPostEdgeArgs = {
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** All input for the upsert `PostRecording` mutation. */
export type UpsertPostRecordingInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostRecording` to be upserted by this mutation. */
  postRecording: PostRecordingInput;
};

/** The output of our upsert `PostRecording` mutation. */
export type UpsertPostRecordingPayload = {
  __typename?: 'UpsertPostRecordingPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostRecording`. */
  post?: Maybe<Post>;
  /** The `PostRecording` that was upserted by this mutation. */
  postRecording?: Maybe<PostRecording>;
  /** An edge for our `PostRecording`. May be used by Relay 1. */
  postRecordingEdge?: Maybe<PostRecordingsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostRecording`. */
  user?: Maybe<User>;
};


/** The output of our upsert `PostRecording` mutation. */
export type UpsertPostRecordingPayloadPostRecordingEdgeArgs = {
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};

/** Where conditions for the upsert `PostRecording` mutation. */
export type UpsertPostRecordingWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `PostUserMention` mutation. */
export type UpsertPostUserMentionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PostUserMention` to be upserted by this mutation. */
  postUserMention: PostUserMentionInput;
};

/** The output of our upsert `PostUserMention` mutation. */
export type UpsertPostUserMentionPayload = {
  __typename?: 'UpsertPostUserMentionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Post` that is related to this `PostUserMention`. */
  post?: Maybe<Post>;
  /** The `PostUserMention` that was upserted by this mutation. */
  postUserMention?: Maybe<PostUserMention>;
  /** An edge for our `PostUserMention`. May be used by Relay 1. */
  postUserMentionEdge?: Maybe<PostUserMentionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PostUserMention`. */
  user?: Maybe<User>;
};


/** The output of our upsert `PostUserMention` mutation. */
export type UpsertPostUserMentionPayloadPostUserMentionEdgeArgs = {
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};

/** Where conditions for the upsert `PostUserMention` mutation. */
export type UpsertPostUserMentionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Where conditions for the upsert `Post` mutation. */
export type UpsertPostWhere = {
  id?: Maybe<Scalars['Int']>;
  snowflakeId?: Maybe<Scalars['BigInt']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `Prompt` mutation. */
export type UpsertPromptInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Prompt` to be upserted by this mutation. */
  prompt: PromptInput;
};

/** The output of our upsert `Prompt` mutation. */
export type UpsertPromptPayload = {
  __typename?: 'UpsertPromptPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `Prompt`. */
  language?: Maybe<Language>;
  /** The `Prompt` that was upserted by this mutation. */
  prompt?: Maybe<Prompt>;
  /** An edge for our `Prompt`. May be used by Relay 1. */
  promptEdge?: Maybe<PromptsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `Prompt`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
};


/** The output of our upsert `Prompt` mutation. */
export type UpsertPromptPayloadPromptEdgeArgs = {
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};

/** Where conditions for the upsert `Prompt` mutation. */
export type UpsertPromptWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `RussianRandomQuestion` mutation. */
export type UpsertRussianRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RussianRandomQuestion` to be upserted by this mutation. */
  russianRandomQuestion: RussianRandomQuestionInput;
};

/** The output of our upsert `RussianRandomQuestion` mutation. */
export type UpsertRussianRandomQuestionPayload = {
  __typename?: 'UpsertRussianRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianRandomQuestion` that was upserted by this mutation. */
  russianRandomQuestion?: Maybe<RussianRandomQuestion>;
  /** An edge for our `RussianRandomQuestion`. May be used by Relay 1. */
  russianRandomQuestionEdge?: Maybe<RussianRandomQuestionsEdge>;
};


/** The output of our upsert `RussianRandomQuestion` mutation. */
export type UpsertRussianRandomQuestionPayloadRussianRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `RussianRandomQuestion` mutation. */
export type UpsertRussianRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `RussianWord` mutation. */
export type UpsertRussianWordInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RussianWord` to be upserted by this mutation. */
  russianWord: RussianWordInput;
};

/** The output of our upsert `RussianWord` mutation. */
export type UpsertRussianWordPayload = {
  __typename?: 'UpsertRussianWordPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWord` that was upserted by this mutation. */
  russianWord?: Maybe<RussianWord>;
  /** An edge for our `RussianWord`. May be used by Relay 1. */
  russianWordEdge?: Maybe<RussianWordsEdge>;
};


/** The output of our upsert `RussianWord` mutation. */
export type UpsertRussianWordPayloadRussianWordEdgeArgs = {
  orderBy?: Maybe<Array<RussianWordsOrderBy>>;
};

/** Where conditions for the upsert `RussianWord` mutation. */
export type UpsertRussianWordWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `RussianWouldYouRatherQuestion` mutation. */
export type UpsertRussianWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RussianWouldYouRatherQuestion` to be upserted by this mutation. */
  russianWouldYouRatherQuestion: RussianWouldYouRatherQuestionInput;
};

/** The output of our upsert `RussianWouldYouRatherQuestion` mutation. */
export type UpsertRussianWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertRussianWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `RussianWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `RussianWouldYouRatherQuestion` that was upserted by this mutation. */
  russianWouldYouRatherQuestion?: Maybe<RussianWouldYouRatherQuestion>;
  /** An edge for our `RussianWouldYouRatherQuestion`. May be used by Relay 1. */
  russianWouldYouRatherQuestionEdge?: Maybe<RussianWouldYouRatherQuestionsEdge>;
};


/** The output of our upsert `RussianWouldYouRatherQuestion` mutation. */
export type UpsertRussianWouldYouRatherQuestionPayloadRussianWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<RussianWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `RussianWouldYouRatherQuestion` mutation. */
export type UpsertRussianWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `SpanishRandomQuestion` mutation. */
export type UpsertSpanishRandomQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpanishRandomQuestion` to be upserted by this mutation. */
  spanishRandomQuestion: SpanishRandomQuestionInput;
};

/** The output of our upsert `SpanishRandomQuestion` mutation. */
export type UpsertSpanishRandomQuestionPayload = {
  __typename?: 'UpsertSpanishRandomQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishRandomQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishRandomQuestion` that was upserted by this mutation. */
  spanishRandomQuestion?: Maybe<SpanishRandomQuestion>;
  /** An edge for our `SpanishRandomQuestion`. May be used by Relay 1. */
  spanishRandomQuestionEdge?: Maybe<SpanishRandomQuestionsEdge>;
};


/** The output of our upsert `SpanishRandomQuestion` mutation. */
export type UpsertSpanishRandomQuestionPayloadSpanishRandomQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishRandomQuestionsOrderBy>>;
};

/** Where conditions for the upsert `SpanishRandomQuestion` mutation. */
export type UpsertSpanishRandomQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `SpanishWord` mutation. */
export type UpsertSpanishWordInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpanishWord` to be upserted by this mutation. */
  spanishWord: SpanishWordInput;
};

/** The output of our upsert `SpanishWord` mutation. */
export type UpsertSpanishWordPayload = {
  __typename?: 'UpsertSpanishWordPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWord`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWord` that was upserted by this mutation. */
  spanishWord?: Maybe<SpanishWord>;
  /** An edge for our `SpanishWord`. May be used by Relay 1. */
  spanishWordEdge?: Maybe<SpanishWordsEdge>;
};


/** The output of our upsert `SpanishWord` mutation. */
export type UpsertSpanishWordPayloadSpanishWordEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWordsOrderBy>>;
};

/** Where conditions for the upsert `SpanishWord` mutation. */
export type UpsertSpanishWordWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `SpanishWouldYouRatherQuestion` mutation. */
export type UpsertSpanishWouldYouRatherQuestionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpanishWouldYouRatherQuestion` to be upserted by this mutation. */
  spanishWouldYouRatherQuestion: SpanishWouldYouRatherQuestionInput;
};

/** The output of our upsert `SpanishWouldYouRatherQuestion` mutation. */
export type UpsertSpanishWouldYouRatherQuestionPayload = {
  __typename?: 'UpsertSpanishWouldYouRatherQuestionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `LanguageSkillLevel` that is related to this `SpanishWouldYouRatherQuestion`. */
  recommendedSkillLevel?: Maybe<LanguageSkillLevel>;
  /** The `SpanishWouldYouRatherQuestion` that was upserted by this mutation. */
  spanishWouldYouRatherQuestion?: Maybe<SpanishWouldYouRatherQuestion>;
  /** An edge for our `SpanishWouldYouRatherQuestion`. May be used by Relay 1. */
  spanishWouldYouRatherQuestionEdge?: Maybe<SpanishWouldYouRatherQuestionsEdge>;
};


/** The output of our upsert `SpanishWouldYouRatherQuestion` mutation. */
export type UpsertSpanishWouldYouRatherQuestionPayloadSpanishWouldYouRatherQuestionEdgeArgs = {
  orderBy?: Maybe<Array<SpanishWouldYouRatherQuestionsOrderBy>>;
};

/** Where conditions for the upsert `SpanishWouldYouRatherQuestion` mutation. */
export type UpsertSpanishWouldYouRatherQuestionWhere = {
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `UserDevice` mutation. */
export type UpsertUserDeviceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserDevice` to be upserted by this mutation. */
  userDevice: UserDeviceInput;
};

/** The output of our upsert `UserDevice` mutation. */
export type UpsertUserDevicePayload = {
  __typename?: 'UpsertUserDevicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserDevice`. */
  user?: Maybe<User>;
  /** The `UserDevice` that was upserted by this mutation. */
  userDevice?: Maybe<UserDevice>;
  /** An edge for our `UserDevice`. May be used by Relay 1. */
  userDeviceEdge?: Maybe<UserDevicesEdge>;
};


/** The output of our upsert `UserDevice` mutation. */
export type UpsertUserDevicePayloadUserDeviceEdgeArgs = {
  orderBy?: Maybe<Array<UserDevicesOrderBy>>;
};

/** Where conditions for the upsert `UserDevice` mutation. */
export type UpsertUserDeviceWhere = {
  fcmToken?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** All input for the upsert `UserFollower` mutation. */
export type UpsertUserFollowerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserFollower` to be upserted by this mutation. */
  userFollower: UserFollowerInput;
};

/** The output of our upsert `UserFollower` mutation. */
export type UpsertUserFollowerPayload = {
  __typename?: 'UpsertUserFollowerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  follower?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserFollower`. */
  user?: Maybe<User>;
  /** The `UserFollower` that was upserted by this mutation. */
  userFollower?: Maybe<UserFollower>;
  /** An edge for our `UserFollower`. May be used by Relay 1. */
  userFollowerEdge?: Maybe<UserFollowersEdge>;
};


/** The output of our upsert `UserFollower` mutation. */
export type UpsertUserFollowerPayloadUserFollowerEdgeArgs = {
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};

/** Where conditions for the upsert `UserFollower` mutation. */
export type UpsertUserFollowerWhere = {
  id?: Maybe<Scalars['Int']>;
};

/** All input for the upsert `User` mutation. */
export type UpsertUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` to be upserted by this mutation. */
  user: UserInput;
};

/** All input for the upsert `UserLanguage` mutation. */
export type UpsertUserLanguageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserLanguage` to be upserted by this mutation. */
  userLanguage: UserLanguageInput;
};

/** The output of our upsert `UserLanguage` mutation. */
export type UpsertUserLanguagePayload = {
  __typename?: 'UpsertUserLanguagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `UserLanguage`. */
  language?: Maybe<Language>;
  /** Reads a single `LanguageSkillLevel` that is related to this `UserLanguage`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserLanguage`. */
  user?: Maybe<User>;
  /** The `UserLanguage` that was upserted by this mutation. */
  userLanguage?: Maybe<UserLanguage>;
  /** An edge for our `UserLanguage`. May be used by Relay 1. */
  userLanguageEdge?: Maybe<UserLanguagesEdge>;
};


/** The output of our upsert `UserLanguage` mutation. */
export type UpsertUserLanguagePayloadUserLanguageEdgeArgs = {
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** Where conditions for the upsert `UserLanguage` mutation. */
export type UpsertUserLanguageWhere = {
  id?: Maybe<Scalars['Int']>;
};

/** The output of our upsert `User` mutation. */
export type UpsertUserPayload = {
  __typename?: 'UpsertUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `User`. */
  languageByLocale?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `InviteToken` that is related to this `User`. */
  signedUpWithToken?: Maybe<InviteToken>;
  /** The `User` that was upserted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our upsert `User` mutation. */
export type UpsertUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the upsert `UserPreference` mutation. */
export type UpsertUserPreferenceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserPreference` to be upserted by this mutation. */
  userPreference: UserPreferenceInput;
};

/** The output of our upsert `UserPreference` mutation. */
export type UpsertUserPreferencePayload = {
  __typename?: 'UpsertUserPreferencePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Language` that is related to this `UserPreference`. */
  feedLanguage?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserPreference`. */
  user?: Maybe<User>;
  /** The `UserPreference` that was upserted by this mutation. */
  userPreference?: Maybe<UserPreference>;
  /** An edge for our `UserPreference`. May be used by Relay 1. */
  userPreferenceEdge?: Maybe<UserPreferencesEdge>;
};


/** The output of our upsert `UserPreference` mutation. */
export type UpsertUserPreferencePayloadUserPreferenceEdgeArgs = {
  orderBy?: Maybe<Array<UserPreferencesOrderBy>>;
};

/** Where conditions for the upsert `UserPreference` mutation. */
export type UpsertUserPreferenceWhere = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
};

/** All input for the upsert `UserSession` mutation. */
export type UpsertUserSessionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserSession` to be upserted by this mutation. */
  userSession: UserSessionInput;
};

/** The output of our upsert `UserSession` mutation. */
export type UpsertUserSessionPayload = {
  __typename?: 'UpsertUserSessionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserSession` that was upserted by this mutation. */
  userSession?: Maybe<UserSession>;
  /** An edge for our `UserSession`. May be used by Relay 1. */
  userSessionEdge?: Maybe<UserSessionsEdge>;
};


/** The output of our upsert `UserSession` mutation. */
export type UpsertUserSessionPayloadUserSessionEdgeArgs = {
  orderBy?: Maybe<Array<UserSessionsOrderBy>>;
};

/** Where conditions for the upsert `UserSession` mutation. */
export type UpsertUserSessionWhere = {
  sid?: Maybe<Scalars['String']>;
};

/** Where conditions for the upsert `User` mutation. */
export type UpsertUserWhere = {
  email?: Maybe<Scalars['String']>;
  emailUnsubscribeToken?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  resetPasswordToken?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  uuid?: Maybe<Scalars['UUID']>;
};

export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `Post`. */
  authoredPosts: PostsConnection;
  avatarUrl?: Maybe<Scalars['String']>;
  bio: Scalars['String'];
  createdAt: Scalars['Datetime'];
  displayName?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  emailNotificationsEnabled: Scalars['Boolean'];
  emailUnsubscribeToken?: Maybe<Scalars['String']>;
  followedByCurrentUser?: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `UserFollower`. */
  followedUsers: UserFollowersConnection;
  /** Reads and enables pagination through a set of `UserFollower`. */
  followers: UserFollowersConnection;
  gender?: Maybe<Scalars['String']>;
  googleId?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByGroupUserUserIdAndGroupId: UserGroupsByGroupUserUserIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByMessageRecipientIdAndRecipientGroupId: UserGroupsByMessageRecipientIdAndRecipientGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByMessageSenderIdAndRecipientGroupId: UserGroupsByMessageSenderIdAndRecipientGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByNotificationRecipientIdAndRecipientGroupId: UserGroupsByNotificationRecipientIdAndRecipientGroupIdManyToManyConnection;
  id: Scalars['Int'];
  /** Reads and enables pagination through a set of `InviteToken`. */
  inviteTokens: InviteTokensConnection;
  /** Reads a single `Language` that is related to this `User`. */
  languageByLocale?: Maybe<Language>;
  /** Reads and enables pagination through a set of `LanguageSkillLevel`. */
  languageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelId: UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Language`. */
  languagesByPostAuthorIdAndLanguageId: UserLanguagesByPostAuthorIdAndLanguageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Language`. */
  languagesByUserLanguageUserIdAndLanguageId: UserLanguagesByUserLanguageUserIdAndLanguageIdManyToManyConnection;
  lastActiveAt: Scalars['Datetime'];
  locale?: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByMessageRecipientIdAndParentMessageId: UserMessagesByMessageRecipientIdAndParentMessageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByMessageSenderIdAndParentMessageId: UserMessagesByMessageSenderIdAndParentMessageIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientId: MessagesConnection;
  /** Reads and enables pagination through a set of `Message`. */
  messagesBySenderId: MessagesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads and enables pagination through a set of `NotificationChannel`. */
  notificationChannelsByNotificationRecipientIdAndChannelId: UserNotificationChannelsByNotificationRecipientIdAndChannelIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByRecipientId: NotificationsConnection;
  passwordHash?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PostCorrection`. */
  postCorrections: PostCorrectionsConnection;
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  postGameAnswers: PostGameAnswersConnection;
  /** Reads and enables pagination through a set of `PostGameRange`. */
  postGameRangesByPostGameAnswerUserIdAndRangeId: UserPostGameRangesByPostGameAnswerUserIdAndRangeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PostGame`. */
  postGamesByPostGameAnswerUserIdAndGameId: UserPostGamesByPostGameAnswerUserIdAndGameIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PostLike`. */
  postLikes: PostLikesConnection;
  /** Reads and enables pagination through a set of `PostRecording`. */
  postRecordings: PostRecordingsConnection;
  /** Reads and enables pagination through a set of `PostUserMention`. */
  postUserMentions: PostUserMentionsConnection;
  /** Reads and enables pagination through a set of `Post`. */
  postsByPostAuthorIdAndParentPostId: UserPostsByPostAuthorIdAndParentPostIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Post`. */
  postsByPostCorrectionUserIdAndPostId: UserPostsByPostCorrectionUserIdAndPostIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Post`. */
  postsByPostLikeUserIdAndPostId: UserPostsByPostLikeUserIdAndPostIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Post`. */
  postsByPostRecordingUserIdAndPostId: UserPostsByPostRecordingUserIdAndPostIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Post`. */
  postsByPostUserMentionUserIdAndPostId: UserPostsByPostUserMentionUserIdAndPostIdManyToManyConnection;
  /** Reads a single `UserPreference` that is related to this `User`. */
  preference?: Maybe<UserPreference>;
  /** Reads and enables pagination through a set of `Prompt`. */
  promptsByPostAuthorIdAndPromptId: UserPromptsByPostAuthorIdAndPromptIdManyToManyConnection;
  resetPasswordToken?: Maybe<Scalars['String']>;
  resetPasswordTokenCreatedAt?: Maybe<Scalars['Datetime']>;
  /** Reads a single `InviteToken` that is related to this `User`. */
  signedUpWithToken?: Maybe<InviteToken>;
  signedUpWithTokenId?: Maybe<Scalars['Int']>;
  unconfirmedEmail?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `UserDevice`. */
  userDevices: UserDevicesConnection;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
  username?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByMessageRecipientIdAndSenderId: UserUsersByMessageRecipientIdAndSenderIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByMessageSenderIdAndRecipientId: UserUsersByMessageSenderIdAndRecipientIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserFollowerFollowerIdAndUserId: UserUsersByUserFollowerFollowerIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserFollowerUserIdAndFollowerId: UserUsersByUserFollowerUserIdAndFollowerIdManyToManyConnection;
  uuid: Scalars['UUID'];
};


export type UserAuthoredPostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type UserFollowedUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserFollowerCondition>;
  filter?: Maybe<UserFollowerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};


export type UserFollowersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserFollowerCondition>;
  filter?: Maybe<UserFollowerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};


export type UserGroupUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupUserCondition>;
  filter?: Maybe<GroupUserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};


export type UserGroupsByGroupUserUserIdAndGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type UserGroupsByMessageRecipientIdAndRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type UserGroupsByMessageSenderIdAndRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type UserGroupsByNotificationRecipientIdAndRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
};


export type UserInviteTokensArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<InviteTokenCondition>;
  filter?: Maybe<InviteTokenFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<InviteTokensOrderBy>>;
};


export type UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageSkillLevelCondition>;
  filter?: Maybe<LanguageSkillLevelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguageSkillLevelsOrderBy>>;
};


export type UserLanguagesByPostAuthorIdAndLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type UserLanguagesByUserLanguageUserIdAndLanguageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<LanguageCondition>;
  filter?: Maybe<LanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LanguagesOrderBy>>;
};


export type UserMessagesByMessageRecipientIdAndParentMessageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


export type UserMessagesByMessageSenderIdAndParentMessageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


export type UserMessagesByRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


export type UserMessagesBySenderIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};


export type UserNotificationChannelsByNotificationRecipientIdAndChannelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationChannelCondition>;
  filter?: Maybe<NotificationChannelFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationChannelsOrderBy>>;
};


export type UserNotificationsByRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};


export type UserPostCorrectionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCorrectionCondition>;
  filter?: Maybe<PostCorrectionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};


export type UserPostGameAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};


export type UserPostGameRangesByPostGameAnswerUserIdAndRangeIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameRangeCondition>;
  filter?: Maybe<PostGameRangeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameRangesOrderBy>>;
};


export type UserPostGamesByPostGameAnswerUserIdAndGameIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameCondition>;
  filter?: Maybe<PostGameFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGamesOrderBy>>;
};


export type UserPostLikesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostLikeCondition>;
  filter?: Maybe<PostLikeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};


export type UserPostRecordingsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostRecordingCondition>;
  filter?: Maybe<PostRecordingFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};


export type UserPostUserMentionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostUserMentionCondition>;
  filter?: Maybe<PostUserMentionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};


export type UserPostsByPostAuthorIdAndParentPostIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type UserPostsByPostCorrectionUserIdAndPostIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type UserPostsByPostLikeUserIdAndPostIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type UserPostsByPostRecordingUserIdAndPostIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type UserPostsByPostUserMentionUserIdAndPostIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};


export type UserPromptsByPostAuthorIdAndPromptIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PromptCondition>;
  filter?: Maybe<PromptFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PromptsOrderBy>>;
};


export type UserUserDevicesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserDeviceCondition>;
  filter?: Maybe<UserDeviceFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserDevicesOrderBy>>;
};


export type UserUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};


export type UserUsersByMessageRecipientIdAndSenderIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type UserUsersByMessageSenderIdAndRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type UserUsersByUserFollowerFollowerIdAndUserIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};


export type UserUsersByUserFollowerUserIdAndFollowerIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `avatarUrl` field. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bio` field. */
  bio?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `displayName` field. */
  displayName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `emailNotificationsEnabled` field. */
  emailNotificationsEnabled?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `emailUnsubscribeToken` field. */
  emailUnsubscribeToken?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `googleId` field. */
  googleId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `lastActiveAt` field. */
  lastActiveAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `locale` field. */
  locale?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `resetPasswordToken` field. */
  resetPasswordToken?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `resetPasswordTokenCreatedAt` field. */
  resetPasswordTokenCreatedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `signedUpWithTokenId` field. */
  signedUpWithTokenId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `unconfirmedEmail` field. */
  unconfirmedEmail?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

export type UserDevice = Node & {
  __typename?: 'UserDevice';
  createdAt: Scalars['Datetime'];
  fcmToken?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `UserDevice`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
};

/**
 * A condition to be used against `UserDevice` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserDeviceCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `fcmToken` field. */
  fcmToken?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `UserDevice` object types. All fields are combined with a logical ‘and.’ */
export type UserDeviceFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserDeviceFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `fcmToken` field. */
  fcmToken?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<UserDeviceFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserDeviceFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

/** An input for mutations affecting `UserDevice` */
export type UserDeviceInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  fcmToken?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** Represents an update to a `UserDevice`. Fields that are set will be updated. */
export type UserDevicePatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  fcmToken?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `UserDevice` values. */
export type UserDevicesConnection = {
  __typename?: 'UserDevicesConnection';
  /** A list of edges which contains the `UserDevice` and cursor to aid in pagination. */
  edges: Array<UserDevicesEdge>;
  /** A list of `UserDevice` objects. */
  nodes: Array<Maybe<UserDevice>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserDevice` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserDevice` edge in the connection. */
export type UserDevicesEdge = {
  __typename?: 'UserDevicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserDevice` at the end of the edge. */
  node?: Maybe<UserDevice>;
};

/** Methods to use when ordering `UserDevice`. */
export enum UserDevicesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FcmTokenAsc = 'FCM_TOKEN_ASC',
  FcmTokenDesc = 'FCM_TOKEN_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>;
  /** Filter by the object’s `avatarUrl` field. */
  avatarUrl?: Maybe<StringFilter>;
  /** Filter by the object’s `bio` field. */
  bio?: Maybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `displayName` field. */
  displayName?: Maybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `emailNotificationsEnabled` field. */
  emailNotificationsEnabled?: Maybe<BooleanFilter>;
  /** Filter by the object’s `emailUnsubscribeToken` field. */
  emailUnsubscribeToken?: Maybe<StringFilter>;
  /** Filter by the object’s `followedByCurrentUser` field. */
  followedByCurrentUser?: Maybe<BooleanFilter>;
  /** Filter by the object’s `gender` field. */
  gender?: Maybe<StringFilter>;
  /** Filter by the object’s `googleId` field. */
  googleId?: Maybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `lastActiveAt` field. */
  lastActiveAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `locale` field. */
  locale?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: Maybe<StringFilter>;
  /** Filter by the object’s `resetPasswordToken` field. */
  resetPasswordToken?: Maybe<StringFilter>;
  /** Filter by the object’s `resetPasswordTokenCreatedAt` field. */
  resetPasswordTokenCreatedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `signedUpWithTokenId` field. */
  signedUpWithTokenId?: Maybe<IntFilter>;
  /** Filter by the object’s `unconfirmedEmail` field. */
  unconfirmedEmail?: Maybe<StringFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: Maybe<UuidFilter>;
};

export type UserFollower = Node & {
  __typename?: 'UserFollower';
  createdAt: Scalars['Datetime'];
  /** Reads a single `User` that is related to this `UserFollower`. */
  follower?: Maybe<User>;
  followerId: Scalars['Int'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `UserFollower`. */
  user?: Maybe<User>;
  userId: Scalars['Int'];
};

/**
 * A condition to be used against `UserFollower` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserFollowerCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `followerId` field. */
  followerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `UserFollower` object types. All fields are combined with a logical ‘and.’ */
export type UserFollowerFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFollowerFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `followerId` field. */
  followerId?: Maybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<UserFollowerFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFollowerFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
};

/** An input for mutations affecting `UserFollower` */
export type UserFollowerInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  followerId: Scalars['Int'];
  id?: Maybe<Scalars['Int']>;
  userId: Scalars['Int'];
};

/** Represents an update to a `UserFollower`. Fields that are set will be updated. */
export type UserFollowerPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  followerId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `UserFollower` values. */
export type UserFollowersConnection = {
  __typename?: 'UserFollowersConnection';
  /** A list of edges which contains the `UserFollower` and cursor to aid in pagination. */
  edges: Array<UserFollowersEdge>;
  /** A list of `UserFollower` objects. */
  nodes: Array<Maybe<UserFollower>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserFollower` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserFollower` edge in the connection. */
export type UserFollowersEdge = {
  __typename?: 'UserFollowersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserFollower` at the end of the edge. */
  node?: Maybe<UserFollower>;
};

/** Methods to use when ordering `UserFollower`. */
export enum UserFollowersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FollowerIdAsc = 'FOLLOWER_ID_ASC',
  FollowerIdDesc = 'FOLLOWER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Group` values, with data from `GroupUser`. */
export type UserGroupsByGroupUserUserIdAndGroupIdManyToManyConnection = {
  __typename?: 'UserGroupsByGroupUserUserIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `GroupUser`, and the cursor to aid in pagination. */
  edges: Array<UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Maybe<Group>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection, with data from `GroupUser`. */
export type UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdge = {
  __typename?: 'UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  /** The `Group` at the end of the edge. */
  node?: Maybe<Group>;
};


/** A `Group` edge in the connection, with data from `GroupUser`. */
export type UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdgeGroupUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<GroupUserCondition>;
  filter?: Maybe<GroupUserFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupUsersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Message`. */
export type UserGroupsByMessageRecipientIdAndRecipientGroupIdManyToManyConnection = {
  __typename?: 'UserGroupsByMessageRecipientIdAndRecipientGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<UserGroupsByMessageRecipientIdAndRecipientGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Maybe<Group>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection, with data from `Message`. */
export type UserGroupsByMessageRecipientIdAndRecipientGroupIdManyToManyEdge = {
  __typename?: 'UserGroupsByMessageRecipientIdAndRecipientGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientGroupId: MessagesConnection;
  /** The `Group` at the end of the edge. */
  node?: Maybe<Group>;
};


/** A `Group` edge in the connection, with data from `Message`. */
export type UserGroupsByMessageRecipientIdAndRecipientGroupIdManyToManyEdgeMessagesByRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Message`. */
export type UserGroupsByMessageSenderIdAndRecipientGroupIdManyToManyConnection = {
  __typename?: 'UserGroupsByMessageSenderIdAndRecipientGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<UserGroupsByMessageSenderIdAndRecipientGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Maybe<Group>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection, with data from `Message`. */
export type UserGroupsByMessageSenderIdAndRecipientGroupIdManyToManyEdge = {
  __typename?: 'UserGroupsByMessageSenderIdAndRecipientGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientGroupId: MessagesConnection;
  /** The `Group` at the end of the edge. */
  node?: Maybe<Group>;
};


/** A `Group` edge in the connection, with data from `Message`. */
export type UserGroupsByMessageSenderIdAndRecipientGroupIdManyToManyEdgeMessagesByRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Notification`. */
export type UserGroupsByNotificationRecipientIdAndRecipientGroupIdManyToManyConnection = {
  __typename?: 'UserGroupsByNotificationRecipientIdAndRecipientGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Notification`, and the cursor to aid in pagination. */
  edges: Array<UserGroupsByNotificationRecipientIdAndRecipientGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Maybe<Group>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Group` edge in the connection, with data from `Notification`. */
export type UserGroupsByNotificationRecipientIdAndRecipientGroupIdManyToManyEdge = {
  __typename?: 'UserGroupsByNotificationRecipientIdAndRecipientGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Group` at the end of the edge. */
  node?: Maybe<Group>;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByRecipientGroupId: NotificationsConnection;
};


/** A `Group` edge in the connection, with data from `Notification`. */
export type UserGroupsByNotificationRecipientIdAndRecipientGroupIdManyToManyEdgeNotificationsByRecipientGroupIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  avatarUrl?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  displayName?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  emailNotificationsEnabled?: Maybe<Scalars['Boolean']>;
  emailUnsubscribeToken?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  googleId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastActiveAt?: Maybe<Scalars['Datetime']>;
  locale?: Maybe<Scalars['Int']>;
  passwordHash?: Maybe<Scalars['String']>;
  resetPasswordToken?: Maybe<Scalars['String']>;
  resetPasswordTokenCreatedAt?: Maybe<Scalars['Datetime']>;
  signedUpWithTokenId?: Maybe<Scalars['Int']>;
  unconfirmedEmail?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  uuid?: Maybe<Scalars['UUID']>;
};

export type UserLanguage = Node & {
  __typename?: 'UserLanguage';
  createdAt: Scalars['Datetime'];
  id: Scalars['Int'];
  /** Reads a single `Language` that is related to this `UserLanguage`. */
  language?: Maybe<Language>;
  languageId: Scalars['Int'];
  /** Reads a single `LanguageSkillLevel` that is related to this `UserLanguage`. */
  languageSkillLevel?: Maybe<LanguageSkillLevel>;
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  native: Scalars['Boolean'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `UserLanguage`. */
  user?: Maybe<User>;
  userId: Scalars['Int'];
};

/**
 * A condition to be used against `UserLanguage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserLanguageCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `languageId` field. */
  languageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `languageSkillLevelId` field. */
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `native` field. */
  native?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `UserLanguage` object types. All fields are combined with a logical ‘and.’ */
export type UserLanguageFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserLanguageFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `languageId` field. */
  languageId?: Maybe<IntFilter>;
  /** Filter by the object’s `languageSkillLevelId` field. */
  languageSkillLevelId?: Maybe<IntFilter>;
  /** Filter by the object’s `native` field. */
  native?: Maybe<BooleanFilter>;
  /** Negates the expression. */
  not?: Maybe<UserLanguageFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserLanguageFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
};

/** An input for mutations affecting `UserLanguage` */
export type UserLanguageInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  languageId?: Maybe<Scalars['Int']>;
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  native?: Maybe<Scalars['Boolean']>;
  userId?: Maybe<Scalars['Int']>;
};

/** Represents an update to a `UserLanguage`. Fields that are set will be updated. */
export type UserLanguagePatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  id?: Maybe<Scalars['Int']>;
  languageId?: Maybe<Scalars['Int']>;
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  native?: Maybe<Scalars['Boolean']>;
  userId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `LanguageSkillLevel` values, with data from `UserLanguage`. */
export type UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdManyToManyConnection = {
  __typename?: 'UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdManyToManyConnection';
  /** A list of edges which contains the `LanguageSkillLevel`, info from the `UserLanguage`, and the cursor to aid in pagination. */
  edges: Array<UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdManyToManyEdge>;
  /** A list of `LanguageSkillLevel` objects. */
  nodes: Array<Maybe<LanguageSkillLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LanguageSkillLevel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LanguageSkillLevel` edge in the connection, with data from `UserLanguage`. */
export type UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdManyToManyEdge = {
  __typename?: 'UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LanguageSkillLevel` at the end of the edge. */
  node?: Maybe<LanguageSkillLevel>;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
};


/** A `LanguageSkillLevel` edge in the connection, with data from `UserLanguage`. */
export type UserLanguageSkillLevelsByUserLanguageUserIdAndLanguageSkillLevelIdManyToManyEdgeUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** A connection to a list of `Language` values, with data from `Post`. */
export type UserLanguagesByPostAuthorIdAndLanguageIdManyToManyConnection = {
  __typename?: 'UserLanguagesByPostAuthorIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<UserLanguagesByPostAuthorIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `Post`. */
export type UserLanguagesByPostAuthorIdAndLanguageIdManyToManyEdge = {
  __typename?: 'UserLanguagesByPostAuthorIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
};


/** A `Language` edge in the connection, with data from `Post`. */
export type UserLanguagesByPostAuthorIdAndLanguageIdManyToManyEdgePostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** A connection to a list of `Language` values, with data from `UserLanguage`. */
export type UserLanguagesByUserLanguageUserIdAndLanguageIdManyToManyConnection = {
  __typename?: 'UserLanguagesByUserLanguageUserIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `UserLanguage`, and the cursor to aid in pagination. */
  edges: Array<UserLanguagesByUserLanguageUserIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Maybe<Language>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Language` edge in the connection, with data from `UserLanguage`. */
export type UserLanguagesByUserLanguageUserIdAndLanguageIdManyToManyEdge = {
  __typename?: 'UserLanguagesByUserLanguageUserIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Language` at the end of the edge. */
  node?: Maybe<Language>;
  /** Reads and enables pagination through a set of `UserLanguage`. */
  userLanguages: UserLanguagesConnection;
};


/** A `Language` edge in the connection, with data from `UserLanguage`. */
export type UserLanguagesByUserLanguageUserIdAndLanguageIdManyToManyEdgeUserLanguagesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserLanguageCondition>;
  filter?: Maybe<UserLanguageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserLanguagesOrderBy>>;
};

/** A connection to a list of `UserLanguage` values. */
export type UserLanguagesConnection = {
  __typename?: 'UserLanguagesConnection';
  /** A list of edges which contains the `UserLanguage` and cursor to aid in pagination. */
  edges: Array<UserLanguagesEdge>;
  /** A list of `UserLanguage` objects. */
  nodes: Array<Maybe<UserLanguage>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserLanguage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserLanguage` edge in the connection. */
export type UserLanguagesEdge = {
  __typename?: 'UserLanguagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserLanguage` at the end of the edge. */
  node?: Maybe<UserLanguage>;
};

/** Methods to use when ordering `UserLanguage`. */
export enum UserLanguagesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LanguageIdAsc = 'LANGUAGE_ID_ASC',
  LanguageIdDesc = 'LANGUAGE_ID_DESC',
  LanguageSkillLevelIdAsc = 'LANGUAGE_SKILL_LEVEL_ID_ASC',
  LanguageSkillLevelIdDesc = 'LANGUAGE_SKILL_LEVEL_ID_DESC',
  NativeAsc = 'NATIVE_ASC',
  NativeDesc = 'NATIVE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Message` values, with data from `Message`. */
export type UserMessagesByMessageRecipientIdAndParentMessageIdManyToManyConnection = {
  __typename?: 'UserMessagesByMessageRecipientIdAndParentMessageIdManyToManyConnection';
  /** A list of edges which contains the `Message`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<UserMessagesByMessageRecipientIdAndParentMessageIdManyToManyEdge>;
  /** A list of `Message` objects. */
  nodes: Array<Maybe<Message>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Message` edge in the connection, with data from `Message`. */
export type UserMessagesByMessageRecipientIdAndParentMessageIdManyToManyEdge = {
  __typename?: 'UserMessagesByMessageRecipientIdAndParentMessageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByParentMessageId: MessagesConnection;
  /** The `Message` at the end of the edge. */
  node?: Maybe<Message>;
};


/** A `Message` edge in the connection, with data from `Message`. */
export type UserMessagesByMessageRecipientIdAndParentMessageIdManyToManyEdgeMessagesByParentMessageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `Message` values, with data from `Message`. */
export type UserMessagesByMessageSenderIdAndParentMessageIdManyToManyConnection = {
  __typename?: 'UserMessagesByMessageSenderIdAndParentMessageIdManyToManyConnection';
  /** A list of edges which contains the `Message`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<UserMessagesByMessageSenderIdAndParentMessageIdManyToManyEdge>;
  /** A list of `Message` objects. */
  nodes: Array<Maybe<Message>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Message` edge in the connection, with data from `Message`. */
export type UserMessagesByMessageSenderIdAndParentMessageIdManyToManyEdge = {
  __typename?: 'UserMessagesByMessageSenderIdAndParentMessageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByParentMessageId: MessagesConnection;
  /** The `Message` at the end of the edge. */
  node?: Maybe<Message>;
};


/** A `Message` edge in the connection, with data from `Message`. */
export type UserMessagesByMessageSenderIdAndParentMessageIdManyToManyEdgeMessagesByParentMessageIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `NotificationChannel` values, with data from `Notification`. */
export type UserNotificationChannelsByNotificationRecipientIdAndChannelIdManyToManyConnection = {
  __typename?: 'UserNotificationChannelsByNotificationRecipientIdAndChannelIdManyToManyConnection';
  /** A list of edges which contains the `NotificationChannel`, info from the `Notification`, and the cursor to aid in pagination. */
  edges: Array<UserNotificationChannelsByNotificationRecipientIdAndChannelIdManyToManyEdge>;
  /** A list of `NotificationChannel` objects. */
  nodes: Array<Maybe<NotificationChannel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NotificationChannel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `NotificationChannel` edge in the connection, with data from `Notification`. */
export type UserNotificationChannelsByNotificationRecipientIdAndChannelIdManyToManyEdge = {
  __typename?: 'UserNotificationChannelsByNotificationRecipientIdAndChannelIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `NotificationChannel` at the end of the edge. */
  node?: Maybe<NotificationChannel>;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByChannelId: NotificationsConnection;
};


/** A `NotificationChannel` edge in the connection, with data from `Notification`. */
export type UserNotificationChannelsByNotificationRecipientIdAndChannelIdManyToManyEdgeNotificationsByChannelIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  avatarUrl?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  displayName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  emailNotificationsEnabled?: Maybe<Scalars['Boolean']>;
  emailUnsubscribeToken?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  googleId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastActiveAt?: Maybe<Scalars['Datetime']>;
  locale?: Maybe<Scalars['Int']>;
  passwordHash?: Maybe<Scalars['String']>;
  resetPasswordToken?: Maybe<Scalars['String']>;
  resetPasswordTokenCreatedAt?: Maybe<Scalars['Datetime']>;
  signedUpWithTokenId?: Maybe<Scalars['Int']>;
  unconfirmedEmail?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  uuid?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `PostGameRange` values, with data from `PostGameAnswer`. */
export type UserPostGameRangesByPostGameAnswerUserIdAndRangeIdManyToManyConnection = {
  __typename?: 'UserPostGameRangesByPostGameAnswerUserIdAndRangeIdManyToManyConnection';
  /** A list of edges which contains the `PostGameRange`, info from the `PostGameAnswer`, and the cursor to aid in pagination. */
  edges: Array<UserPostGameRangesByPostGameAnswerUserIdAndRangeIdManyToManyEdge>;
  /** A list of `PostGameRange` objects. */
  nodes: Array<Maybe<PostGameRange>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostGameRange` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostGameRange` edge in the connection, with data from `PostGameAnswer`. */
export type UserPostGameRangesByPostGameAnswerUserIdAndRangeIdManyToManyEdge = {
  __typename?: 'UserPostGameRangesByPostGameAnswerUserIdAndRangeIdManyToManyEdge';
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  answers: PostGameAnswersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGameRange` at the end of the edge. */
  node?: Maybe<PostGameRange>;
};


/** A `PostGameRange` edge in the connection, with data from `PostGameAnswer`. */
export type UserPostGameRangesByPostGameAnswerUserIdAndRangeIdManyToManyEdgeAnswersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** A connection to a list of `PostGame` values, with data from `PostGameAnswer`. */
export type UserPostGamesByPostGameAnswerUserIdAndGameIdManyToManyConnection = {
  __typename?: 'UserPostGamesByPostGameAnswerUserIdAndGameIdManyToManyConnection';
  /** A list of edges which contains the `PostGame`, info from the `PostGameAnswer`, and the cursor to aid in pagination. */
  edges: Array<UserPostGamesByPostGameAnswerUserIdAndGameIdManyToManyEdge>;
  /** A list of `PostGame` objects. */
  nodes: Array<Maybe<PostGame>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostGame` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PostGame` edge in the connection, with data from `PostGameAnswer`. */
export type UserPostGamesByPostGameAnswerUserIdAndGameIdManyToManyEdge = {
  __typename?: 'UserPostGamesByPostGameAnswerUserIdAndGameIdManyToManyEdge';
  /** Reads and enables pagination through a set of `PostGameAnswer`. */
  answerReveals: PostGameAnswersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PostGame` at the end of the edge. */
  node?: Maybe<PostGame>;
};


/** A `PostGame` edge in the connection, with data from `PostGameAnswer`. */
export type UserPostGamesByPostGameAnswerUserIdAndGameIdManyToManyEdgeAnswerRevealsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostGameAnswerCondition>;
  filter?: Maybe<PostGameAnswerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostGameAnswersOrderBy>>;
};

/** A connection to a list of `Post` values, with data from `Post`. */
export type UserPostsByPostAuthorIdAndParentPostIdManyToManyConnection = {
  __typename?: 'UserPostsByPostAuthorIdAndParentPostIdManyToManyConnection';
  /** A list of edges which contains the `Post`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<UserPostsByPostAuthorIdAndParentPostIdManyToManyEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection, with data from `Post`. */
export type UserPostsByPostAuthorIdAndParentPostIdManyToManyEdge = {
  __typename?: 'UserPostsByPostAuthorIdAndParentPostIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
  /** Reads and enables pagination through a set of `Post`. */
  replies: PostsConnection;
};


/** A `Post` edge in the connection, with data from `Post`. */
export type UserPostsByPostAuthorIdAndParentPostIdManyToManyEdgeRepliesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

/** A connection to a list of `Post` values, with data from `PostCorrection`. */
export type UserPostsByPostCorrectionUserIdAndPostIdManyToManyConnection = {
  __typename?: 'UserPostsByPostCorrectionUserIdAndPostIdManyToManyConnection';
  /** A list of edges which contains the `Post`, info from the `PostCorrection`, and the cursor to aid in pagination. */
  edges: Array<UserPostsByPostCorrectionUserIdAndPostIdManyToManyEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection, with data from `PostCorrection`. */
export type UserPostsByPostCorrectionUserIdAndPostIdManyToManyEdge = {
  __typename?: 'UserPostsByPostCorrectionUserIdAndPostIdManyToManyEdge';
  /** Reads and enables pagination through a set of `PostCorrection`. */
  corrections: PostCorrectionsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
};


/** A `Post` edge in the connection, with data from `PostCorrection`. */
export type UserPostsByPostCorrectionUserIdAndPostIdManyToManyEdgeCorrectionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCorrectionCondition>;
  filter?: Maybe<PostCorrectionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostCorrectionsOrderBy>>;
};

/** A connection to a list of `Post` values, with data from `PostLike`. */
export type UserPostsByPostLikeUserIdAndPostIdManyToManyConnection = {
  __typename?: 'UserPostsByPostLikeUserIdAndPostIdManyToManyConnection';
  /** A list of edges which contains the `Post`, info from the `PostLike`, and the cursor to aid in pagination. */
  edges: Array<UserPostsByPostLikeUserIdAndPostIdManyToManyEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection, with data from `PostLike`. */
export type UserPostsByPostLikeUserIdAndPostIdManyToManyEdge = {
  __typename?: 'UserPostsByPostLikeUserIdAndPostIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `PostLike`. */
  likes: PostLikesConnection;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
};


/** A `Post` edge in the connection, with data from `PostLike`. */
export type UserPostsByPostLikeUserIdAndPostIdManyToManyEdgeLikesArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostLikeCondition>;
  filter?: Maybe<PostLikeFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostLikesOrderBy>>;
};

/** A connection to a list of `Post` values, with data from `PostRecording`. */
export type UserPostsByPostRecordingUserIdAndPostIdManyToManyConnection = {
  __typename?: 'UserPostsByPostRecordingUserIdAndPostIdManyToManyConnection';
  /** A list of edges which contains the `Post`, info from the `PostRecording`, and the cursor to aid in pagination. */
  edges: Array<UserPostsByPostRecordingUserIdAndPostIdManyToManyEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection, with data from `PostRecording`. */
export type UserPostsByPostRecordingUserIdAndPostIdManyToManyEdge = {
  __typename?: 'UserPostsByPostRecordingUserIdAndPostIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
  /** Reads and enables pagination through a set of `PostRecording`. */
  recordings: PostRecordingsConnection;
};


/** A `Post` edge in the connection, with data from `PostRecording`. */
export type UserPostsByPostRecordingUserIdAndPostIdManyToManyEdgeRecordingsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostRecordingCondition>;
  filter?: Maybe<PostRecordingFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostRecordingsOrderBy>>;
};

/** A connection to a list of `Post` values, with data from `PostUserMention`. */
export type UserPostsByPostUserMentionUserIdAndPostIdManyToManyConnection = {
  __typename?: 'UserPostsByPostUserMentionUserIdAndPostIdManyToManyConnection';
  /** A list of edges which contains the `Post`, info from the `PostUserMention`, and the cursor to aid in pagination. */
  edges: Array<UserPostsByPostUserMentionUserIdAndPostIdManyToManyEdge>;
  /** A list of `Post` objects. */
  nodes: Array<Maybe<Post>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Post` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Post` edge in the connection, with data from `PostUserMention`. */
export type UserPostsByPostUserMentionUserIdAndPostIdManyToManyEdge = {
  __typename?: 'UserPostsByPostUserMentionUserIdAndPostIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Post` at the end of the edge. */
  node?: Maybe<Post>;
  /** Reads and enables pagination through a set of `PostUserMention`. */
  userMentions: PostUserMentionsConnection;
};


/** A `Post` edge in the connection, with data from `PostUserMention`. */
export type UserPostsByPostUserMentionUserIdAndPostIdManyToManyEdgeUserMentionsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostUserMentionCondition>;
  filter?: Maybe<PostUserMentionFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostUserMentionsOrderBy>>;
};

export type UserPreference = Node & {
  __typename?: 'UserPreference';
  createdAt: Scalars['Datetime'];
  /** Reads a single `Language` that is related to this `UserPreference`. */
  feedLanguage?: Maybe<Language>;
  feedLanguageId: Scalars['Int'];
  id: Scalars['Int'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  /** Reads a single `User` that is related to this `UserPreference`. */
  user?: Maybe<User>;
  userId: Scalars['Int'];
};

/**
 * A condition to be used against `UserPreference` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserPreferenceCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `feedLanguageId` field. */
  feedLanguageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `UserPreference` object types. All fields are combined with a logical ‘and.’ */
export type UserPreferenceFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserPreferenceFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `feedLanguageId` field. */
  feedLanguageId?: Maybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Negates the expression. */
  not?: Maybe<UserPreferenceFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserPreferenceFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
};

/** An input for mutations affecting `UserPreference` */
export type UserPreferenceInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  feedLanguageId: Scalars['Int'];
  id?: Maybe<Scalars['Int']>;
  userId: Scalars['Int'];
};

/** Represents an update to a `UserPreference`. Fields that are set will be updated. */
export type UserPreferencePatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  feedLanguageId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `UserPreference` values. */
export type UserPreferencesConnection = {
  __typename?: 'UserPreferencesConnection';
  /** A list of edges which contains the `UserPreference` and cursor to aid in pagination. */
  edges: Array<UserPreferencesEdge>;
  /** A list of `UserPreference` objects. */
  nodes: Array<Maybe<UserPreference>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserPreference` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserPreference` edge in the connection. */
export type UserPreferencesEdge = {
  __typename?: 'UserPreferencesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserPreference` at the end of the edge. */
  node?: Maybe<UserPreference>;
};

/** Methods to use when ordering `UserPreference`. */
export enum UserPreferencesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FeedLanguageIdAsc = 'FEED_LANGUAGE_ID_ASC',
  FeedLanguageIdDesc = 'FEED_LANGUAGE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Prompt` values, with data from `Post`. */
export type UserPromptsByPostAuthorIdAndPromptIdManyToManyConnection = {
  __typename?: 'UserPromptsByPostAuthorIdAndPromptIdManyToManyConnection';
  /** A list of edges which contains the `Prompt`, info from the `Post`, and the cursor to aid in pagination. */
  edges: Array<UserPromptsByPostAuthorIdAndPromptIdManyToManyEdge>;
  /** A list of `Prompt` objects. */
  nodes: Array<Maybe<Prompt>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Prompt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Prompt` edge in the connection, with data from `Post`. */
export type UserPromptsByPostAuthorIdAndPromptIdManyToManyEdge = {
  __typename?: 'UserPromptsByPostAuthorIdAndPromptIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Prompt` at the end of the edge. */
  node?: Maybe<Prompt>;
  /** Reads and enables pagination through a set of `Post`. */
  posts: PostsConnection;
};


/** A `Prompt` edge in the connection, with data from `Post`. */
export type UserPromptsByPostAuthorIdAndPromptIdManyToManyEdgePostsArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PostCondition>;
  filter?: Maybe<PostFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PostsOrderBy>>;
};

export type UserSession = Node & {
  __typename?: 'UserSession';
  createdAt: Scalars['Datetime'];
  expire: Scalars['Datetime'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  sess: Scalars['JSON'];
  sid: Scalars['String'];
};

/**
 * A condition to be used against `UserSession` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserSessionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `expire` field. */
  expire?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `sess` field. */
  sess?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `sid` field. */
  sid?: Maybe<Scalars['String']>;
};

/** A filter to be used against `UserSession` object types. All fields are combined with a logical ‘and.’ */
export type UserSessionFilter = {
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserSessionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `expire` field. */
  expire?: Maybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: Maybe<UserSessionFilter>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserSessionFilter>>;
  /** Filter by the object’s `sid` field. */
  sid?: Maybe<StringFilter>;
};

/** An input for mutations affecting `UserSession` */
export type UserSessionInput = {
  createdAt?: Maybe<Scalars['Datetime']>;
  expire: Scalars['Datetime'];
  sess: Scalars['JSON'];
  sid: Scalars['String'];
};

/** Represents an update to a `UserSession`. Fields that are set will be updated. */
export type UserSessionPatch = {
  createdAt?: Maybe<Scalars['Datetime']>;
  expire?: Maybe<Scalars['Datetime']>;
  sess?: Maybe<Scalars['JSON']>;
  sid?: Maybe<Scalars['String']>;
};

/** A connection to a list of `UserSession` values. */
export type UserSessionsConnection = {
  __typename?: 'UserSessionsConnection';
  /** A list of edges which contains the `UserSession` and cursor to aid in pagination. */
  edges: Array<UserSessionsEdge>;
  /** A list of `UserSession` objects. */
  nodes: Array<Maybe<UserSession>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserSession` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserSession` edge in the connection. */
export type UserSessionsEdge = {
  __typename?: 'UserSessionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserSession` at the end of the edge. */
  node?: Maybe<UserSession>;
};

/** Methods to use when ordering `UserSession`. */
export enum UserSessionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExpireAsc = 'EXPIRE_ASC',
  ExpireDesc = 'EXPIRE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SessAsc = 'SESS_ASC',
  SessDesc = 'SESS_DESC',
  SidAsc = 'SID_ASC',
  SidDesc = 'SID_DESC'
}

export enum UserType {
  Global = 'GLOBAL',
  Learner = 'LEARNER',
  Native = 'NATIVE'
}

/** A filter to be used against UserType fields. All fields are combined with a logical ‘and.’ */
export type UserTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<UserType>;
  /** Equal to the specified value. */
  equalTo?: Maybe<UserType>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<UserType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<UserType>;
  /** Included in the specified list. */
  in?: Maybe<Array<UserType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: Maybe<UserType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<UserType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<UserType>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<UserType>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<UserType>>;
};

/** A connection to a list of `User` values, with data from `Message`. */
export type UserUsersByMessageRecipientIdAndSenderIdManyToManyConnection = {
  __typename?: 'UserUsersByMessageRecipientIdAndSenderIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByMessageRecipientIdAndSenderIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Message`. */
export type UserUsersByMessageRecipientIdAndSenderIdManyToManyEdge = {
  __typename?: 'UserUsersByMessageRecipientIdAndSenderIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesBySenderId: MessagesConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Message`. */
export type UserUsersByMessageRecipientIdAndSenderIdManyToManyEdgeMessagesBySenderIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Message`. */
export type UserUsersByMessageSenderIdAndRecipientIdManyToManyConnection = {
  __typename?: 'UserUsersByMessageSenderIdAndRecipientIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Message`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByMessageSenderIdAndRecipientIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `Message`. */
export type UserUsersByMessageSenderIdAndRecipientIdManyToManyEdge = {
  __typename?: 'UserUsersByMessageSenderIdAndRecipientIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `Message`. */
  messagesByRecipientId: MessagesConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `Message`. */
export type UserUsersByMessageSenderIdAndRecipientIdManyToManyEdgeMessagesByRecipientIdArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<MessageCondition>;
  filter?: Maybe<MessageFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<MessagesOrderBy>>;
};

/** A connection to a list of `User` values, with data from `UserFollower`. */
export type UserUsersByUserFollowerFollowerIdAndUserIdManyToManyConnection = {
  __typename?: 'UserUsersByUserFollowerFollowerIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserFollower`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByUserFollowerFollowerIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `UserFollower`. */
export type UserUsersByUserFollowerFollowerIdAndUserIdManyToManyEdge = {
  __typename?: 'UserUsersByUserFollowerFollowerIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `UserFollower`. */
  followers: UserFollowersConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `UserFollower`. */
export type UserUsersByUserFollowerFollowerIdAndUserIdManyToManyEdgeFollowersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserFollowerCondition>;
  filter?: Maybe<UserFollowerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `UserFollower`. */
export type UserUsersByUserFollowerUserIdAndFollowerIdManyToManyConnection = {
  __typename?: 'UserUsersByUserFollowerUserIdAndFollowerIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserFollower`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByUserFollowerUserIdAndFollowerIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection, with data from `UserFollower`. */
export type UserUsersByUserFollowerUserIdAndFollowerIdManyToManyEdge = {
  __typename?: 'UserUsersByUserFollowerUserIdAndFollowerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** Reads and enables pagination through a set of `UserFollower`. */
  followedUsers: UserFollowersConnection;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};


/** A `User` edge in the connection, with data from `UserFollower`. */
export type UserUsersByUserFollowerUserIdAndFollowerIdManyToManyEdgeFollowedUsersArgs = {
  after?: Maybe<Scalars['Cursor']>;
  before?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<UserFollowerCondition>;
  filter?: Maybe<UserFollowerFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UserFollowersOrderBy>>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  AvatarUrlAsc = 'AVATAR_URL_ASC',
  AvatarUrlDesc = 'AVATAR_URL_DESC',
  BioAsc = 'BIO_ASC',
  BioDesc = 'BIO_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DisplayNameAsc = 'DISPLAY_NAME_ASC',
  DisplayNameDesc = 'DISPLAY_NAME_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  EmailNotificationsEnabledAsc = 'EMAIL_NOTIFICATIONS_ENABLED_ASC',
  EmailNotificationsEnabledDesc = 'EMAIL_NOTIFICATIONS_ENABLED_DESC',
  EmailUnsubscribeTokenAsc = 'EMAIL_UNSUBSCRIBE_TOKEN_ASC',
  EmailUnsubscribeTokenDesc = 'EMAIL_UNSUBSCRIBE_TOKEN_DESC',
  GenderAsc = 'GENDER_ASC',
  GenderDesc = 'GENDER_DESC',
  GoogleIdAsc = 'GOOGLE_ID_ASC',
  GoogleIdDesc = 'GOOGLE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastActiveAtAsc = 'LAST_ACTIVE_AT_ASC',
  LastActiveAtDesc = 'LAST_ACTIVE_AT_DESC',
  LocaleAsc = 'LOCALE_ASC',
  LocaleDesc = 'LOCALE_DESC',
  Natural = 'NATURAL',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ResetPasswordTokenAsc = 'RESET_PASSWORD_TOKEN_ASC',
  ResetPasswordTokenCreatedAtAsc = 'RESET_PASSWORD_TOKEN_CREATED_AT_ASC',
  ResetPasswordTokenCreatedAtDesc = 'RESET_PASSWORD_TOKEN_CREATED_AT_DESC',
  ResetPasswordTokenDesc = 'RESET_PASSWORD_TOKEN_DESC',
  SignedUpWithTokenIdAsc = 'SIGNED_UP_WITH_TOKEN_ID_ASC',
  SignedUpWithTokenIdDesc = 'SIGNED_UP_WITH_TOKEN_ID_DESC',
  UnconfirmedEmailAsc = 'UNCONFIRMED_EMAIL_ASC',
  UnconfirmedEmailDesc = 'UNCONFIRMED_EMAIL_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type ChatUserQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type ChatUserQuery = { __typename?: 'Query', user?: { __typename?: 'User', id: number, username?: string | null | undefined, uuid: any, avatarUrl?: string | null | undefined } | null | undefined };

export type CreateMessageMutationVariables = Exact<{
  parentMessageId?: Maybe<Scalars['Int']>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  recipientId?: Maybe<Scalars['Int']>;
  senderId?: Maybe<Scalars['Int']>;
  uuid: Scalars['UUID'];
  body: Scalars['String'];
}>;


export type CreateMessageMutation = { __typename?: 'Mutation', createMessage?: { __typename?: 'CreateMessagePayload', sender?: { __typename?: 'User', uuid: any } | null | undefined, message?: { __typename?: 'Message', id: number, uuid: any, createdAt: any } | null | undefined } | null | undefined };

export type CreateMessagePreviewMutationVariables = Exact<{
  messageId: Scalars['Int'];
  filename: Scalars['String'];
  extension?: Maybe<Scalars['String']>;
  uuid: Scalars['UUID'];
}>;


export type CreateMessagePreviewMutation = { __typename?: 'Mutation', createMessagePreview?: { __typename?: 'CreateMessagePreviewPayload', messagePreview?: { __typename?: 'MessagePreview', id: number } | null | undefined } | null | undefined };

export type GroupChatQueryVariables = Exact<{
  groupUuid: Scalars['UUID'];
}>;


export type GroupChatQuery = { __typename?: 'Query', groupByUuid?: { __typename?: 'Group', groupName?: string | null | undefined, uuid: any, language?: { __typename?: 'Language', englishName: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined, nodeId: string } | null | undefined, usersByGroupUserGroupIdAndUserId: { __typename?: 'GroupUsersByGroupUserGroupIdAndUserIdManyToManyConnection', nodes: Array<{ __typename?: 'User', bio: string, avatarUrl?: string | null | undefined, uuid: any, username?: string | null | undefined, lastActiveAt: any, userLanguages: { __typename?: 'UserLanguagesConnection', nodes: Array<{ __typename?: 'UserLanguage', nodeId: string, language?: { __typename?: 'Language', englishName: string } | null | undefined } | null | undefined> }, groupUsers: { __typename?: 'GroupUsersConnection', nodes: Array<{ __typename?: 'GroupUser', userType: UserType, nodeId: string, group?: { __typename?: 'Group', uuid: any, language?: { __typename?: 'Language', englishName: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined } | null | undefined } | null | undefined } | null | undefined> } } | null | undefined> } } | null | undefined };

export type GroupChatMessagesQueryVariables = Exact<{
  groupUuid: Scalars['UUID'];
  before?: Maybe<Scalars['Cursor']>;
}>;


export type GroupChatMessagesQuery = { __typename?: 'Query', groupByUuid?: { __typename?: 'Group', messagesByRecipientGroupId: { __typename?: 'MessagesConnection', edges: Array<{ __typename?: 'MessagesEdge', node?: { __typename?: 'Message', body: string, createdAt: any, uuid: any, sender?: { __typename?: 'User', uuid: any } | null | undefined, messagePreviews: { __typename?: 'MessagePreviewsConnection', nodes: Array<{ __typename?: 'MessagePreview', uuid: any, filename: string, extension?: string | null | undefined } | null | undefined> } } | null | undefined }>, pageInfo: { __typename?: 'PageInfo', startCursor?: any | null | undefined, hasPreviousPage: boolean } } } | null | undefined };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', bio: string, email: string, gender?: string | null | undefined, username?: string | null | undefined, uuid: any, avatarUrl?: string | null | undefined, userLanguages: { __typename?: 'UserLanguagesConnection', totalCount: number }, languageByLocale?: { __typename?: 'Language', alpha2: string } | null | undefined, inviteTokens: { __typename?: 'InviteTokensConnection', nodes: Array<{ __typename?: 'InviteToken', inviteToken: string } | null | undefined> }, preference?: { __typename?: 'UserPreference', feedLanguage?: { __typename?: 'Language', alpha2: string } | null | undefined } | null | undefined } | null | undefined };

export type RegisterUserActivityMutationVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type RegisterUserActivityMutation = { __typename?: 'Mutation', registerUserActivity?: { __typename?: 'RegisterUserActivityPayload', datetime?: any | null | undefined } | null | undefined };

export type CreatePostMutationVariables = Exact<{
  authorId: Scalars['Int'];
  body: Scalars['String'];
  parentPostId?: Maybe<Scalars['Int']>;
  languageId: Scalars['Int'];
  promptId?: Maybe<Scalars['Int']>;
}>;


export type CreatePostMutation = { __typename?: 'Mutation', createPost?: { __typename?: 'CreatePostPayload', clientMutationId?: string | null | undefined, post?: { __typename?: 'Post', body: string, createdAt: any, id: number, uuid: any, nodeId: string, snowflakeId: any } | null | undefined } | null | undefined };

export type CreatePostCorrectionMutationVariables = Exact<{
  userId: Scalars['Int'];
  postId: Scalars['Int'];
  body: Scalars['String'];
  endIndex: Scalars['Int'];
  startIndex: Scalars['Int'];
  uuid: Scalars['UUID'];
}>;


export type CreatePostCorrectionMutation = { __typename?: 'Mutation', createPostCorrection?: { __typename?: 'CreatePostCorrectionPayload', postCorrection?: { __typename?: 'PostCorrection', id: number, postId: number, userId: number, nodeId: string, createdAt: any, endIndex: number, startIndex: number, uuid: any, body: string } | null | undefined } | null | undefined };

export type CreatePostGameMutationVariables = Exact<{
  postId: Scalars['Int'];
  gameType: PostGameType;
}>;


export type CreatePostGameMutation = { __typename?: 'Mutation', createPostGame?: { __typename?: 'CreatePostGamePayload', postGame?: { __typename?: 'PostGame', id: number, postId: number, nodeId: string, createdAt: any } | null | undefined } | null | undefined };

export type CreatePostGameAnswerMutationVariables = Exact<{
  genderOption?: Maybe<GrammaticalGender>;
  caseOption?: Maybe<GrammaticalCase>;
  correct?: Maybe<Scalars['Boolean']>;
  rangeId?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  userId: Scalars['Int'];
  clozeAnswer?: Maybe<Scalars['String']>;
}>;


export type CreatePostGameAnswerMutation = { __typename?: 'Mutation', createPostGameAnswer?: { __typename?: 'CreatePostGameAnswerPayload', postGameAnswer?: { __typename?: 'PostGameAnswer', id: number, nodeId: string, createdAt: any, caseOption?: GrammaticalCase | null | undefined, uuid: any, correct?: boolean | null | undefined, clozeAnswer?: string | null | undefined, genderOption?: GrammaticalGender | null | undefined, range?: { __typename?: 'PostGameRange', uuid: any } | null | undefined, game?: { __typename?: 'PostGame', uuid: any } | null | undefined } | null | undefined } | null | undefined };

export type CreatePostGameRangeMutationVariables = Exact<{
  gameId: Scalars['Int'];
  startIndex: Scalars['Int'];
  endIndex: Scalars['Int'];
  genderOption?: Maybe<GrammaticalGender>;
  caseOption?: Maybe<GrammaticalCase>;
  uuid?: Maybe<Scalars['UUID']>;
}>;


export type CreatePostGameRangeMutation = { __typename?: 'Mutation', createPostGameRange?: { __typename?: 'CreatePostGameRangePayload', postGameRange?: { __typename?: 'PostGameRange', id: number, gameId: number, nodeId: string, createdAt: any, caseOption?: GrammaticalCase | null | undefined, endIndex: number, startIndex: number, uuid: any } | null | undefined } | null | undefined };

export type CreatePostLikeMutationVariables = Exact<{
  userId: Scalars['Int'];
  postId: Scalars['Int'];
}>;


export type CreatePostLikeMutation = { __typename?: 'Mutation', createPostLike?: { __typename?: 'CreatePostLikePayload', postLike?: { __typename?: 'PostLike', id: number, postId: number, userId: number, nodeId: string, createdAt: any } | null | undefined } | null | undefined };

export type CreatePostRecordingMutationVariables = Exact<{
  userId: Scalars['Int'];
  postId: Scalars['Int'];
  filename: Scalars['String'];
  extension?: Maybe<Scalars['String']>;
}>;


export type CreatePostRecordingMutation = { __typename?: 'Mutation', createPostRecording?: { __typename?: 'CreatePostRecordingPayload', postRecording?: { __typename?: 'PostRecording', createdAt: any, extension?: string | null | undefined, filename: string, uuid: any, nodeId: string } | null | undefined } | null | undefined };

export type CreatePostUserMentionMutationVariables = Exact<{
  userId: Scalars['Int'];
  postId: Scalars['Int'];
  endIndex: Scalars['Int'];
  startIndex: Scalars['Int'];
}>;


export type CreatePostUserMentionMutation = { __typename?: 'Mutation', createPostUserMention?: { __typename?: 'CreatePostUserMentionPayload', postUserMention?: { __typename?: 'PostUserMention', id: number, postId: number, userId: number, nodeId: string, createdAt: any, endIndex: number, startIndex: number, uuid: any } | null | undefined } | null | undefined };

export type CurrentUserHasAnsweredOrRevealedPostGameQueryVariables = Exact<{
  gameId: Scalars['Int'];
}>;


export type CurrentUserHasAnsweredOrRevealedPostGameQuery = { __typename?: 'Query', postGame?: { __typename?: 'PostGame', revealedByCurrentUser?: boolean | null | undefined, answersByCurrentUser: { __typename?: 'PostGameAnswersConnection', totalCount: number } } | null | undefined };

export type DeletePostLikeMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeletePostLikeMutation = { __typename?: 'Mutation', deletePostLike?: { __typename?: 'DeletePostLikePayload', postLike?: { __typename?: 'PostLike', postId: number, userId: number, nodeId: string, createdAt: any } | null | undefined } | null | undefined };

export type FeedPostsQueryVariables = Exact<{
  locale: Scalars['String'];
  afterUuid?: Maybe<Scalars['UUID']>;
}>;


export type FeedPostsQuery = { __typename?: 'Query', feedPosts?: { __typename?: 'PostsConnection', edges: Array<{ __typename?: 'PostsEdge', node?: { __typename?: 'Post', uuid: any, nodeId: string, createdAt: any, body: string, snowflakeId: any, author?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined, displayName?: string | null | undefined } | null | undefined, likes: { __typename?: 'PostLikesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostLike', user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, parentPost?: { __typename?: 'Post', uuid: any } | null | undefined, replies: { __typename?: 'PostsConnection', totalCount: number, nodes: Array<{ __typename?: 'Post', uuid: any, nodeId: string, createdAt: any, body: string, snowflakeId: any, author?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined } | null | undefined, likes: { __typename?: 'PostLikesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostLike', user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, parentPost?: { __typename?: 'Post', uuid: any } | null | undefined, language?: { __typename?: 'Language', alpha2: string } | null | undefined, prompt?: { __typename?: 'Prompt', content?: string | null | undefined, uuid: any, type: PromptType } | null | undefined, userMentions: { __typename?: 'PostUserMentionsConnection', nodes: Array<{ __typename?: 'PostUserMention', startIndex: number, endIndex: number, uuid: any, user?: { __typename?: 'User', displayName?: string | null | undefined, username?: string | null | undefined, uuid: any } | null | undefined } | null | undefined> } } | null | undefined> }, recordings: { __typename?: 'PostRecordingsConnection', totalCount: number, nodes: Array<{ __typename?: 'PostRecording', filename: string, extension?: string | null | undefined, uuid: any, user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, language?: { __typename?: 'Language', alpha2: string } | null | undefined, prompt?: { __typename?: 'Prompt', content?: string | null | undefined, uuid: any, type: PromptType } | null | undefined, games: { __typename?: 'PostGamesConnection', nodes: Array<{ __typename?: 'PostGame', gameType: PostGameType, uuid: any, revealedByCurrentUser?: boolean | null | undefined, ranges: { __typename?: 'PostGameRangesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostGameRange', endIndex: number, startIndex: number, uuid: any, answers: { __typename?: 'PostGameAnswersConnection', edges: Array<{ __typename?: 'PostGameAnswersEdge', node?: { __typename?: 'PostGameAnswer', id: number } | null | undefined }> } } | null | undefined> }, answersByCurrentUser: { __typename?: 'PostGameAnswersConnection', totalCount: number, nodes: Array<{ __typename?: 'PostGameAnswer', caseOption?: GrammaticalCase | null | undefined, clozeAnswer?: string | null | undefined, correct?: boolean | null | undefined, genderOption?: GrammaticalGender | null | undefined, range?: { __typename?: 'PostGameRange', uuid: any } | null | undefined } | null | undefined> }, correctAnswers: { __typename?: 'PostGamesCorrectAnswersConnection', nodes: Array<{ __typename?: 'PostGamesCorrectAnswersRecord', caseOption?: GrammaticalCase | null | undefined, clozeAnswer?: string | null | undefined, genderOption?: GrammaticalGender | null | undefined, rangeUuid?: any | null | undefined } | null | undefined> }, answerers: { __typename?: 'UsersConnection', totalCount: number } } | null | undefined> }, corrections: { __typename?: 'PostCorrectionsConnection', nodes: Array<{ __typename?: 'PostCorrection', body: string, endIndex: number, createdAt: any, startIndex: number, uuid: any, user?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined, displayName?: string | null | undefined } | null | undefined } | null | undefined> } } | null | undefined }> } | null | undefined };

export type PostGameByUuidQueryVariables = Exact<{
  uuid: Scalars['UUID'];
}>;


export type PostGameByUuidQuery = { __typename?: 'Query', postGameByUuid?: { __typename?: 'PostGame', id: number, nodeId: string, gameType: PostGameType, ranges: { __typename?: 'PostGameRangesConnection', nodes: Array<{ __typename?: 'PostGameRange', uuid: any, id: number, caseOption?: GrammaticalCase | null | undefined, genderOption?: GrammaticalGender | null | undefined, startIndex: number, endIndex: number } | null | undefined> }, post?: { __typename?: 'Post', authorId?: number | null | undefined, language?: { __typename?: 'Language', alpha2: string } | null | undefined } | null | undefined, correctAnswers: { __typename?: 'PostGamesCorrectAnswersConnection', nodes: Array<{ __typename?: 'PostGamesCorrectAnswersRecord', caseOption?: GrammaticalCase | null | undefined, clozeAnswer?: string | null | undefined, genderOption?: GrammaticalGender | null | undefined, rangeUuid?: any | null | undefined } | null | undefined> } } | null | undefined };

export type PostGameIdByUuidQueryVariables = Exact<{
  uuid: Scalars['UUID'];
}>;


export type PostGameIdByUuidQuery = { __typename?: 'Query', postGameByUuid?: { __typename?: 'PostGame', id: number, nodeId: string } | null | undefined };

export type PostIdByUuidQueryVariables = Exact<{
  uuid: Scalars['UUID'];
}>;


export type PostIdByUuidQuery = { __typename?: 'Query', postByUuid?: { __typename?: 'Post', id: number, nodeId: string } | null | undefined };

export type PostLikeIdByPostIdAndUserIdQueryVariables = Exact<{
  postId: Scalars['Int'];
  userId: Scalars['Int'];
}>;


export type PostLikeIdByPostIdAndUserIdQuery = { __typename?: 'Query', postLikes?: { __typename?: 'PostLikesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostLike', id: number, nodeId: string } | null | undefined> } | null | undefined };

export type PromptIdByUuidQueryVariables = Exact<{
  uuid: Scalars['UUID'];
}>;


export type PromptIdByUuidQuery = { __typename?: 'Query', promptByUuid?: { __typename?: 'Prompt', id: number, nodeId: string } | null | undefined };

export type SinglePostQueryVariables = Exact<{
  snowflakeId: Scalars['BigInt'];
}>;


export type SinglePostQuery = { __typename?: 'Query', posts?: { __typename?: 'PostsConnection', nodes: Array<{ __typename?: 'Post', uuid: any, nodeId: string, createdAt: any, body: string, snowflakeId: any, author?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined, displayName?: string | null | undefined } | null | undefined, likes: { __typename?: 'PostLikesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostLike', user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, parentPost?: { __typename?: 'Post', uuid: any } | null | undefined, replies: { __typename?: 'PostsConnection', totalCount: number, nodes: Array<{ __typename?: 'Post', uuid: any, nodeId: string, createdAt: any, body: string, snowflakeId: any, author?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined } | null | undefined, likes: { __typename?: 'PostLikesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostLike', user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, parentPost?: { __typename?: 'Post', uuid: any } | null | undefined, language?: { __typename?: 'Language', alpha2: string } | null | undefined, prompt?: { __typename?: 'Prompt', content?: string | null | undefined, uuid: any, type: PromptType } | null | undefined, userMentions: { __typename?: 'PostUserMentionsConnection', nodes: Array<{ __typename?: 'PostUserMention', startIndex: number, endIndex: number, uuid: any, user?: { __typename?: 'User', displayName?: string | null | undefined, username?: string | null | undefined, uuid: any } | null | undefined } | null | undefined> } } | null | undefined> }, recordings: { __typename?: 'PostRecordingsConnection', totalCount: number, nodes: Array<{ __typename?: 'PostRecording', filename: string, extension?: string | null | undefined, uuid: any, user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, language?: { __typename?: 'Language', alpha2: string } | null | undefined, prompt?: { __typename?: 'Prompt', content?: string | null | undefined, uuid: any, type: PromptType } | null | undefined, games: { __typename?: 'PostGamesConnection', nodes: Array<{ __typename?: 'PostGame', gameType: PostGameType, uuid: any, revealedByCurrentUser?: boolean | null | undefined, ranges: { __typename?: 'PostGameRangesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostGameRange', endIndex: number, startIndex: number, uuid: any, answers: { __typename?: 'PostGameAnswersConnection', edges: Array<{ __typename?: 'PostGameAnswersEdge', node?: { __typename?: 'PostGameAnswer', id: number } | null | undefined }> } } | null | undefined> }, answersByCurrentUser: { __typename?: 'PostGameAnswersConnection', totalCount: number, nodes: Array<{ __typename?: 'PostGameAnswer', caseOption?: GrammaticalCase | null | undefined, clozeAnswer?: string | null | undefined, correct?: boolean | null | undefined, genderOption?: GrammaticalGender | null | undefined, range?: { __typename?: 'PostGameRange', uuid: any } | null | undefined } | null | undefined> }, correctAnswers: { __typename?: 'PostGamesCorrectAnswersConnection', nodes: Array<{ __typename?: 'PostGamesCorrectAnswersRecord', caseOption?: GrammaticalCase | null | undefined, clozeAnswer?: string | null | undefined, genderOption?: GrammaticalGender | null | undefined, rangeUuid?: any | null | undefined } | null | undefined> }, answerers: { __typename?: 'UsersConnection', totalCount: number } } | null | undefined> }, corrections: { __typename?: 'PostCorrectionsConnection', nodes: Array<{ __typename?: 'PostCorrection', body: string, endIndex: number, createdAt: any, startIndex: number, uuid: any, user?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined, displayName?: string | null | undefined } | null | undefined } | null | undefined> } } | null | undefined> } | null | undefined };

export type CreateUserFollowershipMutationVariables = Exact<{
  userId: Scalars['Int'];
  followerId: Scalars['Int'];
}>;


export type CreateUserFollowershipMutation = { __typename?: 'Mutation', createUserFollower?: { __typename?: 'CreateUserFollowerPayload', userFollower?: { __typename?: 'UserFollower', id: number, userId: number, followerId: number, nodeId: string, createdAt: any } | null | undefined } | null | undefined };

export type DeleteUserFollowershipMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteUserFollowershipMutation = { __typename?: 'Mutation', deleteUserFollower?: { __typename?: 'DeleteUserFollowerPayload', userFollower?: { __typename?: 'UserFollower', followerId: number, userId: number, nodeId: string, createdAt: any } | null | undefined } | null | undefined };

export type UserByUsernameFollowershipsQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type UserByUsernameFollowershipsQuery = { __typename?: 'Query', userByUsername?: { __typename?: 'User', followers: { __typename?: 'UserFollowersConnection', nodes: Array<{ __typename?: 'UserFollower', follower?: { __typename?: 'User', uuid: any, avatarUrl?: string | null | undefined, bio: string, displayName?: string | null | undefined, username?: string | null | undefined, followedByCurrentUser?: boolean | null | undefined } | null | undefined } | null | undefined> }, followedUsers: { __typename?: 'UserFollowersConnection', nodes: Array<{ __typename?: 'UserFollower', user?: { __typename?: 'User', avatarUrl?: string | null | undefined, bio: string, displayName?: string | null | undefined, uuid: any, followedByCurrentUser?: boolean | null | undefined, username?: string | null | undefined } | null | undefined } | null | undefined> } } | null | undefined };

export type UserFollowershipIdByUserIdAndFollowerIdQueryVariables = Exact<{
  followerId: Scalars['Int'];
  userId: Scalars['Int'];
}>;


export type UserFollowershipIdByUserIdAndFollowerIdQuery = { __typename?: 'Query', userFollowers?: { __typename?: 'UserFollowersConnection', totalCount: number, nodes: Array<{ __typename?: 'UserFollower', id: number, nodeId: string } | null | undefined> } | null | undefined };

export type CreateGroupUserMutationVariables = Exact<{
  userType: UserType;
  userId: Scalars['Int'];
  groupId: Scalars['Int'];
}>;


export type CreateGroupUserMutation = { __typename?: 'Mutation', createGroupUser?: { __typename?: 'CreateGroupUserPayload', groupUser?: { __typename?: 'GroupUser', id: number } | null | undefined } | null | undefined };

export type JoinGlobalGroupMutationVariables = Exact<{
  groupUuid: Scalars['UUID'];
}>;


export type JoinGlobalGroupMutation = { __typename?: 'Mutation', joinGlobalGroup?: { __typename?: 'JoinGlobalGroupPayload', groupUser?: { __typename?: 'GroupUser', nodeId: string, group?: { __typename?: 'Group', uuid: any } | null | undefined, user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined } | null | undefined };

export type UserGroupMembershipsQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type UserGroupMembershipsQuery = { __typename?: 'Query', user?: { __typename?: 'User', groupUsers: { __typename?: 'GroupUsersConnection', edges: Array<{ __typename?: 'GroupUsersEdge', node?: { __typename?: 'GroupUser', userType: UserType, group?: { __typename?: 'Group', global: boolean, uuid: any, groupName?: string | null | undefined, language?: { __typename?: 'Language', alpha2: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined } | null | undefined } | null | undefined } | null | undefined }> } } | null | undefined };

export type UserIsInGroupQueryVariables = Exact<{
  userId: Scalars['Int'];
  groupUuid: Scalars['UUID'];
}>;


export type UserIsInGroupQuery = { __typename?: 'Query', groupByUuid?: { __typename?: 'Group', groupUsers: { __typename?: 'GroupUsersConnection', totalCount: number } } | null | undefined };

export type UsersWithoutLearnerGroupQueryVariables = Exact<{
  lid: Scalars['Int'];
  lsklid: Scalars['Int'];
  learnerSize: Scalars['Int'];
}>;


export type UsersWithoutLearnerGroupQuery = { __typename?: 'Query', usersWithoutLearnerGroup?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', id: number } | null | undefined> } | null | undefined };

export type UsersWithoutNativeGroupQueryVariables = Exact<{
  lid: Scalars['Int'];
  nativeSize: Scalars['Int'];
}>;


export type UsersWithoutNativeGroupQuery = { __typename?: 'Query', usersWithoutNativeGroup?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', id: number } | null | undefined> } | null | undefined };

export type AllGroupUuidsQueryVariables = Exact<{ [key: string]: never; }>;


export type AllGroupUuidsQuery = { __typename?: 'Query', groups?: { __typename?: 'GroupsConnection', nodes: Array<{ __typename?: 'Group', uuid: any } | null | undefined> } | null | undefined };

export type AllGroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type AllGroupsQuery = { __typename?: 'Query', groups?: { __typename?: 'GroupsConnection', nodes: Array<{ __typename?: 'Group', uuid: any, groupName?: string | null | undefined, global: boolean, language?: { __typename?: 'Language', alpha2: string, englishName: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined, nodeId: string } | null | undefined, groupUsers: { __typename?: 'GroupUsersConnection', totalCount: number, nodes: Array<{ __typename?: 'GroupUser', joinedOn: any, user?: { __typename?: 'User', avatarUrl?: string | null | undefined, username?: string | null | undefined, uuid: any } | null | undefined } | null | undefined> } } | null | undefined> } | null | undefined };

export type CreateGroupMutationVariables = Exact<{
  global: Scalars['Boolean'];
  groupName: Scalars['String'];
  languageId: Scalars['Int'];
  languageSkillLevelId: Scalars['Int'];
  uuid: Scalars['UUID'];
}>;


export type CreateGroupMutation = { __typename?: 'Mutation', createGroup?: { __typename?: 'CreateGroupPayload', group?: { __typename?: 'Group', id: number, uuid: any } | null | undefined } | null | undefined };

export type GroupIdByUuidQueryVariables = Exact<{
  uuid: Scalars['UUID'];
}>;


export type GroupIdByUuidQuery = { __typename?: 'Query', groupByUuid?: { __typename?: 'Group', id: number } | null | undefined };

export type GroupLanguageByUuidQueryVariables = Exact<{
  uuid: Scalars['UUID'];
}>;


export type GroupLanguageByUuidQuery = { __typename?: 'Query', groupByUuid?: { __typename?: 'Group', uuid: any, language?: { __typename?: 'Language', alpha2: string } | null | undefined } | null | undefined };

export type LanguageCodeMappingsQueryVariables = Exact<{ [key: string]: never; }>;


export type LanguageCodeMappingsQuery = { __typename?: 'Query', languages?: { __typename?: 'LanguagesConnection', nodes: Array<{ __typename?: 'Language', alpha2: string, englishName: string } | null | undefined> } | null | undefined };

export type LanguageIdByAlpha2QueryVariables = Exact<{
  alpha2: Scalars['String'];
}>;


export type LanguageIdByAlpha2Query = { __typename?: 'Query', languageByAlpha2?: { __typename?: 'Language', id: number } | null | undefined };

export type AdminEmailsFcmTokensQueryVariables = Exact<{
  in: Array<Scalars['String']> | Scalars['String'];
}>;


export type AdminEmailsFcmTokensQuery = { __typename?: 'Query', users?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', userDevices: { __typename?: 'UserDevicesConnection', nodes: Array<{ __typename?: 'UserDevice', fcmToken?: string | null | undefined } | null | undefined> } } | null | undefined> } | null | undefined };

export type CreateNotificationMutationVariables = Exact<{
  channelId: Scalars['Int'];
  recipientId?: Maybe<Scalars['Int']>;
  recipientGroupId?: Maybe<Scalars['Int']>;
  sentAt?: Maybe<Scalars['Datetime']>;
  params?: Maybe<Scalars['JSON']>;
  expiresAt?: Maybe<Scalars['Datetime']>;
  withheldUntil?: Maybe<Scalars['Datetime']>;
}>;


export type CreateNotificationMutation = { __typename?: 'Mutation', createNotification?: { __typename?: 'CreateNotificationPayload', clientMutationId?: string | null | undefined, notification?: { __typename?: 'Notification', createdAt: any, expiresAt?: any | null | undefined, withheldUntil?: any | null | undefined, id: number } | null | undefined } | null | undefined };

export type CreateUserDeviceMutationVariables = Exact<{
  userId: Scalars['Int'];
  fcmToken?: Maybe<Scalars['String']>;
}>;


export type CreateUserDeviceMutation = { __typename?: 'Mutation', createUserDevice?: { __typename?: 'CreateUserDevicePayload', userDevice?: { __typename?: 'UserDevice', uuid: any, fcmToken?: string | null | undefined, id: number } | null | undefined } | null | undefined };

export type DeleteInvalidFcmTokenMutationVariables = Exact<{
  fcmToken: Scalars['String'];
}>;


export type DeleteInvalidFcmTokenMutation = { __typename?: 'Mutation', deleteUserDeviceByFcmToken?: { __typename?: 'DeleteUserDevicePayload', clientMutationId?: string | null | undefined, userDevice?: { __typename?: 'UserDevice', userId?: number | null | undefined, fcmToken?: string | null | undefined, id: number } | null | undefined } | null | undefined };

export type GroupMessageNotificationQueryVariables = Exact<{
  groupUuid: Scalars['UUID'];
  senderUuid: Scalars['UUID'];
}>;


export type GroupMessageNotificationQuery = { __typename?: 'Query', groupByUuid?: { __typename?: 'Group', groupName?: string | null | undefined, uuid: any, groupUsers: { __typename?: 'GroupUsersConnection', nodes: Array<{ __typename?: 'GroupUser', user?: { __typename?: 'User', uuid: any, userDevices: { __typename?: 'UserDevicesConnection', nodes: Array<{ __typename?: 'UserDevice', fcmToken?: string | null | undefined } | null | undefined> } } | null | undefined } | null | undefined> }, language?: { __typename?: 'Language', alpha2: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined } | null | undefined } | null | undefined, userByUuid?: { __typename?: 'User', username?: string | null | undefined } | null | undefined };

export type MarkNotificationAsSentMutationVariables = Exact<{
  id: Scalars['Int'];
  sentAt?: Maybe<Scalars['Datetime']>;
}>;


export type MarkNotificationAsSentMutation = { __typename?: 'Mutation', updateNotification?: { __typename?: 'UpdateNotificationPayload', notification?: { __typename?: 'Notification', id: number, sentAt?: any | null | undefined } | null | undefined } | null | undefined };

export type NotificationChannelByNameQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type NotificationChannelByNameQuery = { __typename?: 'Query', notificationChannelByName?: { __typename?: 'NotificationChannel', id: number } | null | undefined };

export type OutstandingEmailNotificationsQueryVariables = Exact<{ [key: string]: never; }>;


export type OutstandingEmailNotificationsQuery = { __typename?: 'Query', notificationChannelByName?: { __typename?: 'NotificationChannel', notificationsByChannelId: { __typename?: 'NotificationsConnection', nodes: Array<{ __typename?: 'Notification', id: number, params?: any | null | undefined, expiresAt?: any | null | undefined, withheldUntil?: any | null | undefined, recipient?: { __typename?: 'User', email: string, emailNotificationsEnabled: boolean, username?: string | null | undefined, unconfirmedEmail?: string | null | undefined } | null | undefined } | null | undefined> } } | null | undefined };

export type OutstandingFcmNotificationsQueryVariables = Exact<{ [key: string]: never; }>;


export type OutstandingFcmNotificationsQuery = { __typename?: 'Query', notificationChannelByName?: { __typename?: 'NotificationChannel', notificationsByChannelId: { __typename?: 'NotificationsConnection', nodes: Array<{ __typename?: 'Notification', id: number, params?: any | null | undefined, expiresAt?: any | null | undefined, withheldUntil?: any | null | undefined, recipient?: { __typename?: 'User', uuid: any, userDevices: { __typename?: 'UserDevicesConnection', nodes: Array<{ __typename?: 'UserDevice', fcmToken?: string | null | undefined } | null | undefined> } } | null | undefined, recipientGroup?: { __typename?: 'Group', uuid: any, groupUsers: { __typename?: 'GroupUsersConnection', nodes: Array<{ __typename?: 'GroupUser', user?: { __typename?: 'User', uuid: any, userDevices: { __typename?: 'UserDevicesConnection', nodes: Array<{ __typename?: 'UserDevice', fcmToken?: string | null | undefined } | null | undefined> } } | null | undefined } | null | undefined> } } | null | undefined } | null | undefined> } } | null | undefined };

export type PostLikeNotificationQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type PostLikeNotificationQuery = { __typename?: 'Query', postLike?: { __typename?: 'PostLike', post?: { __typename?: 'Post', authorId?: number | null | undefined, body: string, parentPostId?: number | null | undefined, snowflakeId: any } | null | undefined, user?: { __typename?: 'User', id: number, username?: string | null | undefined, displayName?: string | null | undefined } | null | undefined } | null | undefined };

export type PostReplyNotificationQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type PostReplyNotificationQuery = { __typename?: 'Query', post?: { __typename?: 'Post', authorId?: number | null | undefined, body: string, createdAt: any, snowflakeId: any, parentPost?: { __typename?: 'Post', authorId?: number | null | undefined, snowflakeId: any } | null | undefined, author?: { __typename?: 'User', displayName?: string | null | undefined, username?: string | null | undefined } | null | undefined } | null | undefined };

export type PostUserMentionNotificationQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type PostUserMentionNotificationQuery = { __typename?: 'Query', postUserMention?: { __typename?: 'PostUserMention', userId: number, postId: number, post?: { __typename?: 'Post', body: string, parentPost?: { __typename?: 'Post', authorId?: number | null | undefined, snowflakeId: any } | null | undefined, author?: { __typename?: 'User', displayName?: string | null | undefined, username?: string | null | undefined } | null | undefined } | null | undefined } | null | undefined };

export type UnsubscribeUserEmailNotificationsMutationVariables = Exact<{
  token: Scalars['String'];
  lastActiveAt: Scalars['Datetime'];
}>;


export type UnsubscribeUserEmailNotificationsMutation = { __typename?: 'Mutation', updateUserByEmailUnsubscribeToken?: { __typename?: 'UpdateUserPayload', clientMutationId?: string | null | undefined, user?: { __typename?: 'User', email: string, uuid: any, username?: string | null | undefined } | null | undefined } | null | undefined };

export type UserFollowershipNotificationQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type UserFollowershipNotificationQuery = { __typename?: 'Query', userFollower?: { __typename?: 'UserFollower', follower?: { __typename?: 'User', username?: string | null | undefined, displayName?: string | null | undefined } | null | undefined, user?: { __typename?: 'User', id: number } | null | undefined } | null | undefined };

export type UserPasswordResetEmailNotificationQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type UserPasswordResetEmailNotificationQuery = { __typename?: 'Query', user?: { __typename?: 'User', username?: string | null | undefined, displayName?: string | null | undefined, resetPasswordToken?: string | null | undefined } | null | undefined };

export type UserPasswordResetSuccessEmailNotificationQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type UserPasswordResetSuccessEmailNotificationQuery = { __typename?: 'Query', user?: { __typename?: 'User', username?: string | null | undefined, displayName?: string | null | undefined } | null | undefined };

export type UserByUsernamePostsQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type UserByUsernamePostsQuery = { __typename?: 'Query', userByUsername?: { __typename?: 'User', authoredPosts: { __typename?: 'PostsConnection', nodes: Array<{ __typename?: 'Post', uuid: any, nodeId: string, createdAt: any, body: string, snowflakeId: any, author?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined, displayName?: string | null | undefined } | null | undefined, likes: { __typename?: 'PostLikesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostLike', user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, parentPost?: { __typename?: 'Post', uuid: any } | null | undefined, replies: { __typename?: 'PostsConnection', totalCount: number, nodes: Array<{ __typename?: 'Post', uuid: any, nodeId: string, createdAt: any, body: string, snowflakeId: any, author?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined } | null | undefined, likes: { __typename?: 'PostLikesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostLike', user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, parentPost?: { __typename?: 'Post', uuid: any } | null | undefined, language?: { __typename?: 'Language', alpha2: string } | null | undefined, prompt?: { __typename?: 'Prompt', content?: string | null | undefined, uuid: any, type: PromptType } | null | undefined, userMentions: { __typename?: 'PostUserMentionsConnection', nodes: Array<{ __typename?: 'PostUserMention', startIndex: number, endIndex: number, uuid: any, user?: { __typename?: 'User', displayName?: string | null | undefined, username?: string | null | undefined, uuid: any } | null | undefined } | null | undefined> } } | null | undefined> }, recordings: { __typename?: 'PostRecordingsConnection', totalCount: number, nodes: Array<{ __typename?: 'PostRecording', filename: string, extension?: string | null | undefined, uuid: any, user?: { __typename?: 'User', uuid: any } | null | undefined } | null | undefined> }, language?: { __typename?: 'Language', alpha2: string } | null | undefined, prompt?: { __typename?: 'Prompt', content?: string | null | undefined, uuid: any, type: PromptType } | null | undefined, games: { __typename?: 'PostGamesConnection', nodes: Array<{ __typename?: 'PostGame', gameType: PostGameType, uuid: any, revealedByCurrentUser?: boolean | null | undefined, ranges: { __typename?: 'PostGameRangesConnection', totalCount: number, nodes: Array<{ __typename?: 'PostGameRange', endIndex: number, startIndex: number, uuid: any, answers: { __typename?: 'PostGameAnswersConnection', edges: Array<{ __typename?: 'PostGameAnswersEdge', node?: { __typename?: 'PostGameAnswer', id: number } | null | undefined }> } } | null | undefined> }, answersByCurrentUser: { __typename?: 'PostGameAnswersConnection', totalCount: number, nodes: Array<{ __typename?: 'PostGameAnswer', caseOption?: GrammaticalCase | null | undefined, clozeAnswer?: string | null | undefined, correct?: boolean | null | undefined, genderOption?: GrammaticalGender | null | undefined, range?: { __typename?: 'PostGameRange', uuid: any } | null | undefined } | null | undefined> }, correctAnswers: { __typename?: 'PostGamesCorrectAnswersConnection', nodes: Array<{ __typename?: 'PostGamesCorrectAnswersRecord', caseOption?: GrammaticalCase | null | undefined, clozeAnswer?: string | null | undefined, genderOption?: GrammaticalGender | null | undefined, rangeUuid?: any | null | undefined } | null | undefined> }, answerers: { __typename?: 'UsersConnection', totalCount: number } } | null | undefined> }, corrections: { __typename?: 'PostCorrectionsConnection', nodes: Array<{ __typename?: 'PostCorrection', body: string, endIndex: number, createdAt: any, startIndex: number, uuid: any, user?: { __typename?: 'User', uuid: any, username?: string | null | undefined, avatarUrl?: string | null | undefined, displayName?: string | null | undefined } | null | undefined } | null | undefined> } } | null | undefined> } } | null | undefined };

export type UserProfileQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type UserProfileQuery = { __typename?: 'Query', userByUsername?: { __typename?: 'User', bio: string, gender?: string | null | undefined, username?: string | null | undefined, avatarUrl?: string | null | undefined, uuid: any, displayName?: string | null | undefined, userLanguages: { __typename?: 'UserLanguagesConnection', totalCount: number, nodes: Array<{ __typename?: 'UserLanguage', native: boolean, language?: { __typename?: 'Language', englishName: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined } | null | undefined } | null | undefined> } } | null | undefined };

export type CreateUserMutationVariables = Exact<{
  email: Scalars['String'];
  gender: Scalars['String'];
  passwordHash: Scalars['String'];
  username: Scalars['String'];
  uuid: Scalars['UUID'];
  avatarUrl: Scalars['String'];
  locale?: Maybe<Scalars['Int']>;
  emailUnsubscribeToken: Scalars['String'];
}>;


export type CreateUserMutation = { __typename?: 'Mutation', createUser?: { __typename?: 'CreateUserPayload', user?: { __typename?: 'User', id: number } | null | undefined } | null | undefined };

export type CreateUserLanguageMutationVariables = Exact<{
  languageId: Scalars['Int'];
  languageSkillLevelId?: Maybe<Scalars['Int']>;
  native: Scalars['Boolean'];
  userId: Scalars['Int'];
}>;


export type CreateUserLanguageMutation = { __typename?: 'Mutation', createUserLanguage?: { __typename?: 'CreateUserLanguagePayload', userLanguage?: { __typename?: 'UserLanguage', id: number } | null | undefined } | null | undefined };

export type CreateUserPreferenceMutationVariables = Exact<{
  feedLanguageId: Scalars['Int'];
  userId: Scalars['Int'];
}>;


export type CreateUserPreferenceMutation = { __typename?: 'Mutation', createUserPreference?: { __typename?: 'CreateUserPreferencePayload', userPreference?: { __typename?: 'UserPreference', createdAt: any, id: number, nodeId: string, feedLanguageId: number } | null | undefined } | null | undefined };

export type CurrentUserProfileQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserProfileQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', bio: string, email: string, gender?: string | null | undefined, username?: string | null | undefined, avatarUrl?: string | null | undefined, uuid: any, displayName?: string | null | undefined, userLanguages: { __typename?: 'UserLanguagesConnection', totalCount: number, nodes: Array<{ __typename?: 'UserLanguage', native: boolean, language?: { __typename?: 'Language', englishName: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined } | null | undefined } | null | undefined> }, groupUsers: { __typename?: 'GroupUsersConnection', nodes: Array<{ __typename?: 'GroupUser', nodeId: string, userType: UserType, joinedOn: any, group?: { __typename?: 'Group', uuid: any, groupName?: string | null | undefined, language?: { __typename?: 'Language', englishName: string } | null | undefined, languageSkillLevel?: { __typename?: 'LanguageSkillLevel', name?: string | null | undefined } | null | undefined } | null | undefined } | null | undefined> } } | null | undefined };

export type ResetUserPasswordMutationVariables = Exact<{
  id: Scalars['Int'];
  passwordHash: Scalars['String'];
}>;


export type ResetUserPasswordMutation = { __typename?: 'Mutation', updateUser?: { __typename?: 'UpdateUserPayload', user?: { __typename?: 'User', id: number } | null | undefined } | null | undefined };

export type UpdateUserAvatarUrlMutationVariables = Exact<{
  avatarUrl: Scalars['String'];
  id: Scalars['Int'];
}>;


export type UpdateUserAvatarUrlMutation = { __typename?: 'Mutation', updateUser?: { __typename?: 'UpdateUserPayload', user?: { __typename?: 'User', avatarUrl?: string | null | undefined } | null | undefined } | null | undefined };

export type UpdateUserBioMutationVariables = Exact<{
  bio: Scalars['String'];
  id: Scalars['Int'];
}>;


export type UpdateUserBioMutation = { __typename?: 'Mutation', updateUser?: { __typename?: 'UpdateUserPayload', user?: { __typename?: 'User', bio: string } | null | undefined } | null | undefined };

export type UpdateUserResetPasswordTokenMutationVariables = Exact<{
  id: Scalars['Int'];
  resetPasswordToken: Scalars['String'];
  resetPasswordTokenCreatedAt: Scalars['Datetime'];
}>;


export type UpdateUserResetPasswordTokenMutation = { __typename?: 'Mutation', updateUser?: { __typename?: 'UpdateUserPayload', user?: { __typename?: 'User', id: number, resetPasswordTokenCreatedAt?: any | null | undefined, resetPasswordToken?: string | null | undefined } | null | undefined } | null | undefined };

export type UpsertUserPreferenceMutationVariables = Exact<{
  feedLanguageId: Scalars['Int'];
  userId: Scalars['Int'];
}>;


export type UpsertUserPreferenceMutation = { __typename?: 'Mutation', upsertUserPreference?: { __typename?: 'UpsertUserPreferencePayload', userPreference?: { __typename?: 'UserPreference', createdAt: any, id: number, nodeId: string, feedLanguageId: number } | null | undefined } | null | undefined };

export type UserByResetPasswordTokenQueryVariables = Exact<{
  resetPasswordToken: Scalars['String'];
}>;


export type UserByResetPasswordTokenQuery = { __typename?: 'Query', userByResetPasswordToken?: { __typename?: 'User', resetPasswordTokenCreatedAt?: any | null | undefined, resetPasswordToken?: string | null | undefined, id: number, googleId?: string | null | undefined } | null | undefined };

export type UserHasCompletedProfileQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type UserHasCompletedProfileQuery = { __typename?: 'Query', user?: { __typename?: 'User', username?: string | null | undefined, userLanguages: { __typename?: 'UserLanguagesConnection', totalCount: number } } | null | undefined };

export type UserIdByEmailQueryVariables = Exact<{
  email: Scalars['String'];
}>;


export type UserIdByEmailQuery = { __typename?: 'Query', userByEmail?: { __typename?: 'User', id: number } | null | undefined };

export type UserIdByUsernameQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type UserIdByUsernameQuery = { __typename?: 'Query', userByUsername?: { __typename?: 'User', id: number } | null | undefined };

export type UserIdByUuidQueryVariables = Exact<{
  uuid: Scalars['UUID'];
}>;


export type UserIdByUuidQuery = { __typename?: 'Query', userByUuid?: { __typename?: 'User', id: number } | null | undefined };

export type UserLanguageInfoQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type UserLanguageInfoQuery = { __typename?: 'Query', user?: { __typename?: 'User', id: number, uuid: any, userLanguages: { __typename?: 'UserLanguagesConnection', nodes: Array<{ __typename?: 'UserLanguage', nodeId: string, languageId: number, languageSkillLevelId?: number | null | undefined, native: boolean } | null | undefined> } } | null | undefined };

export type UserPasswordResetDataByEmailQueryVariables = Exact<{
  email: Scalars['String'];
}>;


export type UserPasswordResetDataByEmailQuery = { __typename?: 'Query', userByEmail?: { __typename?: 'User', id: number, resetPasswordToken?: string | null | undefined, resetPasswordTokenCreatedAt?: any | null | undefined, unconfirmedEmail?: string | null | undefined, googleId?: string | null | undefined, email: string } | null | undefined };

export type UserUuidByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type UserUuidByIdQuery = { __typename?: 'Query', user?: { __typename?: 'User', uuid: any } | null | undefined };


export const ChatUser = gql`
    query ChatUser($id: Int!) {
  user(id: $id) {
    id
    username
    uuid
    avatarUrl
  }
}
    `;
export const CreateMessage = gql`
    mutation CreateMessage($parentMessageId: Int, $recipientGroupId: Int, $recipientId: Int, $senderId: Int, $uuid: UUID!, $body: String!) {
  createMessage(
    input: {message: {body: $body, parentMessageId: $parentMessageId, uuid: $uuid, senderId: $senderId, recipientGroupId: $recipientGroupId, recipientId: $recipientId}}
  ) {
    sender {
      uuid
    }
    message {
      id
      uuid
      createdAt
    }
  }
}
    `;
export const CreateMessagePreview = gql`
    mutation CreateMessagePreview($messageId: Int!, $filename: String!, $extension: String, $uuid: UUID!) {
  createMessagePreview(
    input: {messagePreview: {uuid: $uuid, filename: $filename, extension: $extension, messageId: $messageId}}
  ) {
    messagePreview {
      id
    }
  }
}
    `;
export const GroupChat = gql`
    query GroupChat($groupUuid: UUID!) {
  groupByUuid(uuid: $groupUuid) {
    groupName
    language {
      englishName
    }
    languageSkillLevel {
      name
      nodeId
    }
    uuid
    usersByGroupUserGroupIdAndUserId {
      nodes {
        bio
        avatarUrl
        uuid
        username
        lastActiveAt
        userLanguages {
          nodes {
            nodeId
            language {
              englishName
            }
          }
        }
        groupUsers {
          nodes {
            userType
            group {
              uuid
              language {
                englishName
              }
              languageSkillLevel {
                name
              }
            }
            nodeId
          }
        }
      }
    }
  }
}
    `;
export const GroupChatMessages = gql`
    query GroupChatMessages($groupUuid: UUID!, $before: Cursor) {
  groupByUuid(uuid: $groupUuid) {
    messagesByRecipientGroupId(orderBy: CREATED_AT_ASC, last: 128, before: $before) {
      edges {
        node {
          body
          createdAt
          sender {
            uuid
          }
          uuid
          messagePreviews {
            nodes {
              uuid
              filename
              extension
            }
          }
        }
      }
      pageInfo {
        startCursor
        hasPreviousPage
      }
    }
  }
}
    `;
export const CurrentUser = gql`
    query CurrentUser {
  currentUser {
    bio
    email
    gender
    username
    uuid
    avatarUrl
    userLanguages {
      totalCount
    }
    languageByLocale {
      alpha2
    }
    inviteTokens {
      nodes {
        inviteToken
      }
    }
    preference {
      feedLanguage {
        alpha2
      }
    }
  }
}
    `;
export const RegisterUserActivity = gql`
    mutation RegisterUserActivity($userId: Int!) {
  registerUserActivity(input: {userId: $userId}) {
    datetime
  }
}
    `;
export const CreatePost = gql`
    mutation CreatePost($authorId: Int!, $body: String!, $parentPostId: Int, $languageId: Int!, $promptId: Int) {
  createPost(
    input: {post: {authorId: $authorId, parentPostId: $parentPostId, body: $body, languageId: $languageId, promptId: $promptId}}
  ) {
    clientMutationId
    post {
      body
      createdAt
      id
      uuid
      nodeId
      snowflakeId
    }
  }
}
    `;
export const CreatePostCorrection = gql`
    mutation CreatePostCorrection($userId: Int!, $postId: Int!, $body: String!, $endIndex: Int!, $startIndex: Int!, $uuid: UUID!) {
  createPostCorrection(
    input: {postCorrection: {postId: $postId, userId: $userId, body: $body, endIndex: $endIndex, startIndex: $startIndex, uuid: $uuid}}
  ) {
    postCorrection {
      id
      postId
      userId
      nodeId
      createdAt
      endIndex
      startIndex
      uuid
      body
    }
  }
}
    `;
export const CreatePostGame = gql`
    mutation CreatePostGame($postId: Int!, $gameType: PostGameType!) {
  createPostGame(input: {postGame: {postId: $postId, gameType: $gameType}}) {
    postGame {
      id
      postId
      nodeId
      createdAt
    }
  }
}
    `;
export const CreatePostGameAnswer = gql`
    mutation CreatePostGameAnswer($genderOption: GrammaticalGender, $caseOption: GrammaticalCase, $correct: Boolean, $rangeId: Int, $gameId: Int, $userId: Int!, $clozeAnswer: String) {
  createPostGameAnswer(
    input: {postGameAnswer: {rangeId: $rangeId, gameId: $gameId, userId: $userId, correct: $correct, genderOption: $genderOption, clozeAnswer: $clozeAnswer, caseOption: $caseOption}}
  ) {
    postGameAnswer {
      id
      nodeId
      createdAt
      caseOption
      uuid
      range {
        uuid
      }
      game {
        uuid
      }
      correct
      clozeAnswer
      genderOption
    }
  }
}
    `;
export const CreatePostGameRange = gql`
    mutation CreatePostGameRange($gameId: Int!, $startIndex: Int!, $endIndex: Int!, $genderOption: GrammaticalGender, $caseOption: GrammaticalCase, $uuid: UUID) {
  createPostGameRange(
    input: {postGameRange: {gameId: $gameId, startIndex: $startIndex, endIndex: $endIndex, genderOption: $genderOption, caseOption: $caseOption, uuid: $uuid}}
  ) {
    postGameRange {
      id
      gameId
      nodeId
      createdAt
      caseOption
      endIndex
      startIndex
      uuid
    }
  }
}
    `;
export const CreatePostLike = gql`
    mutation CreatePostLike($userId: Int!, $postId: Int!) {
  createPostLike(input: {postLike: {postId: $postId, userId: $userId}}) {
    postLike {
      id
      postId
      userId
      nodeId
      createdAt
    }
  }
}
    `;
export const CreatePostRecording = gql`
    mutation CreatePostRecording($userId: Int!, $postId: Int!, $filename: String!, $extension: String = "") {
  createPostRecording(
    input: {postRecording: {userId: $userId, postId: $postId, filename: $filename, extension: $extension}}
  ) {
    postRecording {
      createdAt
      extension
      filename
      uuid
      nodeId
    }
  }
}
    `;
export const CreatePostUserMention = gql`
    mutation CreatePostUserMention($userId: Int!, $postId: Int!, $endIndex: Int!, $startIndex: Int!) {
  createPostUserMention(
    input: {postUserMention: {postId: $postId, userId: $userId, endIndex: $endIndex, startIndex: $startIndex}}
  ) {
    postUserMention {
      id
      postId
      userId
      nodeId
      createdAt
      endIndex
      startIndex
      uuid
    }
  }
}
    `;
export const CurrentUserHasAnsweredOrRevealedPostGame = gql`
    query CurrentUserHasAnsweredOrRevealedPostGame($gameId: Int!) {
  postGame(id: $gameId) {
    answersByCurrentUser {
      totalCount
    }
    revealedByCurrentUser
  }
}
    `;
export const DeletePostLike = gql`
    mutation DeletePostLike($id: Int!) {
  deletePostLike(input: {id: $id}) {
    postLike {
      postId
      userId
      nodeId
      createdAt
    }
  }
}
    `;
export const FeedPosts = gql`
    query FeedPosts($locale: String!, $afterUuid: UUID) {
  feedPosts(locale: $locale, afterUuid: $afterUuid) {
    edges {
      node {
        uuid
        nodeId
        createdAt
        author {
          uuid
          username
          avatarUrl
          displayName
        }
        body
        likes {
          totalCount
          nodes {
            user {
              uuid
            }
          }
        }
        parentPost {
          uuid
        }
        replies(orderBy: CREATED_AT_ASC, filter: {not: {parentPostId: {isNull: true}}}) {
          totalCount
          nodes {
            uuid
            nodeId
            createdAt
            author {
              uuid
              username
              avatarUrl
            }
            likes {
              totalCount
              nodes {
                user {
                  uuid
                }
              }
            }
            body
            parentPost {
              uuid
            }
            language {
              alpha2
            }
            prompt {
              content
              uuid
              type
            }
            snowflakeId
            userMentions {
              nodes {
                startIndex
                user {
                  displayName
                  username
                  uuid
                }
                endIndex
                uuid
              }
            }
          }
        }
        recordings {
          totalCount
          nodes {
            filename
            extension
            uuid
            user {
              uuid
            }
          }
        }
        language {
          alpha2
        }
        prompt {
          content
          uuid
          type
        }
        snowflakeId
        games {
          nodes {
            gameType
            uuid
            ranges {
              nodes {
                answers {
                  edges {
                    node {
                      id
                    }
                  }
                }
                endIndex
                startIndex
                uuid
              }
              totalCount
            }
            revealedByCurrentUser
            answersByCurrentUser {
              nodes {
                caseOption
                clozeAnswer
                correct
                genderOption
                range {
                  uuid
                }
              }
              totalCount
            }
            correctAnswers {
              nodes {
                caseOption
                clozeAnswer
                genderOption
                rangeUuid
              }
            }
            answerers {
              totalCount
            }
          }
        }
        corrections {
          nodes {
            body
            endIndex
            createdAt
            startIndex
            uuid
            user {
              uuid
              username
              avatarUrl
              displayName
            }
          }
        }
      }
    }
  }
}
    `;
export const PostGameByUuid = gql`
    query PostGameByUuid($uuid: UUID!) {
  postGameByUuid(uuid: $uuid) {
    id
    nodeId
    ranges {
      nodes {
        uuid
        id
        caseOption
        genderOption
        startIndex
        endIndex
      }
    }
    gameType
    post {
      authorId
      language {
        alpha2
      }
    }
    correctAnswers {
      nodes {
        caseOption
        clozeAnswer
        genderOption
        rangeUuid
      }
    }
  }
}
    `;
export const PostGameIdByUuid = gql`
    query PostGameIdByUuid($uuid: UUID!) {
  postGameByUuid(uuid: $uuid) {
    id
    nodeId
  }
}
    `;
export const PostIdByUuid = gql`
    query PostIdByUuid($uuid: UUID!) {
  postByUuid(uuid: $uuid) {
    id
    nodeId
  }
}
    `;
export const PostLikeIdByPostIdAndUserId = gql`
    query PostLikeIdByPostIdAndUserId($postId: Int!, $userId: Int!) {
  postLikes(condition: {postId: $postId, userId: $userId}) {
    nodes {
      id
      nodeId
    }
    totalCount
  }
}
    `;
export const PromptIdByUuid = gql`
    query PromptIdByUuid($uuid: UUID!) {
  promptByUuid(uuid: $uuid) {
    id
    nodeId
  }
}
    `;
export const SinglePost = gql`
    query SinglePost($snowflakeId: BigInt!) {
  posts(condition: {parentPostId: null, snowflakeId: $snowflakeId}) {
    nodes {
      uuid
      nodeId
      createdAt
      author {
        uuid
        username
        avatarUrl
        displayName
      }
      body
      likes {
        totalCount
        nodes {
          user {
            uuid
          }
        }
      }
      parentPost {
        uuid
      }
      replies(orderBy: CREATED_AT_ASC, filter: {not: {parentPostId: {isNull: true}}}) {
        totalCount
        nodes {
          uuid
          nodeId
          createdAt
          author {
            uuid
            username
            avatarUrl
          }
          likes {
            totalCount
            nodes {
              user {
                uuid
              }
            }
          }
          body
          parentPost {
            uuid
          }
          language {
            alpha2
          }
          prompt {
            content
            uuid
            type
          }
          snowflakeId
          userMentions {
            nodes {
              startIndex
              user {
                displayName
                username
                uuid
              }
              endIndex
              uuid
            }
          }
        }
      }
      recordings {
        totalCount
        nodes {
          filename
          extension
          uuid
          user {
            uuid
          }
        }
      }
      language {
        alpha2
      }
      prompt {
        content
        uuid
        type
      }
      snowflakeId
      games {
        nodes {
          gameType
          uuid
          ranges {
            nodes {
              answers {
                edges {
                  node {
                    id
                  }
                }
              }
              endIndex
              startIndex
              uuid
            }
            totalCount
          }
          revealedByCurrentUser
          answersByCurrentUser {
            nodes {
              caseOption
              clozeAnswer
              correct
              genderOption
              range {
                uuid
              }
            }
            totalCount
          }
          correctAnswers {
            nodes {
              caseOption
              clozeAnswer
              genderOption
              rangeUuid
            }
          }
          answerers {
            totalCount
          }
        }
      }
      corrections {
        nodes {
          body
          endIndex
          createdAt
          startIndex
          uuid
          user {
            uuid
            username
            avatarUrl
            displayName
          }
        }
      }
    }
  }
}
    `;
export const CreateUserFollowership = gql`
    mutation CreateUserFollowership($userId: Int!, $followerId: Int!) {
  createUserFollower(
    input: {userFollower: {userId: $userId, followerId: $followerId}}
  ) {
    userFollower {
      id
      userId
      followerId
      nodeId
      createdAt
    }
  }
}
    `;
export const DeleteUserFollowership = gql`
    mutation DeleteUserFollowership($id: Int!) {
  deleteUserFollower(input: {id: $id}) {
    userFollower {
      followerId
      userId
      nodeId
      createdAt
    }
  }
}
    `;
export const UserByUsernameFollowerships = gql`
    query UserByUsernameFollowerships($username: String!) {
  userByUsername(username: $username) {
    followers {
      nodes {
        follower {
          uuid
          avatarUrl
          bio
          displayName
          username
          followedByCurrentUser
        }
      }
    }
    followedUsers {
      nodes {
        user {
          avatarUrl
          bio
          displayName
          uuid
          followedByCurrentUser
          username
        }
      }
    }
  }
}
    `;
export const UserFollowershipIdByUserIdAndFollowerId = gql`
    query UserFollowershipIdByUserIdAndFollowerId($followerId: Int!, $userId: Int!) {
  userFollowers(condition: {followerId: $followerId, userId: $userId}) {
    nodes {
      id
      nodeId
    }
    totalCount
  }
}
    `;
export const CreateGroupUser = gql`
    mutation CreateGroupUser($userType: UserType!, $userId: Int!, $groupId: Int!) {
  createGroupUser(
    input: {groupUser: {userType: $userType, userId: $userId, groupId: $groupId}}
  ) {
    groupUser {
      id
    }
  }
}
    `;
export const JoinGlobalGroup = gql`
    mutation JoinGlobalGroup($groupUuid: UUID!) {
  joinGlobalGroup(input: {groupUuid: $groupUuid}) {
    groupUser {
      group {
        uuid
      }
      user {
        uuid
      }
      nodeId
    }
  }
}
    `;
export const UserGroupMemberships = gql`
    query UserGroupMemberships($id: Int!) {
  user(id: $id) {
    groupUsers {
      edges {
        node {
          group {
            global
            uuid
            groupName
            language {
              alpha2
            }
            languageSkillLevel {
              name
            }
          }
          userType
        }
      }
    }
  }
}
    `;
export const UserIsInGroup = gql`
    query UserIsInGroup($userId: Int!, $groupUuid: UUID!) {
  groupByUuid(uuid: $groupUuid) {
    groupUsers(condition: {userId: $userId}) {
      totalCount
    }
  }
}
    `;
export const UsersWithoutLearnerGroup = gql`
    query UsersWithoutLearnerGroup($lid: Int!, $lsklid: Int!, $learnerSize: Int!) {
  usersWithoutLearnerGroup(lid: $lid, lsklid: $lsklid, first: $learnerSize) {
    nodes {
      id
    }
  }
}
    `;
export const UsersWithoutNativeGroup = gql`
    query UsersWithoutNativeGroup($lid: Int!, $nativeSize: Int!) {
  usersWithoutNativeGroup(lid: $lid, first: $nativeSize) {
    nodes {
      id
    }
  }
}
    `;
export const AllGroupUuids = gql`
    query AllGroupUuids {
  groups {
    nodes {
      uuid
    }
  }
}
    `;
export const AllGroups = gql`
    query AllGroups {
  groups {
    nodes {
      uuid
      groupName
      global
      language {
        alpha2
        englishName
      }
      languageSkillLevel {
        name
        nodeId
      }
      groupUsers {
        totalCount
        nodes {
          user {
            avatarUrl
            username
            uuid
          }
          joinedOn
        }
      }
    }
  }
}
    `;
export const CreateGroup = gql`
    mutation CreateGroup($global: Boolean!, $groupName: String!, $languageId: Int!, $languageSkillLevelId: Int!, $uuid: UUID!) {
  createGroup(
    input: {group: {global: $global, groupName: $groupName, languageId: $languageId, languageSkillLevelId: $languageSkillLevelId, uuid: $uuid}}
  ) {
    group {
      id
      uuid
    }
  }
}
    `;
export const GroupIdByUuid = gql`
    query GroupIdByUuid($uuid: UUID!) {
  groupByUuid(uuid: $uuid) {
    id
  }
}
    `;
export const GroupLanguageByUuid = gql`
    query GroupLanguageByUuid($uuid: UUID!) {
  groupByUuid(uuid: $uuid) {
    language {
      alpha2
    }
    uuid
  }
}
    `;
export const LanguageCodeMappings = gql`
    query LanguageCodeMappings {
  languages {
    nodes {
      alpha2
      englishName
    }
  }
}
    `;
export const LanguageIdByAlpha2 = gql`
    query LanguageIdByAlpha2($alpha2: String!) {
  languageByAlpha2(alpha2: $alpha2) {
    id
  }
}
    `;
export const AdminEmailsFcmTokens = gql`
    query AdminEmailsFcmTokens($in: [String!]!) {
  users(filter: {email: {in: $in}}) {
    nodes {
      userDevices {
        nodes {
          fcmToken
        }
      }
    }
  }
}
    `;
export const CreateNotification = gql`
    mutation CreateNotification($channelId: Int!, $recipientId: Int, $recipientGroupId: Int, $sentAt: Datetime, $params: JSON, $expiresAt: Datetime, $withheldUntil: Datetime) {
  createNotification(
    input: {notification: {channelId: $channelId, recipientId: $recipientId, recipientGroupId: $recipientGroupId, params: $params, sentAt: $sentAt, expiresAt: $expiresAt, withheldUntil: $withheldUntil}}
  ) {
    clientMutationId
    notification {
      createdAt
      expiresAt
      withheldUntil
      id
    }
  }
}
    `;
export const CreateUserDevice = gql`
    mutation CreateUserDevice($userId: Int!, $fcmToken: String) {
  createUserDevice(input: {userDevice: {userId: $userId, fcmToken: $fcmToken}}) {
    userDevice {
      uuid
      fcmToken
      id
    }
  }
}
    `;
export const DeleteInvalidFcmToken = gql`
    mutation DeleteInvalidFcmToken($fcmToken: String!) {
  deleteUserDeviceByFcmToken(input: {fcmToken: $fcmToken}) {
    userDevice {
      userId
      fcmToken
      id
    }
    clientMutationId
  }
}
    `;
export const GroupMessageNotification = gql`
    query GroupMessageNotification($groupUuid: UUID!, $senderUuid: UUID!) {
  groupByUuid(uuid: $groupUuid) {
    groupUsers {
      nodes {
        user {
          uuid
          userDevices {
            nodes {
              fcmToken
            }
          }
        }
      }
    }
    groupName
    uuid
    language {
      alpha2
    }
    languageSkillLevel {
      name
    }
  }
  userByUuid(uuid: $senderUuid) {
    username
  }
}
    `;
export const MarkNotificationAsSent = gql`
    mutation MarkNotificationAsSent($id: Int!, $sentAt: Datetime) {
  updateNotification(input: {patch: {sentAt: $sentAt}, id: $id}) {
    notification {
      id
      sentAt
    }
  }
}
    `;
export const NotificationChannelByName = gql`
    query NotificationChannelByName($name: String!) {
  notificationChannelByName(name: $name) {
    id
  }
}
    `;
export const OutstandingEmailNotifications = gql`
    query OutstandingEmailNotifications {
  notificationChannelByName(name: "Email") {
    notificationsByChannelId(
      orderBy: CREATED_AT_ASC
      filter: {sentAt: {isNull: true}}
    ) {
      nodes {
        id
        recipient {
          email
          emailNotificationsEnabled
          username
          unconfirmedEmail
        }
        params
        expiresAt
        withheldUntil
      }
    }
  }
}
    `;
export const OutstandingFcmNotifications = gql`
    query OutstandingFcmNotifications {
  notificationChannelByName(name: "Firebase Cloud Messaging") {
    notificationsByChannelId(
      orderBy: CREATED_AT_ASC
      filter: {sentAt: {isNull: true}}
    ) {
      nodes {
        id
        recipient {
          userDevices {
            nodes {
              fcmToken
            }
          }
          uuid
        }
        params
        expiresAt
        withheldUntil
        recipientGroup {
          uuid
          groupUsers {
            nodes {
              user {
                userDevices {
                  nodes {
                    fcmToken
                  }
                }
                uuid
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const PostLikeNotification = gql`
    query PostLikeNotification($id: Int!) {
  postLike(id: $id) {
    post {
      authorId
      body
      parentPostId
      snowflakeId
    }
    user {
      id
      username
      displayName
    }
  }
}
    `;
export const PostReplyNotification = gql`
    query PostReplyNotification($id: Int!) {
  post(id: $id) {
    authorId
    parentPost {
      authorId
      snowflakeId
    }
    body
    createdAt
    author {
      displayName
      username
    }
    snowflakeId
  }
}
    `;
export const PostUserMentionNotification = gql`
    query PostUserMentionNotification($id: Int!) {
  postUserMention(id: $id) {
    userId
    postId
    post {
      parentPost {
        authorId
        snowflakeId
      }
      body
      author {
        displayName
        username
      }
    }
  }
}
    `;
export const UnsubscribeUserEmailNotifications = gql`
    mutation UnsubscribeUserEmailNotifications($token: String!, $lastActiveAt: Datetime!) {
  updateUserByEmailUnsubscribeToken(
    input: {patch: {emailNotificationsEnabled: false, lastActiveAt: $lastActiveAt}, emailUnsubscribeToken: $token}
  ) {
    clientMutationId
    user {
      email
      uuid
      username
    }
  }
}
    `;
export const UserFollowershipNotification = gql`
    query UserFollowershipNotification($id: Int!) {
  userFollower(id: $id) {
    follower {
      username
      displayName
    }
    user {
      id
    }
  }
}
    `;
export const UserPasswordResetEmailNotification = gql`
    query UserPasswordResetEmailNotification($id: Int!) {
  user(id: $id) {
    username
    displayName
    resetPasswordToken
  }
}
    `;
export const UserPasswordResetSuccessEmailNotification = gql`
    query UserPasswordResetSuccessEmailNotification($id: Int!) {
  user(id: $id) {
    username
    displayName
  }
}
    `;
export const UserByUsernamePosts = gql`
    query UserByUsernamePosts($username: String!) {
  userByUsername(username: $username) {
    authoredPosts(orderBy: CREATED_AT_DESC, condition: {parentPostId: null}) {
      nodes {
        uuid
        nodeId
        createdAt
        author {
          uuid
          username
          avatarUrl
          displayName
        }
        body
        likes {
          totalCount
          nodes {
            user {
              uuid
            }
          }
        }
        parentPost {
          uuid
        }
        replies(orderBy: CREATED_AT_ASC, filter: {not: {parentPostId: {isNull: true}}}) {
          totalCount
          nodes {
            uuid
            nodeId
            createdAt
            author {
              uuid
              username
              avatarUrl
            }
            likes {
              totalCount
              nodes {
                user {
                  uuid
                }
              }
            }
            body
            parentPost {
              uuid
            }
            language {
              alpha2
            }
            prompt {
              content
              uuid
              type
            }
            snowflakeId
            userMentions {
              nodes {
                startIndex
                user {
                  displayName
                  username
                  uuid
                }
                endIndex
                uuid
              }
            }
          }
        }
        recordings {
          totalCount
          nodes {
            filename
            extension
            uuid
            user {
              uuid
            }
          }
        }
        language {
          alpha2
        }
        prompt {
          content
          uuid
          type
        }
        snowflakeId
        games {
          nodes {
            gameType
            uuid
            ranges {
              nodes {
                answers {
                  edges {
                    node {
                      id
                    }
                  }
                }
                endIndex
                startIndex
                uuid
              }
              totalCount
            }
            revealedByCurrentUser
            answersByCurrentUser {
              nodes {
                caseOption
                clozeAnswer
                correct
                genderOption
                range {
                  uuid
                }
              }
              totalCount
            }
            correctAnswers {
              nodes {
                caseOption
                clozeAnswer
                genderOption
                rangeUuid
              }
            }
            answerers {
              totalCount
            }
          }
        }
        corrections {
          nodes {
            body
            endIndex
            createdAt
            startIndex
            uuid
            user {
              uuid
              username
              avatarUrl
              displayName
            }
          }
        }
      }
    }
  }
}
    `;
export const UserProfile = gql`
    query UserProfile($username: String!) {
  userByUsername(username: $username) {
    bio
    gender
    username
    avatarUrl
    uuid
    userLanguages {
      totalCount
      nodes {
        language {
          englishName
        }
        languageSkillLevel {
          name
        }
        native
      }
    }
    displayName
  }
}
    `;
export const CreateUser = gql`
    mutation CreateUser($email: String!, $gender: String!, $passwordHash: String!, $username: String!, $uuid: UUID!, $avatarUrl: String!, $locale: Int, $emailUnsubscribeToken: String!) {
  createUser(
    input: {user: {email: $email, gender: $gender, passwordHash: $passwordHash, username: $username, uuid: $uuid, avatarUrl: $avatarUrl, locale: $locale, emailUnsubscribeToken: $emailUnsubscribeToken}}
  ) {
    user {
      id
    }
  }
}
    `;
export const CreateUserLanguage = gql`
    mutation CreateUserLanguage($languageId: Int!, $languageSkillLevelId: Int, $native: Boolean!, $userId: Int!) {
  createUserLanguage(
    input: {userLanguage: {languageId: $languageId, languageSkillLevelId: $languageSkillLevelId, native: $native, userId: $userId}}
  ) {
    userLanguage {
      id
    }
  }
}
    `;
export const CreateUserPreference = gql`
    mutation CreateUserPreference($feedLanguageId: Int!, $userId: Int!) {
  createUserPreference(
    input: {userPreference: {feedLanguageId: $feedLanguageId, userId: $userId}}
  ) {
    userPreference {
      createdAt
      id
      nodeId
      feedLanguageId
    }
  }
}
    `;
export const CurrentUserProfile = gql`
    query CurrentUserProfile {
  currentUser {
    bio
    email
    gender
    username
    avatarUrl
    uuid
    userLanguages {
      totalCount
      nodes {
        language {
          englishName
        }
        languageSkillLevel {
          name
        }
        native
      }
    }
    groupUsers {
      nodes {
        nodeId
        group {
          uuid
          groupName
          language {
            englishName
          }
          languageSkillLevel {
            name
          }
        }
        userType
        joinedOn
      }
    }
    displayName
  }
}
    `;
export const ResetUserPassword = gql`
    mutation ResetUserPassword($id: Int!, $passwordHash: String!) {
  updateUser(
    input: {patch: {passwordHash: $passwordHash, resetPasswordToken: null, resetPasswordTokenCreatedAt: null}, id: $id}
  ) {
    user {
      id
    }
  }
}
    `;
export const UpdateUserAvatarUrl = gql`
    mutation UpdateUserAvatarUrl($avatarUrl: String!, $id: Int!) {
  updateUser(input: {patch: {avatarUrl: $avatarUrl}, id: $id}) {
    user {
      avatarUrl
    }
  }
}
    `;
export const UpdateUserBio = gql`
    mutation UpdateUserBio($bio: String!, $id: Int!) {
  updateUser(input: {patch: {bio: $bio}, id: $id}) {
    user {
      bio
    }
  }
}
    `;
export const UpdateUserResetPasswordToken = gql`
    mutation UpdateUserResetPasswordToken($id: Int!, $resetPasswordToken: String!, $resetPasswordTokenCreatedAt: Datetime!) {
  updateUser(
    input: {patch: {resetPasswordTokenCreatedAt: $resetPasswordTokenCreatedAt, resetPasswordToken: $resetPasswordToken}, id: $id}
  ) {
    user {
      id
      resetPasswordTokenCreatedAt
      resetPasswordToken
    }
  }
}
    `;
export const UpsertUserPreference = gql`
    mutation UpsertUserPreference($feedLanguageId: Int!, $userId: Int!) {
  upsertUserPreference(
    input: {userPreference: {feedLanguageId: $feedLanguageId, userId: $userId}}
    where: {userId: $userId}
  ) {
    userPreference {
      createdAt
      id
      nodeId
      feedLanguageId
    }
  }
}
    `;
export const UserByResetPasswordToken = gql`
    query UserByResetPasswordToken($resetPasswordToken: String!) {
  userByResetPasswordToken(resetPasswordToken: $resetPasswordToken) {
    resetPasswordTokenCreatedAt
    resetPasswordToken
    id
    googleId
  }
}
    `;
export const UserHasCompletedProfile = gql`
    query UserHasCompletedProfile($id: Int!) {
  user(id: $id) {
    username
    userLanguages {
      totalCount
    }
  }
}
    `;
export const UserIdByEmail = gql`
    query UserIdByEmail($email: String!) {
  userByEmail(email: $email) {
    id
  }
}
    `;
export const UserIdByUsername = gql`
    query UserIdByUsername($username: String!) {
  userByUsername(username: $username) {
    id
  }
}
    `;
export const UserIdByUuid = gql`
    query UserIdByUuid($uuid: UUID!) {
  userByUuid(uuid: $uuid) {
    id
  }
}
    `;
export const UserLanguageInfo = gql`
    query UserLanguageInfo($id: Int!) {
  user(id: $id) {
    id
    uuid
    userLanguages {
      nodes {
        nodeId
        languageId
        languageSkillLevelId
        native
      }
    }
  }
}
    `;
export const UserPasswordResetDataByEmail = gql`
    query UserPasswordResetDataByEmail($email: String!) {
  userByEmail(email: $email) {
    id
    resetPasswordToken
    resetPasswordTokenCreatedAt
    unconfirmedEmail
    googleId
    email
  }
}
    `;
export const UserUuidById = gql`
    query UserUuidById($id: Int!) {
  user(id: $id) {
    uuid
  }
}
    `;